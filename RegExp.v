Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l le_n_S le_S_n.

Section CharType.

Variable C: Set.
Variable C_eq_dec: forall x y:C, {x=y}+{x<>y}.

Inductive RegExp: Set:=
| Rnil: RegExp
| Rchar: C -> RegExp
| Rcons: RegExp -> RegExp -> RegExp
| Ror: RegExp -> RegExp -> RegExp
| Rstar: RegExp -> RegExp
.

Inductive Racc: RegExp -> list C -> Prop:=
|RAchar : forall c, Racc (Rchar c) (c::nil)
|RAcons : forall l m r s, Racc r l -> Racc s m -> Racc (Rcons r s) (l++m)
|RAor1  : forall l r s, Racc r l -> Racc (Ror r s) l
|RAor2  : forall l r s, Racc s l -> Racc (Ror r s) l
|RAstar1: forall r, Racc (Rstar r) nil
|RAstar2: forall r l m, Racc r l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m)
.
Hint Constructors Racc.

Definition Remp:=Rstar Rnil.
Theorem Remp_spec: forall w, Racc Remp w<-> w=nil. Proof. unfold Remp. intros; split; intros; [|subst w]; auto. inversion H; auto. inversion H1. Qed.
Theorem Rnil_spec: forall w, ~Racc Rnil w. Proof. intros w D. inversion D. Qed.
Theorem Rchar_spec: forall w c, Racc (Rchar c) w <-> w=c::nil. Proof. intros; split; intros. inversion H; auto. subst w; auto. Qed.
Definition Rword w:=fold_right (fun c r=>Rcons (Rchar c) r) Remp w.
Theorem Rword_spec: forall w s, Racc (Rword w) s <-> s=w. Proof. induction w; intros; simpl; split; intros. apply Remp_spec; auto. apply Remp_spec; auto. inversion H. inversion H2. simpl. f_equal. apply IHw; auto. subst s. replace (a::w) with ((a::nil)++w); auto. apply RAcons; auto. apply IHw; auto. Qed.
Hint Resolve Remp_spec Rnil_spec Rchar_spec Rword_spec.

Definition Rincl: relation RegExp:= fun r s=>forall w, Racc r w -> Racc s w.
Definition Req: relation RegExp:= fun r s=> Rincl r s /\ Rincl s r.

Theorem Rstar_app: forall r l m, Racc (Rstar r) l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m). Proof. intros r l m H H0. revert H0. revert m. remember (Rstar r) as r1. revert Heqr1. induction H; intros; try discriminate Heqr1; simpl; auto. rewrite <- app_assoc. apply RAstar2; auto. Qed.
Theorem Rstar_one: forall r w, Racc r w -> Racc (Rstar r) w. Proof. intros. destruct w; auto. rewrite <- app_nil_r; apply RAstar2; auto. Qed.
Theorem Rstar_incl: forall r s, Rincl r s -> Rincl (Rstar r) (Rstar s). Proof. intros. intros w H0. remember (Rstar r) as r1. revert Heqr1. induction H0; intros; try discriminate Heqr1; auto. inversion Heqr1. subst r0. auto. Qed.
Theorem Rstar_rev': forall r w, Racc (Rstar r) w -> w<>nil -> exists l m, Racc r l /\ Racc (Rstar r) m /\ l<>nil /\ w=l++m. intros r w H. remember (Rstar r) as s. revert Heqs. revert r.  induction H; intros; try discriminate Heqs. contradict H; auto. inversion Heqs. subst r0. clear IHRacc1. destruct (list_eq_dec C_eq_dec m nil). subst m. exists l. exists nil. rewrite app_nil_r in H1. auto. destruct IHRacc2 with (r0:=r) as [l' [m' [H2 [H3 [H4 H5]]]]]; auto. subst m. destruct (list_eq_dec C_eq_dec l nil). subst l. exists l'. exists m'; auto. exists l. exists (l'++m'); auto. Qed.
Hint Resolve Rstar_app Rstar_one Rstar_incl Rstar_rev'.

Definition Rshortest: forall r, {w| Racc r w & forall s, Racc r s -> length w <= length s}+{forall w, ~Racc r w}. induction r. right; auto. left; exists (c::nil); auto. intros. apply Rchar_spec in H. subst s; auto. destruct IHr1 as [[w H1 H2]|H1]; [destruct IHr2 as [[s H3 H4]|H3]; [left|right]|right]. exists (w++s); auto. intros. inversion H. subst r s1 s0. repeat rewrite app_length. apply le_trans with (length w+length m). apply plus_le_compat_l; auto. apply plus_le_compat_r; auto. intros t D. inversion D. contradict H6; auto. intros t D. inversion D. contradict H2; auto. destruct IHr1 as [[w H1 H2]|H1]; destruct IHr2 as [[s H3 H4]|H3]. left. destruct (le_lt_dec (length w) (length s)). exists w; auto. intros. inversion H; auto. apply le_trans with (length s); auto.
  exists s; auto. intros. inversion H; auto. apply le_trans with (length w); auto. left; exists w; auto. intros. inversion H; auto. contradict H6; auto. left; exists s; auto. intros. inversion H; auto. contradict H6; auto. right. intros w D. inversion D; contradict H4; auto. left; exists nil; auto. intros. simpl; apply le_O_n. Defined.
Definition Rlang': forall r, {l|forall w, Racc r w <-> In w l}+{forall n, exists w, n<=length w /\ Racc r w}. induction r. left. exists nil. intros; split; intros; inversion H. left; exists ((c::nil)::nil). intros; split; intros. left. inversion H; auto. destruct H. subst w; auto. destruct H. destruct IHr1 as [[l1 H1]|H1]; destruct IHr2 as [[l2 H2]|H2]. left. exists (all_pair (app (A:=C)) l1 l2). intros; split; intros. inversion H. apply all_pair_spec1; auto. apply H1; auto. apply H2; auto. apply all_pair_spec2 in H. destruct H as [x [y [H3 [H4 H5]]]]. subst w. apply RAcons. apply H1; auto. apply H2; auto. destruct l1 as [|a l1]. left; exists nil. intros; split; intros; inversion H. apply H1 in H4. inversion H4. right. intros. destruct (H2 n) as [w [H3 H4]]. exists (a++w). split; auto. rewrite app_length. apply le_trans with (m:=length w); auto. apply RAcons; auto. apply H1; auto.
  destruct l2 as [|a l2]. left. exists nil. intros; split; intros; inversion H. apply H2 in H6; inversion H6. right. intros. destruct (H1 n) as [w [H3 H4]]. exists (w++a). split. rewrite app_length. apply le_trans with (length w); auto. apply RAcons; auto. apply H2; auto. right. intros. destruct (H1 n) as [w1 [H3 H4]]. destruct (H2 n) as [w2 [H5 H6]]. exists (w1++w2). split. rewrite app_length. apply le_trans with (length w1); auto. auto. destruct IHr1 as [[l1 H1]|H1]; [destruct IHr2 as [[l2 H2]|H2]|]. left; exists (l1++l2). intros; split; intros. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H; [apply H1 in H|apply H2 in H]; auto. right. intros. destruct (H2 n) as [w [H3 H4]]. exists w; auto. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto.
  destruct IHr as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[x H2 H3]|H2]. destruct x. left. exists (nil::nil). intros; split; intros. cut (w=nil). intros; subst w; auto. remember (Rstar r) as r1. revert Heqr1. induction H; intros; try discriminate Heqr1; auto. inversion Heqr1; subst r0. apply H1 in H. apply H3 in H. destruct l0. auto. inversion H. destruct H. subst w; auto. destruct H. right. intros. apply H1 in H2. clear -H2. induction n. exists (c::x). split; auto. apply le_O_n. destruct IHn as [w [H3 H4]]. exists ((c::x)++w). split; auto. simpl. apply le_n_S. rewrite app_length. apply le_trans with (length w); auto. subst l. left; exists (nil::nil). intros; split; intros. inversion H. left; auto. apply H1 in H2. inversion H2. destruct H. subst w; auto. destruct H. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto. Defined.
Definition Rlang: forall r, {l|forall w, Racc r w <-> In w l}+{forall l, exists w, Racc r w /\ ~In w l}. intros. destruct (Rlang' r) as [[l H1]|H1]; [left|right]. exists l; auto. intros. destruct (maxf (length (A:=C)) l) as [[x H3 H4]|H3]. destruct (H1 (S (length x))) as [w [H5 H6]]. exists w. split; auto. intros D. apply H4 in D. contradict H5. apply le_not_lt; auto. subst l. destruct (H1 0) as [w [H3 H4]]. exists w. split; auto. Defined.
Definition Rlongest: forall r, {w| Racc r w & forall s, Racc r s -> length s <= length w}+{forall n, exists s, Racc r s /\ n <= length s}+{forall w, ~Racc r w}. intros. destruct (Rlang' r) as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[w H2 H3]|H2]. left; left; exists w; auto. apply H1; auto. intros. apply H3. apply H1; auto. subst l. right. intros. intros D. apply H1 in D. destruct D. left; right. intros. destruct (H1 n) as [w [H2 H3]]. exists w; auto. Defined.
Definition sum_is_n: forall n, {pl|forall p, In p pl <-> fst p+snd p =n}. induction n. exists ((0,0)::nil). intros; split; intros. destruct H. subst p; auto. destruct H. destruct p. destruct n. destruct n0; auto. simpl in H. inversion H. simpl in H. inversion H. destruct IHn as [pl H]. exists ((0,S n)::map (fun p=>(S(fst p),snd p)) pl). intros. split; intros. destruct H0. subst p; auto. apply in_map_iff in H0. destruct H0 as [q [H1 H2]]. subst p. simpl. f_equal; apply H; auto. destruct p as [x y]. simpl in H0. destruct x. left; auto. right. inversion H0. apply in_map_iff. exists (x, y). split; simpl; auto. apply H. auto. Defined.
Definition Rlang_length: forall r n, {l|forall w, Racc r w/\length w=n <-> In w l}. intros. revert r. apply (Fix lt_wf) with (P:=fun n=>forall r,{l|forall w, Racc r w/\length w=n<->In w l}). clear n. intros n IH r. induction r. exists nil. intros; split; intros. destruct H; inversion H. inversion H. destruct (nat_eq_dec n 1). subst n. exists ((c::nil)::nil). intros; split; intros. destruct H. inversion H; auto. destruct H. subst w; auto. destruct H. exists nil. intros; split; intros. destruct H. contradict n0. inversion H. subst w n; auto. destruct H. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. remember (fun m=>match lt_dec m n with left _ H => match IH m H r1 with exist _ l _ => l end| right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m n with left _ H => match IH m H r2 with exist _ l _ => l end| right _ _ => l2 end) as f2. destruct (sum_is_n n) as [sl H3].
  exists (flat_map (fun p=>all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. inversion H. subst r s w. apply in_flat_map. exists (length l, length m). split. apply H3. subst n; rewrite app_length; auto. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length l) n). destruct (IH (length l) l0 r1). apply i; auto. apply H1. split; auto. destruct m. subst n; rewrite app_nil_r; auto. contradict n0; subst n. rewrite app_length. simpl. rewrite <- plus_n_Sm. auto. subst f2. destruct (lt_dec (length m) n). destruct (IH (length m) l0 r2). apply i; auto. apply H2. split; auto. destruct l; subst n; auto. contradict n0. simpl; rewrite app_length; auto. apply in_flat_map in H. destruct H as [[x y] [H5 H4]]. apply H3 in H5. simpl in H5. subst n. apply all_pair_spec2 in H4. simpl in H4. destruct H4 as [s [t [H6 [H7 H8]]]]. subst w. subst f1. destruct (lt_dec x (x+y)). destruct (IH x l r1). apply i in H6. destruct H6. subst x.
  subst f2. destruct (lt_dec y (length s+y)). destruct (IH y l0 r2). apply i0 in H7. destruct H7. subst y. split; auto. rewrite app_length; auto. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite <- H4. replace (length s) with 0; auto. destruct (length s); auto. contradict n. simpl. apply le_n_S. auto. assert (y=0). destruct y; auto. contradict n. rewrite <- plus_n_Sm; auto. subst y. apply H1 in H6. destruct H6. subst f2. destruct (lt_dec 0 (x+0)). destruct (IH 0 l r2). apply i in H7. destruct H7. destruct t. split; auto. rewrite app_nil_r. auto. inversion H5. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite H0. rewrite H5. replace x with 0; auto. destruct x; auto. contradict n0. simpl. apply le_n_S; auto. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. exists (l1++l2). intros; split; intros. destruct H. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H;[apply H1 in H|apply H2 in H]; destruct H; auto.
  destruct n. exists (nil::nil). intros; split; intros. destruct H. destruct w; auto. inversion H0. destruct H. subst w; auto. destruct H. destruct IHr as [l1 H1]. destruct (sum_is_n (S n)) as [sl H2]. remember (fun m=>match lt_dec m (S n) with left _ H  => match IH m H r with exist _ l _ => l end | right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m (S n) with |left _ H => match IH m H (Rstar r) with exist _ l _ => l end | right _ _ => nil end) as f2. exists (flat_map (fun p=> all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. destruct (Rstar_rev' H) as [w1 [w2 [H3 [H4 [H5 H6]]]]]; auto. destruct w. inversion H0. discriminate. subst w. apply in_flat_map. exists (length w1, length w2). split. apply H2. rewrite <- H0. rewrite app_length; auto.  simpl. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length w1) (S n)). destruct (IH (length w1) l r). apply i; auto. apply H1. split; auto. destruct w2. rewrite <- H0. rewrite app_nil_r; auto. contradict n0. rewrite <- H0. rewrite app_length. simpl. rewrite <- plus_n_Sm. apply le_n_S; apply le_plus_l; auto.
  subst f2. destruct (lt_dec (length w2) (S n)). destruct (IH (length w2) l (Rstar r)); auto. apply i; auto. contradict n0. rewrite <- H0. rewrite app_length. destruct w1. contradict H5; auto. simpl. apply le_n_S; apply le_plus_r. apply in_flat_map in H. destruct H as [[x y] [H3 H4]]. apply H2 in H3. simpl in H3. apply all_pair_spec2 in H4. destruct H4 as [w1 [w2 [H5 [H6 H7]]]]. subst w. subst f1. simpl in H5. destruct (lt_dec x (S n)). destruct (IH x l r). apply i in H5. destruct H5. subst f2. simpl in H6. destruct (lt_dec y (S n)). destruct (IH y l0 (Rstar r)). apply i0 in H6. destruct H6. split. auto. rewrite app_length. subst x y; auto. destruct H6. subst f2. simpl in H6. destruct (lt_dec y (S n)). destruct (IH y l). apply i in H6. destruct H6. apply H1 in H5. destruct H5. destruct y.  destruct w2. rewrite app_nil_r. auto. inversion H0. contradict n0. rewrite <- H3. rewrite <- plus_n_Sm. apply le_n_S; apply le_plus_l. destruct H6. Defined.
Definition Rlang_bound: forall r n, {l|forall w, Racc r w/\length w <=n <-> In w l}. intros. induction n. destruct (Rlang_length r 0) as [l H]. exists l. intros; split; intros. apply H. destruct H0. split; auto. destruct (length w); auto. inversion H1. apply H in H0. destruct H0. split; auto. rewrite <- H1; auto. destruct IHn as [l H1]. destruct (Rlang_length r (S n)) as [m H2]. exists (m++l). intros; split; intros. destruct H. apply in_or_app. inversion H0; [left|right]. apply H2; auto. apply H1; auto. apply in_app_or in H. destruct H. apply H2 in H. destruct H; split; auto. rewrite H0; auto. apply H1 in H. destruct H. split; auto. Defined.
Definition Racc_dec: forall r l, {Racc r l}+{~Racc r l}. intros r l. destruct (Rlang_length r (length l)) as [m H]. destruct (in_dec (list_eq_dec C_eq_dec) l m); [left|right]. apply H in i. destruct i; auto. contradict n. apply H; auto. Defined.

Theorem Rstar_rev: forall r w, Racc (Rstar r) w -> {w1:list C & {w2|w=w1++w2 /\ w1<>nil /\ Racc r w1 /\Racc (Rstar r) w2}}+{w=nil}. intros. destruct (list_eq_dec C_eq_dec w nil). right; auto. left. destruct (splits w) as [wl H1 _]. destruct (findP (fun p=>fst p<>nil/\Racc r (fst p)/\Racc (Rstar r) (snd p)) wl) as [[[w1 w2] H2]|H2]. intros p H0. destruct (list_eq_dec C_eq_dec (fst p) nil); [right|]. contradict e. destruct e; auto. destruct (Racc_dec r (fst p)); [|right]. destruct (Racc_dec (Rstar r) (snd p)); [left|right]; auto. contradict n1. destruct n1; destruct H3; auto. contradict n1. destruct n1; destruct H3; auto. destruct a. destruct H3. exists w1. exists w2. split; auto. apply H1 in H2. subst w; auto. exfalso. destruct (Rstar_rev' H) as [l [m [H3 [H4 [H5 H6]]]]]; auto. subst w. cut (In (l,m) wl). intros. apply H2 in H0. contradict H0. simpl; auto. apply H1. auto. Defined.
Theorem Rstar_dual: forall r, Req (Rstar r) (Rstar (Rstar r)). Proof. intros. split; intros w H. auto. revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc(Rstar(Rstar r)) w->Racc(Rstar r) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]; auto. subst w. apply Rstar_app; auto. apply IH; auto. unfold ltof. destruct w1. contradict H3; auto. rewrite app_length. apply le_n_S; apply le_plus_r. subst w; auto. Qed.
Theorem Rstar_dual2: forall r, Req (Rstar r) (Rcons (Rstar r) (Rstar r)). Proof. intros; split; intros w H. rewrite <- app_nil_r; auto. inversion H. apply Rstar_app; auto. Qed.
Theorem Rstar_or: forall r s, Req (Rstar (Ror r s)) (Rstar (Rcons (Rstar r) (Rstar s))). Proof. intros. split; intros w H; revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Ror r s)) w -> Racc (Rstar (Rcons (Rstar r) (Rstar s))) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]. subst w. apply RAstar2; auto. inversion H3. rewrite <- app_nil_r; auto. rewrite <- app_nil_l; auto. apply IH; auto. unfold ltof. rewrite app_length. destruct w1. contradict H2; auto. simpl; auto. subst w; auto.
  apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Rcons (Rstar r) (Rstar s))) w->Racc (Rstar (Ror r s)) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]; subst w; auto. inversion H3; auto. subst w1 r0 s0. apply Rstar_app. apply Rstar_app. revert H5. apply Rstar_incl. intros w Hw. auto. revert H7. apply Rstar_incl. intros w Hw. auto. apply IH; auto. unfold ltof. remember (l++m) as w1. destruct w1. contradict H2; auto. rewrite app_length. simpl. auto. Qed.

(* Deterministic Finite Automata *)
Record DFA: Set := mkDFA {
  DFAstates: list nat; DFAtrans: nat->C->nat;
  DFAinit: nat; DFAaccept: list nat;
  DFAtrans_const: forall c s, In s DFAstates -> In (DFAtrans s c) DFAstates;
  DFAinit_const: In DFAinit DFAstates;
  DFAacc_const: incl DFAaccept DFAstates}.
Definition DFAacc (d:DFA) (w:list C) : Prop := In (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d).
Definition DFAacc_dec: forall d w, {DFAacc d w}+{~DFAacc d w}. intros. destruct (in_dec nat_eq_dec (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d)); [left|right]; auto. Defined.

Inductive Head {T:Type}: T -> list T -> Prop := Head_intro: forall a l, Head a (a::l).
Inductive Tail {T:Type}: T -> list T -> Prop := Tail_nil: forall a, Tail a (a::nil) | Tail_cons: forall  a b l, Tail a l -> Tail a (b::l).
Hint Constructors Head Tail.
Definition Head_dec': forall {T:Type} (l:list T), {a| Head a l & forall b, Head b l -> b=a}+{l=nil}. intros. destruct l. right; auto. left; exists t; auto. intros. inversion H; auto. Defined.
Definition Tail_dec': forall {T:Type} (l:list T), {a| Tail a l & forall b, Tail b l -> b=a}+{l=nil}. intros. destruct l. right; auto. left. induction l. exists t; auto. intros. inversion H; auto. inversion H2. destruct IHl as [b H1 H2]. destruct l. exists a; auto. intros. inversion H. inversion H4; auto. inversion H8. exists b. inversion H1; auto. intros. apply H2. inversion H. inversion H4; auto. Defined.
Definition Tail_dec: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (a:T) l, {Tail a l}+{~Tail a l}. intros. destruct (Tail_dec' l) as [[b H1 H2]|H1]. destruct (T_eq_dec a b). subst b; left; auto. right. contradict n; auto. subst l; right. intros D; inversion D. Defined.
Definition Tail_rev: forall {T:Type} (l:list T) t, Tail t l -> {m|l=m++t::nil}. intros. induction l. exfalso. inversion H. destruct l. exists nil. inversion H; subst a; auto. inversion H2. destruct IHl as [m H1]. inversion H; auto. exists (a::m). simpl. f_equal; auto. Defined.
Definition tail: forall {T:Type} (l:list T), {a:T & {m | l=m++a::nil}}+{l=nil}. induction l. right; auto. destruct IHl. destruct s as [b [m H]]. left. exists b. exists (a::m); auto. simpl. f_equal; auto. subst l. left. exists a. exists nil; auto. Defined.
Theorem Tail_In: forall {T:Type} (l:list T) t, Tail t l -> In t l. Proof. intros. induction H; auto. Qed.
Theorem Tail_app: forall {T:Type} (t:T) l m, Tail t l -> Tail t (m++l). Proof. intros. induction m; simpl; auto. Qed.
Theorem Tail_app_rev: forall {T:Type} (t:T) l m, Tail t (l++m) -> m<>nil -> Tail t m. Proof. intros. induction l. auto. inversion H. destruct l. destruct m. contradict H0; auto. inversion H4. inversion H4. auto. Qed.

Definition ubound_sig: forall (l:list nat), {a|forall x, In x l->x<a & forall b, (forall x, In x l->x<b) -> a<=b}. induction l. exists 0; intros. destruct H. apply le_O_n. destruct IHl as [m Ha Hb]. destruct (le_lt_dec m a). exists (S a); intros. destruct H. subst x; auto. apply lt_le_trans with m; auto. apply H. left; auto. exists m; intros; auto. destruct H; auto. subst x; auto. Defined.
Definition ubound (l:list nat): nat := let (n,_,_):= ubound_sig l in n.
Definition Disjoint {T:Type} : relation (list T):= fun l m =>forall x, ~(In x l /\ In x m).
Theorem Disjoint_comm: forall {T:Type} (l m:list T), Disjoint l m -> Disjoint m l. Proof. unfold Disjoint. intros. intros D. destruct D. absurd (In x l/\In x m); auto. Qed.
Theorem Disjoint_In1: forall {T:Type} l m (x:T), Disjoint l m -> In x l -> ~In x m. Proof. intros. intros D. unfold Disjoint in H. absurd (In x l/\In x m); auto. Qed.
Theorem ubound_Disjoint: forall l m, Disjoint l (map (plus (ubound l)) m). Proof. intros. unfold ubound. destruct (ubound_sig l) as [n H _]. intros x D. destruct D. absurd (x<n); auto. apply le_not_lt. apply in_map_iff in H1. destruct H1 as [y [H2 H3]]. subst x. auto. Qed.
Hint Resolve Tail_In Tail_app Tail_app_rev Disjoint_comm Disjoint_In1 ubound_Disjoint.

Theorem remove_In2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a x, In x (remove T_eq_dec a l) <-> x<>a /\ In x l. Proof. induction l; simpl; split; intros. destruct H. destruct H; auto. destruct (T_eq_dec a0 a). subst a0. apply IHl in H. destruct H. split; auto. destruct H. subst x. split; auto. apply IHl in H. destruct H; auto. destruct H. destruct (T_eq_dec a0 a). apply IHl. destruct H0; auto. subst a0 a. contradict H; auto. destruct H0; auto. left; auto. right. apply IHl; auto. Qed.
Theorem remove_length2:forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a, In a l -> length (remove T_eq_dec a l) < length l. Proof. induction l; simpl; intros. destruct H. destruct (T_eq_dec a0 a). apply le_n_S. apply remove_length. simpl. apply le_n_S. apply IHl. destruct H; auto. contradict n; auto. Qed.
Definition removeAll {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T):= fold_right (remove T_eq_dec) m l.
Theorem removeAll_In: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, ~In x l /\ In x m <-> In x (removeAll T_eq_dec l m). Proof. induction l; intros; simpl; split; intros. destruct H; auto. split; auto. destruct H. destruct (T_eq_dec x a). subst x; contradict H; auto. apply remove_In2. split; auto. apply IHl with (m:=m) (x:=x). split; auto. apply remove_In2 in H. destruct H. apply IHl in H0. destruct H0. split; auto. contradict H0. destruct H0; auto. contradict H; auto. Qed.
Theorem removeAll_app: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l1 l2 m:list T), removeAll T_eq_dec (l1++l2) m = removeAll T_eq_dec l1 (removeAll T_eq_dec l2 m). Proof. induction l1; simpl; intros; auto. f_equal; auto. Qed.
Theorem removeAll_length: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), length (removeAll T_eq_dec l m) <= length m. Proof. induction l; simpl; intros; auto. eapply le_trans. apply remove_length. apply IHl; auto. Qed.
Theorem removeAll_length2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, In x l -> In x m -> length (removeAll T_eq_dec l m) < length m. Proof. induction l; intros. destruct H. simpl. destruct H. subst x. destruct (in_dec T_eq_dec a l). apply le_lt_trans with (length (removeAll T_eq_dec l m)); auto. apply remove_length. apply IHl with a; auto. apply lt_le_trans with (length (removeAll T_eq_dec l m)). apply remove_length2; auto. apply removeAll_In; auto. apply removeAll_length. eapply le_lt_trans. eapply remove_length. eapply IHl; eauto. Qed.
Definition incl_dec: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), {x|In x l & ~In x m}+{incl l m}. induction l; intros. right. intros x H; inversion H. destruct (in_dec T_eq_dec a m). destruct (IHl m); [left|right]. destruct s. exists x; auto. intros x H. destruct H; auto. subst x; auto. left; exists a; auto. Defined.
Definition commonList: forall {T:Type} (T_eq_dec:forall x y:T,{x=y}+{x<>y}) (l m:list T), {c|forall x, In x c<->In x l /\ In x m}. intros. exists (filter (dec2b (fun x=>in_dec T_eq_dec x m)) l). intros; split; intros. induction l. inversion H. simpl in H. remember (dec2b (fun x=>in_dec T_eq_dec x m) a) as b. destruct b. destruct H. subst a. symmetry in Heqb. apply dec2b_true in Heqb. auto. destruct IHl; auto. destruct IHl; auto. destruct H. induction l. destruct H. simpl. destruct H. subst a. remember (dec2b (fun y=>in_dec T_eq_dec y m) x) as b. symmetry in Heqb. destruct b; auto. apply dec2b_false in Heqb. contradiction. destruct (dec2b (fun y=>in_dec T_eq_dec y m) a); auto. Defined.
Definition inv_func: forall {T U:Type} (U_eq_dec:forall x y:U, {x=y}+{x<>y}) (f:T->U) l (d:T), (forall x y, In x l->In y l->f x=f y->x=y) -> {g:U->T|forall x, In x l->g (f x)=x & forall y, ~In y (map f l)->g y=d}. intros. exists (fun y=>match findP (fun x=>f x=y) l (fun x _=>U_eq_dec (f x) y) with inleft _ (exist2 _ _ f _ _) => f  | inright _ _ => d end). intros. destruct (findP (fun y=>f y=f x) l (fun y _=>U_eq_dec (f y) (f x))) as [[a H1 H2]|H1]; auto. absurd (f x=f x); auto. intros. destruct (findP (fun x=>f x=y) l (fun x _=>U_eq_dec (f x) y)) as [[a H1 H2]|H1]; auto.  contradict H0. subst y. apply in_map_iff. exists a; auto. Defined.
Definition split_until: forall {T:Type} (P:T->Prop) (l:list T) (P_dec:forall x, In x l->{P x}+{~P x}), {m1:list T & {x:T &{m2|P x /\ l=m1++x::m2 & Forall (fun x=>~P x) m1}}}+{Forall (fun x=>~P x) l}. induction l; intros. right; auto. destruct IHl as [[m1 [x [m2 [H1 H2] H3]]]|H1]. intros. apply P_dec; auto. subst l. destruct (P_dec a). left; auto. left. exists nil. exists a. exists (m1++x::m2); auto. left. exists (a::m1). exists x. exists m2; auto. destruct (P_dec a). auto. left. exists nil. exists a. exists l; auto. right. auto. Defined.

(* Non-deterministic Finite Automata *)
Record NFA: Type := mkNFA {
  NFAstates: list nat;
  NFAtrans: nat -> C -> list nat;
  NFAinit: list nat; (* take a list for future extension *)
  NFAaccept: list nat;
  NFAtrans_const: forall c s, In s NFAstates -> incl (NFAtrans s c) NFAstates;
  NFAinit_const: incl NFAinit NFAstates;
  NFAacc_const: incl NFAaccept NFAstates;
}.
Inductive NFAsteps (n:NFA) : list C -> list nat -> Prop:=
| NFAsteps_nil: forall s, NFAsteps n nil (s::nil)
| NFAsteps_cons: forall s t l w c, NFAsteps n w (t::l) -> In t (NFAtrans n s c) -> NFAsteps n (c::w) (s::t::l)
.
Inductive NFAacc (n:NFA) (w:list C) : Prop := NFAacc_intro: forall is es l, In es (NFAaccept n) ->In is (NFAinit n) -> NFAsteps n w l -> Head is l -> Tail es l -> NFAacc n w.
Hint Constructors NFAsteps NFAacc.

Theorem NFAsteps_const: forall n w s l, NFAsteps n w (s::l) -> In s (NFAstates n) -> incl l (NFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. intros x Hx. destruct Hx. inversion H. subst w s0 a l0. intros x Hx. destruct Hx. subst x. apply NFAtrans_const in H6; auto. apply IHl with w0 t in H1; auto. apply NFAtrans_const in H6; auto. Qed.
Definition NFAsteps_states': forall n w s, {sl| forall l, In l sl <-> Head s l /\ NFAsteps n w l}. induction w; intros. exists ((s::nil)::nil); intros; split; intros. destruct H. subst l; auto. destruct H. destruct H. inversion H0. subst l. inversion H. subst a s0 l. left; auto.
  exists (flat_map (fun t=>let (sl,_):= IHw t in map (cons s) sl) (NFAtrans n s a)). intros; split; intros. apply in_flat_map in H. destruct H as [t [H1 H2]]. destruct (IHw t) as [sl H3]. apply in_map_iff in H2. destruct H2 as [m [H4 H5]]. subst l. split; auto. apply H3 in H5. destruct H5. inversion H. subst a0 m. auto. destruct H. apply in_flat_map. inversion H0. subst a w0 l. inversion H. subst a s0 l. exists t. split; auto. destruct (IHw t) as [sl H6]. apply in_map_iff. exists (t::l0); auto. split; auto. apply H6. auto. Defined.
Definition NFAsteps_states: forall n w sl, {tl| forall t, In t tl <-> exists s, In s sl /\ exists l, NFAsteps n w l /\ Head s l /\ Tail t l & incl sl (NFAstates n) -> incl tl (NFAstates n)}. intros. exists (map (fun l=>match tail l with inleft (existT _  a _) => a |inright _ => 0 end) (flat_map (fun s=>let (l,_):=NFAsteps_states' n w s in l) sl)). intros; split; intros. apply in_map_iff in H. destruct H as [x [H H0]]. apply in_flat_map in H0. destruct H0 as [y [H0 H1]]. destruct (NFAsteps_states' n w y) as [l H2]. apply H2 in H1. destruct H1. destruct (tail x) as [[a [m H4]]|H4]. subst x a. exists y. split; auto. exists (m++t::nil); auto. subst x t. inversion H1.
  destruct H as [s [H1 [l [H2 [H3 H4]]]]]. apply in_map_iff. exists l. split. destruct (tail l) as [[a [m H5]]|H5]. subst l. apply Tail_app_rev in H4. inversion H4; auto. inversion H5. discriminate. subst l. inversion H3. apply in_flat_map. exists s. split; auto. destruct (NFAsteps_states' n w s). apply i. auto. intros. intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. destruct (NFAsteps_states' n w z) as [tl H5]. apply H5 in H4. destruct H4. destruct (tail y) as [[a [m H4]]|H4]. subst a y. inversion H0. subst a. destruct m. inversion H6. subst x l. apply H; auto. inversion H6. subst n0 l. simpl in H2. apply NFAsteps_const in H2. apply H2. apply in_or_app. right; auto. apply H; auto. subst y. inversion H0.  Defined.

Definition NFAacc_dec: forall n w, {NFAacc n w}+{~NFAacc n w}. intros. destruct (NFAsteps_states n w (NFAinit n)) as [tl H _]. destruct findP with (l:=tl) (P:=fun s=>In s (NFAaccept n)) as [[s H0]|H0]. intros. apply in_dec. apply nat_eq_dec. left. apply H in H0.  destruct H0 as [is [H1 [l [H2 [H3 H4]]]]]. apply NFAacc_intro with is s l; auto. right. intros D. inversion D. contradict H1. apply H0. apply H. exists is. split; auto. exists l; auto. Defined.

Theorem NFAsteps_app: forall n w1 l1, NFAsteps n w1 l1 -> forall w2 l2 s, NFAsteps n w2 (s::l2) -> Tail s l1 -> NFAsteps n (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply NFAsteps_cons; auto. apply IHNFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem NFAsteps_app_s_rev: forall n l1 l2 w s, NFAsteps n w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists (c::w0); auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n0 l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists (c::w1). exists w2. split; simpl; f_equal; auto. Qed.
Theorem NFAsteps_app_w_rev: forall n w1 w2 l, NFAsteps n (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2) /\ Tail s l1. Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|t l]. inversion H. exists t. exists (t::nil). exists l; auto. inversion H. subst c0 w l. apply IHw1 in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. exists u. destruct l1. inversion Hb. inversion Ha. subst n0 l0. exists (s::t::l1). exists l2. split; auto. Qed.
Theorem NFAsteps_parteq: forall n1 n2 w l st, incl l st -> (forall s c, In s st -> NFAtrans n1 s c = NFAtrans n2 s c) -> NFAsteps n1 w l -> NFAsteps n2 w l. Proof. intros. induction H1; auto. apply NFAsteps_cons; auto. apply IHNFAsteps. intros x Hx; auto. rewrite <- H0; auto. Qed.
Theorem NFAsteps_length: forall n w l, NFAsteps n w l -> length l = S(length w). Proof. intros. induction H; simpl; auto. Qed.

(* Non-deterministic Finite Automata with Empty *)
Record EFA: Set := mkEFA {
  EFAstates: list nat; EFAtrans: nat->C->list nat; EFAempty: nat->list nat;
  EFAinit: list nat; (* take a list for future extension *)
  EFAaccept: list nat;
  EFAtrans_const: forall c s, In s EFAstates -> incl (EFAtrans s c) EFAstates;
  EFAempty_const: forall s, In s EFAstates -> incl (EFAempty s) EFAstates;
  EFAinit_const: incl EFAinit EFAstates;
  EFAacc_const: incl EFAaccept EFAstates;
}.
Inductive EFAsteps (n:EFA) : list C -> list nat -> Prop:=
| EFAsteps_nil: forall s, EFAsteps n nil (s::nil)
| EFAsteps_empty: forall s t l w, EFAsteps n w (t::l) -> In t (EFAempty n s) -> EFAsteps n w (s::t::l)
| EFAsteps_cons: forall s t l w c, EFAsteps n w (t::l) -> In t (EFAtrans n s c) -> EFAsteps n (c::w) (s::t::l)
.
Inductive EFAacc (n:EFA) (w:list C) : Prop := EFAacc_intro: forall is es l, In es (EFAaccept n) -> In is (EFAinit n) -> EFAsteps n w l -> Head is l -> Tail es l -> EFAacc n w.
Hint Constructors EFAsteps EFAacc clos_refl_trans.

Theorem EFAsteps_const: forall n w s l, In s (EFAstates n) -> EFAsteps n w l -> Head s l -> incl l (EFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. inversion H1. intros x Hx. destruct Hx. subst x. inversion H1. subst a a0 l0. auto. inversion H1. subst a0 a l0. clear H1. inversion H0. subst l. destruct H2. subst w0 s0 l. apply IHl with w t in H2; auto. apply EFAempty_const in H6; auto. subst w s0 l. apply IHl with w0 t in H2; auto. apply EFAtrans_const in H6; auto. Qed.
Theorem EFAsteps_app: forall e w1 l1, EFAsteps e w1 l1 -> forall w2 l2 s, EFAsteps e w2 (s::l2) -> Tail s l1 -> EFAsteps e (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply EFAsteps_empty; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2. inversion H5; auto. apply EFAsteps_cons; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem EFAsteps_app_s_rev: forall e l1 l2 w s, EFAsteps e w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w0 s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists w; auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists w1. exists w2. split; auto.
  subst s0. inversion H0. subst a t l1. exists nil. exists (c::w0). simpl in H2. subst l2. auto. subst a b l0. destruct l1. inversion H7. inversion H2. subst n l. replace (t0::l1++l2) with ((t0::l1)++l2) in H4; auto. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H6 [H8 H9]]]]. exists (c::w1). exists w2. split; auto. subst w0. auto. Qed.
Theorem EFAsteps_cons_rev: forall n w c l, EFAsteps n (c::w) l -> exists s t l1 l2, l=l1++t::l2 /\ Tail s l1 /\ EFAsteps n nil l1 /\ EFAsteps n w (t::l2) /\ In t (EFAtrans n s c). Proof. intros n w c l H. remember (c::w) as w' in H. revert Heqw'. revert c w. induction H; intros. inversion Heqw'. apply IHEFAsteps in Heqw'. destruct Heqw' as [s' [t' [l1' [l2' [H1 [H2 [H3 [H4 H5]]]]]]]].  exists s'. exists t'. exists (s::l1'). exists l2'. split. simpl; f_equal; auto. split ; auto. split; auto. destruct l1'. inversion H3. inversion H1. subst n0 l. apply EFAsteps_empty; auto.
  inversion Heqw'. subst c0 w0. exists s. exists t. exists (s::nil). exists l; auto. Qed.
Theorem EFAsteps_app_w_rev: forall e w1 w2 l, EFAsteps e (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ Tail s l1 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|s l]. inversion H. exists s. exists (s::nil). exists l; auto. destruct (EFAsteps_cons_rev H) as [s [t [l1 [l2 [H1 [H2 [H3 [H4 H5]]]]]]]]. subst l. destruct (IHw1 w2 (t::l2) H4) as [u [m1 [m2 [H6 [H7 [H8 H9]]]]]]. destruct m1. inversion H8. inversion H6. subst n l2. exists u. exists (l1++t::m1). exists m2. split; auto. rewrite <- app_assoc; auto. split. clear -H7. induction l1; simpl; auto. split; auto. replace (c::w1) with (nil++c::w1); auto. apply EFAsteps_app with s; auto. Qed.
Definition EFA_empty_states': forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}. intros n sl. apply (Fix (well_founded_ltof (list nat) (fun l=>length (removeAll nat_eq_dec l (EFAstates n))))) with (P:=fun sl=>incl sl (EFAstates n)->{tl|forall t,In t tl<->exists s,In s sl/\clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}). clear sl. intros sl IH H.
  destruct (incl_dec nat_eq_dec (flat_map (EFAempty n) sl) sl) as [[x H0 H1]|H0]. destruct (IH (flat_map (EFAempty n) sl++sl)) as [tl H2]. unfold ltof. rewrite removeAll_app. apply removeAll_length2 with x; auto. apply removeAll_In. split; auto. apply in_flat_map in H0. destruct H0 as [y [H2 H3]]. apply (EFAempty_const n) in H3; auto.
  intros y Hy. apply in_app_or in Hy. destruct Hy; auto. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. apply (EFAempty_const n) in H4; auto. exists tl. intros t; split; intros. apply H2 in H3. destruct H3 as [s [H4 H5]]. apply in_app_or in H4. destruct H4. apply in_flat_map in H3. destruct H3 as [u [H6 H7]]. exists u. split; auto. apply rt_trans with s; auto. exists s; auto. apply H2. destruct H3 as [s [H4 H5]]. exists s. split; auto. apply in_or_app; auto.
  exists sl. intros; split; intros. exists t; auto. destruct H1 as [s [H2 H3]]. clear -H0 H2 H3. induction H3; auto. apply H0. apply in_flat_map. exists x; auto. Defined.
Theorem EFAsteps_incl: forall e1 e2 w l st, incl l st -> (forall s t, In s st-> In t (EFAempty e1 s) -> In t st -> In t (EFAempty e2 s)) -> (forall s c t, In s st -> In t (EFAtrans e1 s c) -> In t st -> In t (EFAtrans e2 s c)) -> EFAsteps e1 w l -> EFAsteps e2 w l. Proof. intros. induction H2; auto. apply EFAsteps_empty; auto. apply IHEFAsteps. intros x Hx; auto. apply EFAsteps_cons; auto. apply IHEFAsteps. intros x Hx; auto. Qed.

Definition EFA_empty_states: forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ exists l, EFAsteps n nil l /\ Head s l /\ Tail t l}. intros. destruct (EFA_empty_states' n H) as [tl H0]. exists tl. intros; split; intros. apply H0 in H1. destruct H1 as [s [H2 H3]]. exists s. split; auto. clear -H3. induction H3. exists (x::y::nil); auto. exists (x::nil); auto. destruct IHclos_refl_trans1 as [l [H1 [H2 H3]]]. destruct IHclos_refl_trans2 as [m [H4 [H5 H6]]]. inversion H5. subst a m. exists (l++l0). split. assert (EFAsteps n (nil++nil) (l++l0)). apply EFAsteps_app with y; auto. simpl in H; auto. split. inversion H2; simpl; auto. inversion H6. rewrite app_nil_r; auto. clear -H7. induction l; simpl; auto.
  apply H0. destruct H1 as [s [H2 [l [H3 [H4 H5]]]]]. exists s. split; auto. clear H2. revert dependent s. revert dependent t. clear -H3. induction l; intros. inversion H3. inversion H4. subst a0 a l0. inversion H3. subst s0 l. inversion H5. apply rt_refl. inversion H1. subst w s0 l. inversion H5. subst a b l. apply rt_trans with t0. apply rt_step; auto. apply IHl; auto. Defined.

Definition EFAsteps_states: forall n w sl, incl sl (EFAstates n) -> {tl|forall t, In t tl <-> exists s, In s sl /\ exists l, EFAsteps n w l /\ Head s l /\ Tail t l}. induction w as [|c w]; intros. destruct (EFA_empty_states n H) as [tl H0]. exists tl. auto.
  destruct (EFA_empty_states n H) as [tl H0]. assert (H1: incl (flat_map (fun s=>EFAtrans n s c) tl) (EFAstates n)). intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H1 H2]]. apply EFAtrans_const in H2; auto. destruct (H0 y). destruct (H3 H1) as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hc. subst a l. apply EFAsteps_const with (s:=s) in Hb; auto. destruct (IHw (flat_map (fun s=>EFAtrans n s c) tl) H1) as [ul H2]. clear IHw. exists ul. intros; split; intros. apply H2 in H3. destruct H3 as [s [Ha [l [Hb [Hc Hd]]]]]. clear H2. apply in_flat_map in Ha. destruct Ha as [x [H3 H2]]. apply H0 in H3. destruct H3 as [y [H4 [m [H5 [H6 H7]]]]]. exists y. split; auto. exists (m++l). split. replace (c::w) with (nil++c::w); auto. apply EFAsteps_app with x; auto. inversion Hc. subst a l. apply EFAsteps_cons; auto. split. inversion H6; simpl; auto. clear -Hd. induction m; simpl; auto.
  apply H2. clear H2. destruct H3 as [s [H4 [l [H5 [H6 H7]]]]]. destruct (EFAsteps_cons_rev H5) as [u [v [l1 [l2 [Ha [Hb [Hc [Hd He]]]]]]]]. subst l. exists v. split. apply in_flat_map. exists u. split; auto. apply H0. exists s. split; auto. exists l1; auto. split; auto. split; auto. destruct l1. inversion Hc. inversion H6; auto. exists (v::l2). split; auto. split; auto. clear -H7. induction l1; simpl; auto. inversion H7; auto. destruct l1; inversion H2. Defined. 
Definition EFAacc_dec: forall n w, {EFAacc n w}+{~EFAacc n w}. intros. destruct (EFAsteps_states n w) with  (sl:=EFAinit n) as [tl H]. intros x H. apply (EFAinit_const n) in H; auto. destruct findP with (P:=fun s=>In s tl) (l:=EFAaccept n). intros. apply in_dec. apply nat_eq_dec. destruct s as [s H1 H2]. left. apply H in H2. destruct H2 as [is [H4 [l [H5 [H6 H7]]]]]. apply EFAacc_intro with is s l; auto. right. intros D. inversion D. apply n0 in H0. contradict H0. apply H. exists is. split; auto. exists l; auto. Defined.

Definition EFA2NFA: forall e, {n| forall w, EFAacc e w <-> NFAacc n w}. intros. destruct (EFA_empty_states e (EFAinit_const e)) as [is H]. assert (Hi: incl is (EFAstates e)). intros x Hx. apply H in Hx. destruct Hx as [s [H1 [l [H2 [H3 H4]]]]]. apply (EFAinit_const e) in H1. inversion H3. subst a l. apply EFAsteps_const with (s:=s) in H2; auto. remember (fun s c=>match in_dec nat_eq_dec s (EFAstates e) with |left H => match EFA_empty_states e (EFAtrans_const e c s H) with exist _ sl _ => sl end |right _ => nil end) as tr. assert (Ht: forall c s, In s (EFAstates e) -> incl (tr s c) (EFAstates e)). intros. subst tr. destruct (in_dec nat_eq_dec s (EFAstates e)); [|contradiction]. destruct (EFA_empty_states e (EFAtrans_const e c s i)) as [tl H1]. intros x Hx. apply H1 in Hx.  destruct Hx as [t [H2 [l [H3 [H4 H5]]]]]. inversion H4. subst a l. assert (In t (EFAstates e)). apply (EFAtrans_const e c s); auto. apply EFAsteps_const with (s:=t) in H3; auto.
  exists (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)). cut (forall w t, (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail t l) <-> exists s, In s is /\ exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\ Tail t l). intros; split; intros. inversion H1. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail es l). exists is0. split; auto. exists l; auto. apply (H0 w es) in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply NFAacc_intro with s es m; auto. inversion H1. assert (exists s, In s is/\ exists l, NFAsteps (mkNFA tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\Tail es l). exists is0; split; auto. exists l; auto. apply H0 in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply EFAacc_intro with s es m; auto.
  intros w. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>forall t, (exists s, In s (EFAinit e)/\(exists l, EFAsteps e w l/\Head s l/\Tail t l))<->(exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l/\Head s l/\Tail t l)). clear w. intros w IH t. destruct (tail w) as [[c [w' H1]]|H1]. subst w. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. apply EFAsteps_app_w_rev in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. subst l. apply EFAsteps_cons_rev in Hd. destruct Hd as [v [w [m1 [m2 [H5 [H6 [H7 [H8 H9]]]]]]]]. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w' l/\Head s l/\Tail v l). exists s. split; auto. destruct m1. inversion H7. inversion H5. subst n l2. exists (l1++m1); auto. split; auto. replace w' with (w'++nil). apply EFAsteps_app with u; auto. rewrite app_nil_r; auto. split. destruct l1. inversion Hc. inversion H3; simpl; auto. inversion H6. subst v m1 a. rewrite app_nil_r; auto. clear -H10. induction l1; simpl; auto. apply IH in H0. clear IH. destruct H0 as [x [Hd [l [He [Hf Hg]]]]]. exists x. split; auto. exists (l++t::nil). split. apply NFAsteps_app with v; auto. apply NFAsteps_cons; auto.
  simpl. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0. exists w. split; auto. exists (w::m2). split; auto. split; auto. destruct l2. destruct m1. inversion H7. inversion H5. destruct m1; inversion H10. clear -H5 H4. assert (Tail t (n::l2)). induction l1; auto. apply IHl1. inversion H4; auto. destruct l1; inversion H2. destruct m1. inversion H5. subst u m2. auto. inversion H5. rewrite H2 in H. clear -H. induction m1; auto. apply IHm1. inversion H; auto. destruct m1; inversion H3. contradict n. apply Hi in Hd. inversion Hf. subst a l. apply NFAsteps_const in He. simpl in He. inversion Hg; auto.  simpl; auto. split. inversion Hf; simpl; auto. clear -l. induction l; simpl; auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  destruct H0 as [u [H1 [l [H2 [H3 H4]]]]]. apply NFAsteps_app_w_rev in H2. destruct H2 as [v [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. assert (exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w' l/\Head s l/\Tail v l). exists u. split; auto. exists m1; split; auto. split; auto. destruct m1. inversion Hb. inversion H3; auto. apply IH in H0. clear IH. destruct H0 as [x [H5 [l [H6 [H7 H8]]]]]. exists x; split; auto. inversion Hc. subst c0 w s m2. clear Hc. simpl in H12. inversion H10. subst t0 l0. clear H10.  assert (s=t). clear -H4. induction m1; simpl; auto. inversion H4; auto. inversion H1. apply IHm1. inversion H4; auto. destruct m1; inversion H2. subst s. clear H4. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0 in H12. destruct H12 as [s [H13 [m [H14 [H15 H16]]]]]. exists (l++m). split. apply EFAsteps_app with v; auto. inversion H15. subst a m. apply EFAsteps_cons; auto. split. inversion H7; simpl; auto. clear -H16. induction l; simpl; auto. contradict n. inversion H7. subst a l.  clear -H8 H5 H6. apply EFAinit_const in H5. inversion H8. auto. subst a b l0. apply EFAsteps_const with (s:=x) in H6; auto. clear -c. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. exists t. split. apply H. exists s. split; auto. exists l; auto. exists (t::nil); auto. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. inversion H2. subst l. inversion H3. subst a s0 l. inversion H4. subst a t. apply H in H1. destruct H1 as [t [Ha [l [Hb [Hc Hd]]]]]. exists t. split; auto. exists l; auto. inversion H6. Qed.
 
Definition NFA2EFA: forall n, {e|forall w, EFAacc e w <-> NFAacc n w}. intros. assert (H: forall s, In s (NFAstates n) -> incl ((fun _=>nil) s) (NFAstates n)). intros. intros x Hx; inversion Hx. exists (mkEFA (NFAtrans n) (fun _ => nil) (NFAtrans_const n) H (NFAinit_const n) (NFAacc_const n)). intros; split; intros. inversion H0. clear H0. simpl in H1. simpl in H2. apply NFAacc_intro with is es l; auto. clear -H3. induction H3; auto. simpl in H0. inversion H0. inversion H0. apply EFAacc_intro with is es l; auto. clear -H3. induction H3; auto. Defined.

Definition DFA2NFA: forall d, {n|forall w, DFAacc d w <-> NFAacc n w}. intros. assert (Ht: forall c s, In s (DFAstates d)->incl (DFAtrans d s c::nil) (DFAstates d)). intros. intros x Hx. destruct Hx. subst x. apply DFAtrans_const; auto. destruct H0. assert (Hi: incl (DFAinit d::nil) (DFAstates d)). intros x Hx. destruct Hx. subst x. apply DFAinit_const; auto. destruct H. exists (mkNFA (fun s c=>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)). unfold DFAacc. cut (forall w s t, t=fold_left (DFAtrans d) w s <-> exists l, NFAsteps (mkNFA (fun s c =>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)) w l /\ Head s l /\Tail t l). intros. split; intros. destruct (H w (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d))). destruct H1 as [l [H3 [H4 H5]]]; auto. apply NFAacc_intro with (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d)) l; auto. simpl. auto. inversion H0. clear H0. simpl in H1. simpl in H2. destruct H2; [|destruct H0]. subst is. assert (es=fold_left (DFAtrans d) w (DFAinit d)). apply H. exists l; auto. rewrite <- H0; auto.
  induction w; intros; split; intros. simpl in H. subst t. exists (s::nil); auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. subst l. inversion H2. subst a s0 l. inversion H3. subst t; auto. inversion H4. simpl in H. subst t. destruct (IHw (DFAtrans d s a) (fold_left (DFAtrans d) w (DFAtrans d s a))). clear IHw H0. destruct H as [l [H1 [H2 H3]]]; auto. exists (s::l). split; auto. inversion H2. subst a0 l. apply NFAsteps_cons; auto. simpl. auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. clear H1. simpl in H6. destruct H6; [|destruct H1]. subst a w0 l t0. simpl. apply IHw. clear IHw. inversion H2. subst s0 a l. exists (DFAtrans d s c::l0); auto. split; auto. split; auto. inversion H3; auto. Defined.
Definition DFA2EFA: forall d, {e|forall w, DFAacc d w <-> EFAacc e w}. intros. destruct (DFA2NFA d) as [n H]. destruct (NFA2EFA n) as [e H0]. exists e. intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition NFA2DFA: forall n, {d|forall w, NFAacc n w <-> DFAacc d w}. intros. remember (fun s c=>ps2i nat_eq_dec (NFAstates n) (flat_map (fun s=>NFAtrans n s c) (i2ps nat_eq_dec (NFAstates n) s))) as t. assert (Hu: forall c s, In s (seq 0 (psSize nat_eq_dec (NFAstates n))) -> In (t s c) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros. subst t. apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H4 H5]]. apply NFAtrans_const in H5; auto. apply i2ps_spec1 in H4; auto. apply in_seq in H. destruct H; auto. assert (Hj: In (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) (seq 0 (psSize nat_eq_dec (NFAstates n)))). apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply NFAinit_const; auto. destruct (contain_powerSet nat_eq_dec (NFAstates n) (NFAaccept n)) as [al H4]. assert (Hac: incl (map (ps2i nat_eq_dec (NFAstates n)) al) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros x Hx. apply in_seq. split. apply le_O_n. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply ps2i_spec1; auto. assert (Exists (equiv y) al). apply Exists_exists. exists y; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. exists (mkDFA t (ps2i nat_eq_dec (NFAstates n)  (NFAinit n)) Hu Hj Hac).
  assert (H5: forall w, fold_left t w (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) = let (tl,_,_) := NFAsteps_states n w (NFAinit n) in ps2i nat_eq_dec (NFAstates n) tl). apply (Fix (well_founded_ltof (list C) (length (A:=C)))). intros w IH. destruct (tail w) as [[c [w' H1]]|H1]. subst w. destruct (NFAsteps_states n (w'++c::nil) (NFAinit n)) as [tl H1 Ht]. rewrite fold_left_app. rewrite IH. clear IH. destruct (NFAsteps_states n w' (NFAinit n)) as [ul H0 Hv]. simpl. subst t. apply ps2i_spec3. intros x; split; intros. apply in_flat_map in H. destruct H as [y [H5 H6]]. apply i2ps_spec3 in H5. apply H1. apply H0 in H5. destruct H5 as [s [Ha [l [Hb [Hc Hd]]]]]. exists s. split; auto. exists (l++x::nil); split. apply NFAsteps_app with y; auto. split. inversion Hc; simpl; auto. clear -l. induction l; simpl; auto. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H1 in H. destruct H as [s [H5 [l [H6 [H7 H8]]]]]. apply in_flat_map. apply NFAsteps_app_w_rev in H6. destruct H6 as [t [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. inversion Hc. subst c0 w s0 m2. inversion H6. subst t0 l. clear Hc H6. assert (x=s0). clear -H8. induction m1. inversion H8; auto. inversion H1. apply IHm1. inversion H8; auto. destruct m1; inversion H2. subst s0. exists t. split; auto. apply i2ps_spec3. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H0. destruct m1. inversion Hb. inversion H7. subst n0 a l. exists s. split; auto. exists (s::m1); auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. destruct (NFAsteps_states n nil (NFAinit n)) as [ul H0 Hv]. simpl. apply ps2i_spec3. intros x; split; intros. apply H0. exists x; split; auto. exists (x::nil); auto. apply H0 in H. destruct H as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hb. subst l. inversion Hc. subst a s0 l. inversion Hd. subst a x. auto. inversion H2.
  intros; split; intros. inversion H. unfold DFAacc; simpl. rewrite H5. destruct (NFAsteps_states n w (NFAinit n)) as[tl H7 H8]. apply in_map_iff. assert (Exists (equiv tl) al). apply H4. split. apply H8. intros x Hx. apply NFAinit_const; auto. exists es; split; auto. apply H7. exists is; split; auto. exists l; auto. apply Exists_exists in H9. destruct H9 as [x [Ha Hb]]. exists x; split; auto. apply ps2i_spec3. apply equiv_sym; auto. unfold DFAacc in H. simpl in H. apply in_map_iff in H. destruct H as [x [H1 H2]]. rewrite H5 in H1. destruct (NFAsteps_states n w (NFAinit n)) as [ul H6 H7]. apply ps2i_spec2 in H1. assert (Exists (equiv ul) al). apply Exists_exists. exists x. split; auto. apply equiv_sym; auto. apply H4 in H. destruct H. destruct H0 as [y [H8 H9]]. apply H6 in H8. destruct H8 as [s [Ha [l [Hb [Hc Hd]]]]]. apply NFAacc_intro with s y l; auto. assert (Exists (equiv x) al). apply Exists_exists. exists x; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. apply H7. intros y Hy. apply NFAinit_const; auto. Defined.

Definition EFA2DFA: forall e, {d|forall w, EFAacc e w <-> DFAacc d w}. intros. destruct (EFA2NFA e) as [n H]. destruct (NFA2DFA n) as [d H0]. exists d; intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition EFA_map: forall e (f:nat->nat), (forall x y, In x (EFAstates e) -> In y (EFAstates e) -> f x=f y -> x=y) -> {e'|EFAstates e'=map f (EFAstates e) & forall w, EFAacc e w <-> EFAacc e' w}. intros e. destruct e as [st tr emp ini acc Htr Hemp Hini Hacc]. simpl. intros. destruct (inv_func nat_eq_dec f st 0 H) as [g Hg1 _]. remember (fun s c=>map f (tr (g s) c)) as tr'. assert (Htr': forall c s, In s (map f st) -> incl (tr' s c) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst tr'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Htr in H4; auto. remember (fun s=>map f (emp (g s))) as emp'. assert (Hemp': forall s, In s (map f st)->incl (emp' s) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst emp'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Hemp in H4; auto. assert (Hini': forall s, In s (map f ini)->In s (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. apply in_map_iff. exists x; split; auto. assert (Hacc': incl (map f acc) (map f st)). intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply in_map_iff. exists y; split; auto.
  exists (mkEFA tr' emp' Htr' Hemp' Hini' Hacc'); auto. intros; split; intros; inversion H0. simpl in H1. simpl in H2. clear H0. apply EFAacc_intro with (f is) (f es) (map f l); simpl; auto. apply in_map_iff. exists es; split; auto. apply in_map_iff. exists is; auto. assert (H6:incl l st). apply EFAsteps_const with (s:=is) in H3; auto. subst emp' tr'. clear -H3 H6 Hg1. revert H3. revert H6. revert w. induction l; intros. inversion H3. inversion H3; simpl; auto. subst a w0 l. apply EFAsteps_empty; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. simpl in H4. apply in_map_iff. exists t. split; auto. rewrite Hg1; auto. subst a w l. apply EFAsteps_cons; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. rewrite Hg1; auto. apply in_map_iff. exists t; split; auto. inversion H4; simpl; auto. clear -H5. induction H5; simpl; auto.
  simpl in H1. simpl in H2. clear H0. apply in_map_iff in H1. destruct H1 as [es' [H6 H1]]. subst es. apply in_map_iff in H2. destruct H2 as [is' [H6 H2]]. subst is. apply EFAacc_intro with is' es' (map g l); simpl; auto. assert (H6:incl l (map f st)). apply EFAsteps_const with (s:=f is') in H3; auto. simpl. apply in_map_iff. exists is'; split; auto.  revert H3. revert H6. revert w. subst emp' tr'. clear -Hg1. induction l; intros. inversion H3. inversion H3; simpl; auto. apply EFAsteps_empty; auto. subst w0 a l. apply IHl; auto. intros x Hx; auto. simpl. simpl in H4. subst a w0 l. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Hemp in H5; auto. cut (In s (map f st)); intros. apply in_map_iff in H. destruct H as [x [H7 H8]]. subst s. rewrite Hg1; auto. apply H6; auto. apply EFAsteps_cons; auto. subst w a l. apply IHl; auto. intros x Hx; auto. simpl. subst w a l. simpl in H4. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Htr in H5; auto. cut (In s (map f st)); intros; auto. apply in_map_iff in H. destruct H as [x [H8 H7]]. subst s. rewrite Hg1; auto. inversion H4; simpl. rewrite Hg1; auto. apply Hacc in H1. clear -H1 H5 Hg1. induction l. inversion H5. simpl. inversion H5; auto. simpl. rewrite Hg1; auto. Defined.

Definition Rnil_DFA: {d|forall w, Racc Rnil w <-> DFAacc d w}. assert (Ha:forall (c:C) s, In s (0::nil) -> In 0 (0::nil)). intros. left; auto. assert (Hb:In 0 (0::nil)). left; auto. assert (Hc: incl nil (0::nil)). intros x Hx; inversion Hx. exists (mkDFA (fun _ _=>0) 0 Ha Hb Hc). intros; split; intros. inversion H. inversion H. Defined.
Definition Rchar_DFA: forall c, {d|forall w, Racc (Rchar c) w <-> DFAacc d w}. intros. remember (fun s c'=>if C_eq_dec c' c then if nat_eq_dec s 0 then 1 else 2 else 2) as tr. assert (Ha:forall c s, In s (0::1::2::nil) -> In (tr s c) (0::1::2::nil)). intros c' s H. subst tr. destruct (C_eq_dec c' c). destruct (nat_eq_dec s 0); auto. auto. assert (Hb:In 0 (0::1::2::nil)); auto. assert (Hc:incl (1::nil) (0::1::2::nil)). intros x Hx. destruct Hx. subst x; auto. destruct H. exists (mkDFA tr 0 Ha Hb Hc). intros; split; intros. inversion H. subst c0 w. unfold DFAacc. simpl. left. subst tr. destruct (C_eq_dec c c). destruct (nat_eq_dec 0 0); auto. contradict n; auto. contradict n; auto. unfold DFAacc in H. simpl in H. destruct H; [|destruct H]. destruct w as [|c' w]; simpl in H. inversion H. subst tr. destruct (C_eq_dec c' c). subst c'. destruct (nat_eq_dec 0 0). destruct w; auto. simpl in H. absurd (1=2); auto. rewrite H at 1. clear -w. destruct (C_eq_dec c0 c). induction w; simpl; auto. destruct (C_eq_dec a c); auto. induction w; simpl; auto. destruct (C_eq_dec a c); auto. contradict n; auto. absurd (1=2); auto. rewrite H at 1. clear -n. induction w; simpl; auto. destruct (C_eq_dec a c); auto. Defined.
Definition EFA_or: forall e1 e2, {eo|forall w, EFAacc eo w <-> EFAacc e1 w \/ EFAacc e2 w}. intros. destruct e1 as [st1 tr1 emp1 ini1 acc1 Htr1 Hemp1 Hini1 Hacc1]. destruct (EFA_map e2 (plus (ubound st1))) as [e3 H0 H1]. intros. apply plus_reg_l with (ubound st1); auto. destruct e3 as [st3 tr3 emp3 ini3 acc3 Htr3 Hemp3 Hini3 Hacc3]. simpl in H0. assert (H2: Disjoint st1 st3). subst st3; auto. remember (fun s c=>if in_dec nat_eq_dec s st1 then tr1 s c else tr3 s c) as tr. assert (Htr: forall c s, In s (st1++st3) -> incl (tr s c) (st1++st3)). subst tr. intros s c H x Hx. apply in_app_or in H. apply in_or_app. destruct (in_dec nat_eq_dec c st1). left. apply Htr1 in Hx; auto. apply Htr3 in Hx; auto. destruct H; auto; contradiction. remember (fun s=>if in_dec nat_eq_dec s st1 then emp1 s else emp3 s) as emp. assert (Hemp: forall s, In s (st1++st3) -> incl (emp s) (st1++st3)). intros s H x Hx. subst emp. apply in_app_or in H. apply in_or_app. destruct (in_dec nat_eq_dec s st1). apply Hemp1 in Hx; auto. apply Hemp3 in Hx; auto. destruct H; auto; contradiction. assert (Hini: incl (ini1++ini3) (st1++st3)). intros x Hx. apply in_or_app. apply in_app_or in Hx. destruct Hx; auto.  assert (Hacc: incl (acc1++acc3) (st1++st3)). intros x Hx. apply in_or_app. apply in_app_or in Hx. destruct Hx; auto. exists (mkEFA tr emp Htr Hemp Hini Hacc). intros; split; intros.
  inversion H. simpl in H3. simpl in H4. clear H. apply in_app_or in H4. destruct H4; [left|right]. assert (incl l st1). subst tr emp. apply Hini1 in H. inversion H6. subst a l. clear -H5 H Hemp1 Htr1. revert H5 H. revert w is. induction l0; intros. inversion H5. intros x Hx. destruct Hx. subst x s; auto. destruct H1. intros x Hx. destruct Hx. subst x; auto. inversion H5. subst w0 s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1); [|contradiction]. apply Hemp1 in H7; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. subst w s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1); [|contradiction]. apply Htr1 in H7. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. apply EFAacc_intro with is es l; simpl; intros; auto. apply in_app_or in H3. destruct H3; auto. apply Hacc3 in H3. contradict H3. apply Disjoint_In1 with st1; auto. apply EFAsteps_incl with (st:=st1) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. apply H1. assert (incl l st3). apply Hini3 in H. inversion H6. subst a l emp tr. clear -H H5 Hemp3 Htr3 H2. revert H5 H. revert w is. induction l0; intros. intros x Hx. destruct Hx. subst x; auto. destruct H0. inversion H5. simpl in H7. subst w0 s t l0. destruct (in_dec nat_eq_dec is st1). contradict H. apply Disjoint_In1 with st1; auto. apply Hemp3 in H7. intros x Hx. destruct Hx. subst x; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. 
  subst w s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1). contradict H. apply Disjoint_In1 with st1; auto. apply Htr3 in H7. intros x Hx. destruct Hx. subst x; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. apply EFAacc_intro with is es l; simpl; intros; auto. apply in_app_or in H3. destruct H3; auto. apply Hacc1 in H3. contradict H3. apply Disjoint_In1 with st3; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto. contradict H8; apply Disjoint_In1 with st1; auto. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H8; apply Disjoint_In1 with st1; auto.
  destruct H. inversion H. apply EFAacc_intro with is es l; simpl; auto. apply in_or_app; auto. apply in_or_app; auto. apply EFAsteps_incl with (e1:=mkEFA tr1 emp1 Htr1 Hemp1 Hini1 Hacc1) (st:=st1); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H5; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. apply H1 in H. inversion H. apply EFAacc_intro with is es l; simpl; auto. apply in_or_app; auto. apply in_or_app; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr3 emp3 Htr3 Hemp3 Hini3 Hacc3); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H5; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto. contradict H8. eapply Disjoint_In1; eauto. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H8. eapply Disjoint_In1; eauto. Defined.
Definition EFA_cons: forall e1 e2, {eo|forall w, EFAacc eo w <-> exists w1 w2, w=w1++w2 /\ EFAacc e1 w1 /\ EFAacc e2 w2}. intros. destruct e1 as [st1 tr1 emp1 ini1 acc1 Htr1 Hemp1 Hini1 Hacc1]. destruct (EFA_map e2 (plus (ubound st1))) as [e3 H H0]. intros. eapply plus_reg_l; eauto. destruct e3 as [st3 tr3 emp3 ini3 acc3 Htr3 Hemp3 Hini3 Hacc3]. simpl in H. assert (Disjoint st1 st3). subst st3; auto. remember (fun s c=>if in_dec nat_eq_dec s st1 then tr1 s c else tr3 s c) as tr. remember (fun s=>if in_dec nat_eq_dec s st3 then emp3 s else if in_dec nat_eq_dec s acc1 then emp1 s++ini3 else emp1 s) as emp. assert (Htr: forall c s, In s (st1++st3) -> incl (tr s c) (st1++st3)). intros. intros x Hx. apply in_app_or in H2. subst tr. apply in_or_app. destruct (in_dec nat_eq_dec s st1). apply Htr1 in Hx; auto. apply Htr3 in Hx; auto. destruct H2; auto; contradiction. assert (Hemp: forall s, In s (st1++st3) -> incl (emp s) (st1++st3)). intros. intros x Hx. apply in_or_app. apply in_app_or in H2. subst emp. destruct (in_dec nat_eq_dec s st3). apply Hemp3 in Hx; auto. destruct H2; [|contradiction]. destruct (in_dec nat_eq_dec s acc1). apply in_app_or in Hx. destruct Hx. apply Hemp1 in H3; auto. apply Hini3 in H3; auto. apply Hemp1 in Hx; auto. assert (Hini: incl ini1 (st1++st3)). intros x Hx. apply in_or_app. apply Hini1 in Hx; auto. assert (Hacc: incl acc3 (st1++st3)). intros x Hx. apply in_or_app. apply Hacc3 in Hx; auto. clear H. exists (mkEFA tr emp Htr Hemp Hini Hacc). intros; split; intros.
  inversion H. simpl in H2. simpl in H3. clear H. assert (incl l (st1++st3)). apply EFAsteps_const with (s:=is) in H4; auto. destruct (split_until (fun s=>In s st3) l) as [[l1 [is3 [l3 [H7 H8] H9]]]|H7]. intros. apply in_dec. apply nat_eq_dec. subst l. destruct (Tail_dec' l1) as [[es1 H8 _]|H8]. apply EFAsteps_app_s_rev with (s:=es1) in H4; auto. destruct H4 as [w1 [w2 [Ha [Hb Hc]]]]. subst w. exists w1. exists w2. split; auto. inversion Hc. subst w s t l. simpl in H14. clear Hc. assert (In es1 acc1 /\ In is3 ini3). subst emp. destruct (in_dec nat_eq_dec es1 st3). contradict i. apply Forall_forall with (x:=es1) in H9; auto. destruct (in_dec nat_eq_dec es1 acc1) as [Hi|Hi]. split; auto. apply in_app_or in H14. destruct H14; auto. contradict H7. apply Disjoint_In1 with st1; auto. apply Hemp1 in H4; auto. apply Hemp1 in H14. contradict H7. apply Disjoint_In1 with st1; auto. assert (In es1 (st1++st3)). apply H. apply in_or_app; auto. apply in_app_or in H4. destruct H4; auto; contradiction. destruct H4. clear H14. split; [|apply H0]; clear H0. apply EFAacc_intro with is es1 l1; simpl; auto. apply EFAsteps_incl with (st:=st1) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. intros x Hx. assert (In x (st1++st3)). apply H. apply in_or_app; auto. apply in_app_or in H0. destruct H0; auto. contradict H0. apply Forall_forall with (x:=x) in H9; auto. subst emp. destruct (in_dec nat_eq_dec s st3). contradict i. apply Disjoint_In1 with st1; auto. destruct (in_dec nat_eq_dec s acc1); auto. apply in_app_or in H11. destruct H11; auto. apply Hini3 in H11. contradict H11. apply Disjoint_In1 with st1; auto. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction.
  destruct l1. inversion H5. subst is3. contradict H7. apply Disjoint_In1 with st1; auto. inversion H5; auto. apply EFAacc_intro with is3 es (is3::l3); auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. intros x Hx. destruct Hx. subst x; auto. apply Hini3 in H10. subst tr emp. clear -H0 H10 H12 H1 Hemp3 Htr3. revert H12 H10 H0. revert w2 is3 x. induction l3; intros. destruct H0. inversion H12. simpl in H6. subst w2 s t l. destruct (in_dec nat_eq_dec is3 st3); [|contradiction]. apply Hemp3 in H6; auto. destruct H0. subst x; auto. apply IHl3 with (x:=x) in H4; auto. subst w2 s t l. simpl in H6. destruct (in_dec nat_eq_dec is3 st1). contradict H10; apply Disjoint_In1 with st1; auto. apply Htr3 in H6; auto. destruct H0. subst x; auto. apply IHl3 with (x:=x) in H4; auto. subst emp. destruct (in_dec nat_eq_dec s st3); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H0. apply Disjoint_In1 with st1; auto. clear -H6. induction l1. auto. apply IHl1. inversion H6. destruct l1; inversion H2. auto. subst w2 s t l. simpl in H14. contradict H7. apply Disjoint_In1 with st1; auto. subst tr. destruct (in_dec nat_eq_dec es1 st1). apply Htr1 in H14; auto. assert (In es1 (st1++st3)). apply H. apply in_or_app; auto. apply in_app_or in H4. destruct H4. contradiction. contradict H4. apply Forall_forall with (x:=es1) in H9; auto. subst l1. inversion H5. subst a is3. contradict H7. apply Disjoint_In1 with st1; auto. apply Hacc3 in H2. contradict H2. apply Forall_forall with (x:=es) in H7; auto.
  destruct H as [w1 [w2 [Hw [H2 H3]]]]. subst w. apply H0 in H3. clear H0. inversion H2. clear H2. simpl in H0. simpl in H. inversion H3. clear H3. simpl in H2. simpl in H7. apply EFAacc_intro with is es0 (l++l0); simpl; auto. apply EFAsteps_app with es; auto. apply EFAsteps_incl with (st:=st1) (e1:=mkEFA tr1 emp1 Htr1 Hemp1 Hini1 Hacc1); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H4; auto. subst emp. destruct (in_dec nat_eq_dec s st3). contradict i. apply Disjoint_In1 with st1; auto. destruct (in_dec nat_eq_dec s acc1). apply in_or_app; auto. auto. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. inversion H9. subst a l0. apply EFAsteps_empty; simpl; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr3 emp3 Htr3 Hemp3 Hini3 Hacc3); simpl; intros; auto. apply EFAsteps_const with (s:=is0) in H8; auto. subst emp. destruct (in_dec nat_eq_dec s st3); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H3. apply Disjoint_In1 with st1; auto. subst emp. destruct (in_dec nat_eq_dec es st3). contradict i; apply Disjoint_In1 with st1; auto. destruct (in_dec nat_eq_dec es acc1); [|contradiction]. apply in_or_app; auto. inversion H5; simpl; auto. Defined.
Definition EFA_Rstar: forall r e, (forall w, Racc r w<-> EFAacc e w) -> {eo| forall w, Racc (Rstar r) w <-> EFAacc eo w}. intros. destruct e as [st tr emp ini acc Htr Hemp Hini Hacc]. remember (ubound st) as n. assert (~In n st). subst n. unfold ubound. destruct (ubound_sig st). intros D. apply l in D. contradict D. apply le_not_lt; auto. clear Heqn. remember (fun s c=>if nat_eq_dec s n then nil else tr s c) as tr'. remember (fun s=> if nat_eq_dec s n then ini else if in_dec nat_eq_dec s acc then n::emp s else emp s) as emp'. assert (Hini': incl (n::nil) (n::st)). intros x Hx. destruct Hx. subst x; auto. destruct H1. assert (Htr': forall c s, In s (n::st) -> incl (tr' s c) (n::st)). intros. intros x Hx. subst tr'. destruct (nat_eq_dec s n). subst s. destruct Hx. right. apply Htr in Hx; auto. destruct H1; auto. contradict n0; auto. assert (Hemp': forall s, In s (n::st) -> incl (emp' s) (n::st)). intros. intros x Hx. subst emp'. destruct (nat_eq_dec s n). subst n. right. apply Hini in Hx; auto. destruct (in_dec nat_eq_dec s acc). destruct Hx. subst x; auto. apply Hemp in H2; auto. apply Hemp in Hx; auto. destruct H1; auto. contradict n0; auto. exists (mkEFA tr' emp' Htr' Hemp' Hini' Hini'). intros; split; intros. revert H1. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar r) w->EFAacc (mkEFA tr' emp' Htr' Hemp' Hini' Hini') w). clear w. intros w IH H1. apply Rstar_rev in H1. destruct H1 as [[w1 [w2 [H3 [H4 [H5 H6]]]]]|H3]. subst w. apply H in H5. clear H. apply IH in H6. clear IH. inversion H5. inversion H6. simpl in H1. simpl in H2. simpl in H. simpl in H8. simpl in H9. clear H5 H6. destruct H8; [|destruct H5]. destruct H9; [|destruct H6]. subst es0 is0. apply EFAacc_intro with n n ((n::l)++l0). simpl; auto. simpl; auto. apply EFAsteps_app with es; auto. inversion H3. subst a l. apply EFAsteps_empty; auto.
  apply EFAsteps_incl with (st:=st) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H2; auto. subst emp'. destruct (nat_eq_dec s n). subst s. contradiction. destruct (in_dec nat_eq_dec s acc); auto. subst tr'. destruct (nat_eq_dec s n); auto. subst s; contradiction. simpl. subst emp'. destruct (nat_eq_dec n n); auto. contradict n0; auto. inversion H11. subst a l0. apply EFAsteps_empty; auto. simpl. subst emp'. destruct (nat_eq_dec es n). subst es. apply Hacc in H. contradiction. destruct (in_dec nat_eq_dec es acc); auto. contradiction. simpl; auto. clear -H12. simpl. apply Tail_cons. induction l; simpl; auto. unfold ltof. rewrite app_length. destruct w1. contradict H4; auto. simpl. apply le_n_S. apply le_plus_r. subst w. apply EFAacc_intro with n n (n::nil); simpl; auto.
  inversion H1. simpl in H3. simpl in H2. clear H1. destruct H2; [|contradict H1]. destruct H3; [|contradict H2]. subst es is. revert H4 H5 H6. revert w. apply (Fix (well_founded_ltof (list nat) (length (A:=nat)))) with (P:=fun l=> forall w, EFAsteps (mkEFA tr' emp' Htr' Hemp' Hini' Hini') w l->Head n l -> Tail n l->Racc (Rstar r) w). clear l. intros l IH w. intros. inversion H2. subst a l. clear H2. inversion H1. subst w s l0. auto. simpl in H7. subst w0 s l0. assert (In t ini). subst emp'. destruct (nat_eq_dec n n); auto. contradict n0; auto. clear H7. destruct (split_until (eq n) (t::l)). intros. apply nat_eq_dec. destruct s as [m1 [x [m2 [Ha Hb] Hc]]]. subst x. clear H1. destruct m1. inversion Hb. subst t. apply Hini in H2; contradiction. inversion Hb. subst n0 l. clear Hb. assert (Ht:incl (t::m1) st). intros x Hx. assert (In x (n::st)). apply EFAsteps_const with (s:=t) in H6; simpl; auto. simpl in H6. apply H6.  replace (t::m1++n::m2) with ((t::m1)++n::m2); auto. apply in_or_app; auto. destruct H1; auto. subst x. absurd (n=n); auto. apply Forall_forall with (x:=n) in Hc; auto. replace (t::m1++n::m2) with ((t::m1)++n::m2) in H6; auto. destruct (Tail_dec' (t::m1)) as [[es H4 _]|H4]. apply EFAsteps_app_s_rev with (s:=es) in H6; auto. destruct H6 as [w1 [w2 [Ha [Hb Hd]]]]. subst w. inversion Hd. subst w s t0 l. simpl in H9. clear Hd. assert (In es acc). subst emp'. destruct (nat_eq_dec es n). subst es. apply Hini in H9. contradiction. destruct (in_dec nat_eq_dec es acc); auto. apply Hemp in H9.  contradiction. apply Ht. auto.
  apply RAstar2; auto. apply H. apply EFAacc_intro with t es (t::m1); auto. apply EFAsteps_incl with (st:=st) (e1:=mkEFA tr' emp' Htr' Hemp' Hini' Hini'); simpl; intros; auto. subst emp'. destruct (nat_eq_dec s n). subst s; contradiction. destruct (nat_eq_dec es n). subst es. contradict H0. apply Ht; auto. destruct (in_dec nat_eq_dec s acc); auto. destruct H6; auto. subst t0; contradiction. subst tr'. destruct (nat_eq_dec s n); auto. destruct H6. apply IH with (n::m2); auto. unfold ltof. simpl. repeat apply le_n_S. rewrite app_length. simpl. rewrite <- plus_n_Sm. auto. clear -H3. inversion H3. subst a b l. inversion H1. destruct m1; inversion H4. subst a b l. clear -H2. induction m1; auto. apply IHm1. inversion H2; auto. destruct m1; inversion H3. simpl in H9. subst tr'. destruct (nat_eq_dec es n). destruct H9. apply Htr in H9. contradiction. apply Ht. auto. inversion H4. clear -H3 f. absurd (n=n); auto. inversion H3. apply Forall_forall with (x:=n) in f; auto. simpl in H7. subst w s l0. subst tr'. clear -H7. destruct (nat_eq_dec n n). destruct H7. contradict n0; auto. Defined.

Definition RegExp2EFA: forall r, {e|forall w, Racc r w <-> EFAacc e w}. induction r. destruct Rnil_DFA as [d H]. destruct (DFA2EFA d) as [e H0]. exists e. intros; split; intros. apply H0; apply H; auto. apply H; apply H0; auto. destruct (Rchar_DFA c) as [d H]. destruct (DFA2EFA d) as [e H0]. exists e. intros; split; intros. apply H0; apply H; auto. apply H; apply H0; auto. destruct IHr1 as [e1 H1]. destruct IHr2 as [e2 H2]. destruct (EFA_cons e1 e2) as [e H]. exists e. intros; split; intros. inversion H0. subst w r s. apply H. exists l. exists m. split; auto. split. apply H1; auto. apply H2; auto. apply H in H0. destruct H0 as [w1 [w2 [Ha [Hb Hc]]]]. subst w. apply H1 in Hb. apply H2 in Hc. auto.
  destruct IHr1 as [e1 H1]. destruct IHr2 as [e2 H2]. destruct (EFA_or e1 e2) as [e H]. exists e. intros; split; intros. apply H. inversion H0; [left; apply H1|right; apply H2]; auto. apply H in H0. destruct H0; [apply H1 in H0|apply H2 in H0]; auto.
  destruct IHr as [e H]. destruct (EFA_Rstar H) as [eo H0]. exists eo; auto. Defined.


(* RegExp Finite Automaton *)
Record RFA: Set:= mkRFA {
  RFAstates: list nat;
  RFAtrans: nat -> nat -> RegExp;
  RFAinit: list nat;
  RFAaccept: list nat;
  RFAtrans_const: forall s t w, Racc (RFAtrans s t) w -> In s RFAstates /\ In t RFAstates;
  RFAinit_const: incl RFAinit RFAstates;
  RFAacc_const: incl RFAaccept RFAstates;
}.

Inductive RFAsteps (e:RFA): list C -> list nat -> Prop:=
| RFAsteps_nil: forall s, RFAsteps e nil (s::nil)
| RFAsteps_cons: forall s t l w1 w2, RFAsteps e w2 (t::l) -> Racc (RFAtrans e s t) w1 -> RFAsteps e (w1++w2) (s::t::l)
.
Inductive RFAacc (e:RFA) (w:list C): Prop:= RFAacc_intro: forall l is es, RFAsteps e w l -> Head is l -> Tail es l -> In is (RFAinit e) -> In es (RFAaccept e) -> RFAacc e w.
Hint Constructors RFAsteps RFAacc.

Theorem RFAsteps_const: forall e w l is, RFAsteps e w l -> Head is l -> In is (RFAstates e) -> incl l (RFAstates e). Proof. intros e w l is H. revert is. induction H; intros; intros x Hx. destruct Hx. subst x. inversion H; subst a s; auto. destruct H1. inversion H1. subst a s l0. destruct Hx. subst x; auto. apply IHRFAsteps with (is:=t) in H3; auto. apply (RFAtrans_const e) in H0. destruct H0; auto. Qed.
Theorem RFAsteps_app: forall r w1 l1 s w2 l2, RFAsteps r w1 l1 -> Tail s l1 -> RFAsteps r w2 (s::l2) -> RFAsteps r (w1++w2) (l1++l2). Proof. intros r w1 l1 s w2 l2 H. revert w2 l2 s. induction H; intros. inversion H; simpl. subst a s0; auto. inversion H3. inversion H1. subst a b l0. apply IHRFAsteps in H2; auto. rewrite <- app_assoc. simpl. auto. Qed.
Theorem RFAsteps_app_s_rev: forall r w l1 s l2, RFAsteps r w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ RFAsteps r w1 l1 /\ RFAsteps r w2 (s::l2). Proof. intros r w l1. revert w. induction l1; intros. inversion H0. inversion H0. subst a a0 l1. exists nil. exists w. simpl in H; auto. subst a0 b l1. clear H0. inversion H. destruct l. inversion H3. inversion H4. subst w s0. destruct l. inversion H3. inversion H1. subst n l0. clear H1. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [wa [wb [Ha [Hb Hc]]]]. subst w2. exists (w1++wa). exists wb. split. rewrite app_assoc; auto. split; auto. Qed.

Definition EFA2RFA: forall e cset, (forall s c, In s (EFAstates e) -> EFAtrans e s c <> nil -> In c cset) -> {r| forall w, EFAacc e w <-> RFAacc r w}. intros. destruct e as [st tr emp ini acc Htr Hemp Hini Hacc]. simpl in H. assert (tr_chars: forall s t, In s st->In t st->{cs|forall c, In c cs <-> In t (tr s c)}). intros.  exists (filter (dec2b (fun x=>in_dec nat_eq_dec t (tr s x))) cset). intros; split; intros. apply filter_In in H2. destruct H2. apply dec2b_true in H3; auto. apply filter_In. split. apply H with s; auto. contradict H2. rewrite H2. auto. apply dec2b_true; auto.
  remember (fun s t=>match in_dec nat_eq_dec s st with left _ Hs => match in_dec nat_eq_dec t st with left _ Ht => let (cs,_):=tr_chars s t Hs Ht in let r:=fold_right (fun c r=>Ror (Rchar c) r) Rnil cs in if in_dec nat_eq_dec t (emp s) then Ror Remp r else r  |right _ _ => Rnil end |right _ _ => Rnil end) as tr'. assert (Htr': forall s t w, Racc (tr' s t) w->In s st/\In t st). intros. subst tr'. destruct (in_dec nat_eq_dec s st). destruct (in_dec nat_eq_dec t st); auto. inversion H0. inversion H0. exists (mkRFA tr' Htr' Hini Hacc). intros; split; intros. inversion H0. simpl in H1. simpl in H2. apply RFAacc_intro with l is es; auto. assert (incl l st). apply EFAsteps_const with (s:=is) in H3; auto. clear H0 H1 H2 H4 H5. subst tr'. induction H3; auto. replace w with (nil++w); auto. apply RFAsteps_cons. apply IHEFAsteps. intros x Hx. apply H6. right; auto. simpl. clear H3 IHEFAsteps Htr'. simpl in H0. destruct (in_dec nat_eq_dec s st). destruct (in_dec nat_eq_dec t st). destruct (tr_chars s t i i0) as [cs H7]. destruct (in_dec nat_eq_dec t (emp s)). apply RAor1. apply Remp_spec; auto. contradiction. contradict n. apply H6; auto. contradict n; auto. replace (c::w) with ((c::nil)++w); auto. apply RFAsteps_cons; auto. apply IHEFAsteps; auto. intros x Hx; apply H6; auto. simpl in H0. simpl. clear H3 IHEFAsteps Htr'. destruct (in_dec nat_eq_dec s st). destruct (in_dec nat_eq_dec t st). destruct (tr_chars s t i i0) as [cs H7]. destruct (in_dec nat_eq_dec t (emp s)). apply RAor2. apply H7 in H0. clear -H0. induction cs. destruct H0. inversion H0. subst a. simpl. apply RAor1. auto. simpl.  apply RAor2. apply IHcs. auto. apply H7 in H0.  clear -H0. induction cs. destruct H0. inversion H0. subst a. simpl. auto. simpl; auto. contradict n; apply H6; auto. contradict n; apply H6; auto.
  inversion H0. apply EFAacc_intro with is es l; auto. assert (incl l st). apply RFAsteps_const with (is:=is) in H1; auto. clear H0 H2 H3 H4 H5. induction H1; auto. simpl in H0. subst tr'. destruct (in_dec nat_eq_dec s st). destruct (in_dec nat_eq_dec t st). destruct (tr_chars s t i i0) as [cs H2]. simpl in H0. destruct (in_dec nat_eq_dec t (emp s)). inversion H0. apply Remp_spec in H7. subst w1. simpl. apply EFAsteps_empty; simpl; auto. apply IHRFAsteps; auto. intros x Hx. apply H6; auto. subst r s0 l0. cut (exists c, In c cs/\w1=c::nil). intros. destruct H3 as [c [H3 H4]]. subst w1. simpl. apply EFAsteps_cons; auto. apply IHRFAsteps. intros x Hx. apply H6; auto. simpl. apply H2; auto. clear -H7. induction cs; simpl in H7. inversion H7. inversion H7. inversion H2. exists a; auto. apply IHcs in H2. destruct H2 as [c [H3 H4]]. exists c; auto. clear H1 Htr'. cut (exists c, In c cs /\ w1=c::nil); intros. destruct H1 as [c [H4 H3]]. subst w1. apply EFAsteps_cons; auto. apply IHRFAsteps. intros x Hx; apply H6; auto. simpl. apply H2; auto. clear -H0. induction cs; simpl in H0. inversion H0. inversion H0. exists a; auto. inversion H3; auto. apply IHcs in H3. destruct H3 as [c [H3 H4]]. exists c; auto. contradict n. apply H6; auto. contradict n. apply H6; auto. Defined.

Definition RFA2single_edge: forall r, {i:nat &{e:nat &{st:list nat &{r'|forall w, RFAacc r w<-> RFAacc r' w & RFAstates r' = i::e::st /\ RFAinit r' = i::nil /\ RFAaccept r' = e::nil/\ NoDup (i::e::st)/\ (forall w s,~Racc (RFAtrans r' s i) w) /\ (forall w t,~Racc (RFAtrans r' e t) w)}}}}. intros. destruct r as [st tr ini acc Htr Hini Hacc]. remember (nodup nat_eq_dec st) as st'. assert (NoDup st'). subst st'. apply NoDup_nodup. assert (forall s, In s st' <-> In s st). intros. subst st'. apply nodup_In. clear Heqst'. remember (ubound st') as e. assert (~In e st'). subst e. unfold ubound. destruct (ubound_sig st'). intros D. apply l in D. contradict D; apply le_not_lt; auto. remember (S e) as i. assert (~In i (e::st')). intros D. destruct D. subst i. contradict H2. clear -e. induction e; auto. subst i e. unfold ubound in H2. destruct (ubound_sig st'). apply l in H2. contradict H2. apply le_not_lt; auto. clear Heqe Heqi. exists i. exists e. exists st'. remember (fun s t=> if nat_eq_dec s i then if in_dec nat_eq_dec t ini then Remp else Rnil else if nat_eq_dec t e then if in_dec nat_eq_dec s acc then Remp else Rnil else tr s t) as tr'. assert (Htr': forall s t w, Racc (tr' s t) w -> In s (i::e::st')/\In t (i::e::st')). intros. subst tr'. destruct (nat_eq_dec s i). subst s. destruct (in_dec nat_eq_dec t ini). split; auto. apply Hini in i0; auto. apply H0 in i0; auto. inversion H3. destruct (nat_eq_dec t e). subst t. split; auto. destruct (in_dec nat_eq_dec s acc). apply Hacc in i0. apply H0 in i0; auto. inversion H3. apply Htr in H3. destruct H3. apply H0 in H3. apply H0 in H4; auto. assert (Hini':incl (i::nil) (i::e::st')). intros x Hx. destruct Hx. subst x; auto. destruct H3. assert (Hacc': incl (e::nil) (i::e::st')). intros x Hx. destruct Hx. subst x; auto. destruct H3.
  assert (Hi:forall w s, ~Racc (tr' s i) w). intros w s D. subst tr'. destruct (nat_eq_dec s i). subst s. destruct (in_dec nat_eq_dec i ini). contradict H2. right. apply H0; auto. inversion D. destruct (nat_eq_dec i e). subst e; contradict H2; auto. apply Htr in D. destruct D. contradict H2; right; apply H0; auto. assert (He:forall w s, ~Racc (tr' e s ) w). simpl. intros w s D. subst tr'. destruct (nat_eq_dec e i). subst e; contradict H2; auto. destruct (nat_eq_dec s e). subst s. destruct (in_dec nat_eq_dec e acc). contradict H1; apply H0; auto. inversion D. apply Htr in D. destruct D. contradict H1; apply H0; auto. exists (mkRFA tr' Htr' Hini' Hacc'). intros; split; intros.
  inversion H3. clear H3. simpl in H7. simpl in H8. apply RFAacc_intro with (i::l++e::nil) i e; simpl; auto. assert (incl l st). apply RFAsteps_const with (is:=is) in H4; auto. inversion H5. subst a l.  simpl. replace w with (nil++w); auto. apply RFAsteps_cons; auto. replace w with (w++nil). replace (is::l0++e::nil) with ((is::l0)++e::nil); auto. apply RFAsteps_app with (s:=es); auto. revert H4. revert H3. generalize (is::l0). intros l Hl Hj. induction Hj; auto. apply RFAsteps_cons. apply IHHj. intros x Hx; apply Hl; auto. simpl. subst tr'. destruct (nat_eq_dec s i). subst s. contradict H2. right. apply H0. apply Hl; auto. destruct (nat_eq_dec t e). subst t. contradict H1. apply H0. apply Hl; auto. simpl in H3; auto. replace nil with (nil (A:=C)++nil) at 1; auto. apply RFAsteps_cons; auto. simpl. subst tr'. destruct (nat_eq_dec es i). subst es. contradict H2. right. apply H0; auto. destruct (nat_eq_dec e e). destruct (in_dec nat_eq_dec es acc). apply Remp_spec; auto. contradiction. contradict n0; auto. rewrite app_nil_r; auto. simpl. subst tr'. destruct (nat_eq_dec i i). destruct (in_dec nat_eq_dec is ini). apply Remp_spec; auto. contradiction. contradict n; auto.
  assert (Hs:forall l s w, RFAsteps (mkRFA tr' Htr' Hini' Hacc') w (s::l) -> ~In i l). clear -Hi. induction l; intros; auto. intros D. destruct D. subst a. inversion H. simpl in H5. contradict H5; auto. contradict H0. inversion H. apply IHl with a w2; auto. assert (Ht:forall l s w, RFAsteps (mkRFA tr' Htr' Hini' Hacc') w (l++s::nil) -> ~In e l). clear -He. induction l; intros; auto. intros D. destruct D. subst a. inversion H. destruct l; inversion H3. simpl in H4. contradict H4; auto. contradict H0. inversion H. destruct l; inversion H3. rewrite H1 in H3. apply IHl with s w2; auto.  inversion H3. clear H3. simpl in H7. destruct H7; [subst is|inversion H3]. destruct H8; [subst es|inversion H3]. inversion H5. subst a l. apply Tail_rev in H6. destruct H6 as [l H6]. destruct l. inversion H6. subst e. contradict H2; auto. inversion H6. subst n l0. clear H5 H6. assert (incl l st). intros x Hx. apply H0. assert (In x (i::e::st')). apply RFAsteps_const with (is:=i) in H4; auto. apply H4. right. apply in_or_app; auto. destruct H3. subst x. absurd (In i (l++e::nil)). apply Hs in H4; auto. apply in_or_app; auto. destruct H3; auto. subst x. absurd (In e (i::l)); auto. replace (i::l++e::nil) with ((i::l)++e::nil) in H4; auto. apply Ht in H4; auto. clear Hs Ht. inversion H4. destruct l; inversion H8. subst w s. simpl in H9. assert (In t ini/\w1=nil). subst tr'. clear -H9. destruct (nat_eq_dec i i); [|contradict n; auto]. destruct (in_dec nat_eq_dec t ini). apply Remp_spec in H9; auto. inversion H9. destruct H5. subst w1. destruct l as [|is l]. inversion H6. subst t. contradict H1. apply H0; auto. inversion H6. subst t l0. clear H6 H9 H4. destruct (Tail_dec' (is::l)) as [[es H4 _]|H4]; [|inversion H4]. replace (is::l++e::nil) with ((is::l)++e::nil) in H8; auto. apply RFAsteps_app_s_rev with (s:=es) in H8; auto. destruct H8 as [wa [wb [Ha [Hb Hc]]]]. subst w2.
  assert (In es acc/\wb=nil). inversion Hc. subst wb s t l0. simpl in H11. clear Hc. subst tr'. destruct (nat_eq_dec es i). subst es. absurd (In i st'). contradict H2; auto. apply H0. apply H3. auto. destruct (nat_eq_dec e e); [|contradict n0; auto]. destruct (in_dec nat_eq_dec es acc). split; auto. apply Remp_spec in H11. subst w1. inversion H9; auto. inversion H11. destruct H6. subst wb. simpl. rewrite app_nil_r. apply RFAacc_intro with (is::l) is es; auto. clear -Hb H3 H0 H1 H2 Heqtr'. revert H3 Hb. revert wa. generalize (is::l). clear l. induction l; intros. inversion Hb. inversion Hb. auto. subst wa a l. apply RFAsteps_cons; auto. apply IHl; auto. intros x Hx. apply H3; auto. simpl. simpl in H7. clear IHl Hb H6. subst tr'. destruct (nat_eq_dec s i).  subst s. absurd (In i st). contradict H2. right. apply H0; auto. apply H3; auto. destruct (nat_eq_dec t e). subst t. absurd (In e st). contradict H1. apply H0; auto. apply H3; auto. auto.
  split; auto. split; auto. split; auto. split; auto. apply NoDup_cons; auto. apply NoDup_cons; auto. Defined.

Definition head_n_split: forall {T:Type} n l, {l1:list T &{l2|l=l1++l2 & n <= length l->length l1=n}}. induction n. intros. exists nil. exists l; auto. intros. destruct l. exists nil. exists nil; auto. intros. inversion H. destruct (IHn l) as [l1 [l2 H1 H2]]. exists (t::l1). exists l2. simpl; f_equal; auto. intros. simpl. f_equal. apply H2. apply le_S_n; auto. Defined.
Definition repeat_head: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) a l, {n:nat &{b:T &{m| l=repeat a n++b::m & b<>a}}}+{n|l=repeat a n}. induction l. right. exists 0; auto. destruct (T_eq_dec a0 a). subst a0. destruct IHl as [[n [b [m H1 H2]]]|[n H1]]. subst l. left. exists (S n). exists b. exists m; auto. subst l. right. exists (S n); auto. left. exists 0. exists a0. exists l; auto. Defined.
Definition app_rev: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l1 l2 m1 m2:list T), l1++l2=m1++m2 -> {n|l1=m1++n /\ m2=n++l2 & n<>nil}+{n|m1=l1++n/\l2=n++m2&n<>nil}+{l1=m1/\l2=m2}. induction l1; intros. destruct m1. right. simpl in H; auto. left. right. exists (t::m1); auto. intros D; inversion D. destruct m1 as [|b m1]. simpl in H. left. left. exists (a::l1); auto. intros D; inversion D. simpl in H. inversion H. subst b. apply IHl1 in H2. destruct H2 as [[[n [H3 H4] H5]|[n [H3 H4] H5]]|H3]. subst l1 m2. left. left. exists n; auto. subst m1 l2. left. right. exists n; auto. destruct H3. subst m1 m2. right; auto. Defined.
Theorem In_split: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (a:T) l, {l1:list T &{l2| l=l1++a::l2 & ~In a l1}}+{~In a l}. induction l. right; auto. destruct (T_eq_dec a0 a). subst a0. left. exists nil. exists l; auto. destruct IHl as [[l1 [l2 H1 H2]]|H1]. left. exists (a0::l1). exists l2; auto. simpl. f_equal; auto. intros D. destruct D; contradiction. right. intros D. destruct D; contradiction. Defined.
Theorem pegeon_hole: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), incl l m -> length m<length l -> {a:T &{l1:list T &{l2:list T &{l3:list T|l=l1++a::l2++a::l3}}}}. Proof. intros. revert dependent l. induction m; intros. destruct l. contradict H0. apply le_not_lt; auto. absurd (In t nil); auto. destruct (In_split T_eq_dec a l) as [[l1 [l2 H1 H2]]|H1]. subst l. destruct (In_split T_eq_dec a l2) as [[l3 [l4 H3 H4]]|H3]. subst l2. exists a. exists l1. exists l3. exists l4; auto. destruct (IHm (l1++l2)). intros x Hx. cut (In x (a::m)); intros. destruct H1. subst x. apply in_app_or in Hx. destruct Hx; contradiction. auto. apply H. apply in_or_app. apply in_app_or in Hx. destruct Hx; auto. rewrite app_length in H0. simpl in H0. rewrite plus_comm in H0. simpl in H0. apply le_S_n in H0. rewrite app_length. rewrite plus_comm; auto. destruct s as [l3 [l4 [l5 H4]]]. exists x. apply app_rev in H4. destruct H4 as [[[n [Ha Hb] Hc]|[n [Ha Hb] Hc]]|Ha]. subst l1. destruct n. contradict Hc; auto. inversion Hb. subst t. clear Hb Hc. apply app_rev in H5. destruct H5 as [[[o [Hd He] Hf]|[o [Hd He] Hf]]|Hf].  subst l4 l2. exists l3. exists (n++a::o). exists l5. rewrite <- app_assoc. f_equal. simpl. f_equal. rewrite <- app_assoc. f_equal. subst n. destruct o. contradict Hf; auto. inversion He. subst t l5. exists l3. exists l4. exists (o++a::l2). rewrite <- app_assoc. f_equal. simpl; f_equal. rewrite <- app_assoc. f_equal. destruct Hf. subst n l2. exists l3. exists (l4++a::nil). exists l5. rewrite <- app_assoc. f_equal. simpl. f_equal. rewrite <- app_assoc. f_equal. auto. subst l3 l2. exists (l1++a::n).  exists l4. exists l5. rewrite <- app_assoc. f_equal. auto. destruct Ha. subst l2 l3. exists (l1++a::nil). exists l4. exists l5. rewrite <- app_assoc; auto. auto. apply IHm. intros x Hx. assert (In x (a::m)). apply H; auto. destruct H2; auto. subst x; contradiction. simpl in H0. apply lt_le_weak; auto. Defined.
Definition RFAsingle2RegExp: forall st i e r, RFAstates r = i::e::st -> RFAinit r = i::nil -> RFAaccept r = e::nil -> NoDup (i::e::st) -> (forall w s, ~Racc (RFAtrans r s i) w) -> (forall w s, ~Racc (RFAtrans r e s) w) -> {e| forall w, Racc e w <-> RFAacc r w}. induction st as [|p st]; intros. destruct r as [st tr ini acc Htr Hini Hacc]. simpl in H0. subst ini. simpl in H. subst st. simpl in H1. subst acc. simpl in H4. simpl in H3. exists (tr i e). intros; split; intros. apply RFAacc_intro with (i::e::nil) i e; simpl; auto. replace w with (w++nil). apply RFAsteps_cons; auto. rewrite app_nil_r; auto. inversion H. simpl in H6. destruct H6; [subst is|inversion H6]. simpl in H7. destruct H7; [subst es|inversion H6]. clear H. inversion H1. subst a l. inversion H0. subst w l0 s. inversion H5. subst e a. inversion H2. contradict H7; auto. inversion H7. subst w s l0. clear H0. simpl in H9. assert (In t (i::e::nil)). apply Htr in H9. destruct H9; auto. destruct H. subst t. contradict H9; auto. destruct H. subst t. destruct l. inversion H8. rewrite app_nil_r; auto. inversion H8. simpl in H11. contradict H11; auto. destruct H.
  destruct r as [st' tr ini acc Htr Hini Hacc]. simpl in H. subst st'. simpl in H1. subst acc. simpl in H0. subst ini. simpl in H4. simpl in H3. remember (fun s t=>if nat_eq_dec s p then Rnil else if nat_eq_dec t p then Rnil else Ror (tr s t) (Rcons (tr s p) (Rcons (Rstar (tr p p)) (tr p t))) ) as tr'. assert (Htr': forall s t w, Racc (tr' s t) w -> In s (i::e::st) /\ In t (i::e::st)). intros. subst tr'. destruct (nat_eq_dec s p). inversion H. destruct (nat_eq_dec t p). inversion H. inversion H. apply Htr in H6. destruct H6. split. destruct H6. subst s; auto. destruct H6. subst e; auto. destruct H6; auto. contradict n; auto. destruct H7. subst t; auto. destruct H7. subst e; auto. destruct H7; auto. contradict n0; auto. subst r s0 l. inversion H6. subst r s0 w. apply Htr in H5. destruct H5. inversion H8. subst r s0 m. apply Htr in H11. destruct H11. clear -H0 H7 n n0. split. destruct H0. subst s; auto. destruct H. subst e; auto. destruct H; auto. contradict n; auto. destruct H7. subst i; auto. destruct H. subst e; auto. destruct H; auto. contradict n0; auto. assert (Hini': incl (i::nil) (i::e::st)). intros x Hx.  destruct Hx. subst x; auto. destruct H. assert (Hacc':incl (e::nil) (i::e::st)). intros x Hx. destruct Hx. subst x; auto. destruct H. destruct (IHst i e (mkRFA tr' Htr' Hini' Hacc')) as [r' H]; simpl; auto. inversion H2. inversion H5. inversion H9. apply NoDup_cons. contradict H1. destruct H1. subst e i x; auto. auto. apply NoDup_cons; auto. intros w s D. subst tr'. destruct (nat_eq_dec s p). inversion D. destruct (nat_eq_dec i p). inversion D. inversion D. contradict H5; auto. inversion H5. inversion H10. contradict H15; auto. intros w s D. subst tr'. destruct (nat_eq_dec e p). inversion D. destruct (nat_eq_dec s p). inversion D. inversion D. contradict H5; auto. inversion H5. contradict H8; auto.
  exists r'. intros; split; intros. apply H in H0. clear H. inversion H0. clear H0. simpl in H6. destruct H6; [subst is|inversion H0]. simpl in H7. destruct H7; [subst es|inversion H0]. assert (forall l is es w, incl l (i::e::st) -> Head is l->Tail es l->RFAsteps (mkRFA tr' Htr' Hini' Hacc') w l -> exists m, Head is m /\ Tail es m /\ RFAsteps (mkRFA tr Htr Hini Hacc) w m). clear H H1 H5 l w. induction l; intros. inversion H0. inversion H5. subst w s l. inversion H0. subst a a0 l. inversion H1. subst a es. exists (is::nil); auto. inversion H8. subst w s l. apply IHl with t es w2 in H9; auto. simpl in H10. destruct H9 as [m [Ha [Hb Hc]]]. clear IHl IHst H5. subst tr'. assert (~In p (i::e::st)). inversion H2. intros D. destruct D. contradict H7; subst x i; auto. inversion H8. destruct H9. subst p. contradict H13; auto. inversion H14; contradiction. destruct (nat_eq_dec a p). subst a. contradict H5. apply H; auto. destruct (nat_eq_dec t p). subst p. contradict H5; apply H; auto. inversion H10. inversion H0. subst a a0 l1. exists (is::m). split; auto. split; auto. subst s r l. inversion Ha. subst a m. apply RFAsteps_cons; auto. subst r s l. inversion H9. subst w1 r s. inversion H12. subst r s m0. clear H9 H12 H10. inversion H0. subst a0 a l2. assert (exists sl, Head p sl /\ Tail p sl /\ RFAsteps (mkRFA tr Htr Hini Hacc) l1 sl). revert H11. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun l1=>Racc (Rstar (tr p p)) l1->exists sl, Head p sl /\ Tail p sl/\ RFAsteps (mkRFA tr Htr Hini Hacc) l1 sl). clear l1. intros l1 IH H7. apply Rstar_rev in H7. destruct H7 as [[w0 [w1 [Hd [He [Hf Hg]]]]]|Hd]. subst l1. destruct (IH w1) as [sl [Hh [Hi Hj]]]; auto. unfold ltof. destruct w0. contradict He; auto. simpl. apply le_n_S. rewrite app_length; auto. exists (p::sl). split; auto. split; auto. inversion Hh. subst a sl. apply RFAsteps_cons; auto. subst l1. exists (p::nil); auto.
  destruct H6 as [sl [H9 [H10 H12]]]. exists (is::sl++m). split; auto. split. apply Tail_cons. clear -Hb. induction sl; simpl; auto. rewrite <- app_assoc. inversion H9.  subst a sl. simpl. apply RFAsteps_cons; auto. rewrite <- app_assoc. replace (p::l2++m) with ((p::l2)++m); auto. apply RFAsteps_app with p; auto. inversion Ha. subst a m. apply RFAsteps_cons; auto.  intros x Hx. destruct Hx. subst x. apply H; auto. apply H; auto. inversion H1; auto.  apply H0 with (is:=i) (es:=e) in H; auto. destruct H as [m [Ha [Hb Hc]]]. apply RFAacc_intro with m i e; simpl; auto. apply RFAsteps_const with (is:=i) in H; auto.
  apply H. clear H. inversion H0. clear H0. simpl in H6. destruct H6; [subst is|inversion H0]. simpl in H7. destruct H7; [subst es|inversion H0]. assert (forall l is es w, incl l (i::e::p::st) -> Head is l->Tail es l->is<>p->es<>p->RFAsteps (mkRFA tr Htr Hini Hacc) w l -> RFAsteps (mkRFA tr' Htr' Hini' Hacc') w (remove nat_eq_dec p l)). clear H H1 H5 w l r' IHst. intros l. apply (Fix (well_founded_ltof (list nat) (length (A:=nat)))) with (P:=fun l=>forall is es w, incl l (i::e::p::st)->Head is l->Tail es l->is<>p->es<>p->RFAsteps (mkRFA tr Htr Hini Hacc) w l ->RFAsteps (mkRFA tr' Htr' Hini' Hacc') w (remove nat_eq_dec p l)). clear l. intros l IH. intros. inversion H0. subst a l. clear H0. inversion H7. subst w s l0. simpl. destruct (nat_eq_dec p is); auto. contradict H5; auto. subst w s l0. clear H7. simpl in H11. destruct (repeat_head nat_eq_dec p (t::l)) as [[n [u [l' Ha Hb]]]| [n Ha]]. destruct (nat_eq_dec n 0). subst n. simpl in Ha. inversion Ha. subst u l'. apply IH  with (is:=t) (es:=es) in H10; auto. simpl in H10. simpl. destruct (nat_eq_dec p is). contradict H5; auto. destruct (nat_eq_dec p t). contradict Hb; auto. apply RFAsteps_cons; simpl; auto. subst tr'. destruct (nat_eq_dec is p). contradict n; auto. destruct (nat_eq_dec t p). contradict Hb; auto. auto.  unfold ltof. auto. intros x Hx. apply H. auto. inversion H1; auto. rewrite Ha in H10. replace (repeat p n++u::l') with ((repeat p n++u::nil)++l') in H10. apply RFAsteps_app_s_rev with (s:=u) in H10. destruct H10 as [wa [wb [Hd [He Hf]]]]. subst w2. assert (t=p). destruct n. contradict n0; auto. simpl in Ha. inversion Ha; auto. rewrite Ha. subst t. rewrite app_assoc. replace (remove nat_eq_dec p (is::repeat p n++u::l')) with (is::u::remove nat_eq_dec p l'). apply RFAsteps_cons. apply IH with (is:=u) (es:=es) in Hf; auto. simpl in Hf. destruct (nat_eq_dec p u); auto. contradict Hb; auto. unfold ltof. rewrite Ha. simpl; repeat apply le_n_S. rewrite app_length. rewrite plus_comm; auto.
  intros x Hx. apply H. rewrite Ha. right. apply in_or_app; auto. inversion H1. rewrite Ha in H8. clear -H8. induction n; simpl in H8; auto. apply IHn. inversion H8; auto. destruct n; inversion H2. simpl. clear IH. subst tr'. destruct (nat_eq_dec is p). contradict H5; auto. destruct (nat_eq_dec u p). contradict Hb; auto. apply RAor2. apply RAcons; auto. apply RFAsteps_app_s_rev with (s:=p) in He; auto. destruct He as [w3 [w2 [H7 [H8 H9]]]]. subst wa. apply RAcons; auto. destruct n. contradict n0; auto. clear -H8. simpl in H8. revert H8. revert w3. induction n; intros. simpl in H8. inversion H8. auto. simpl in H8. inversion H8. subst w3 s t l. apply IHn in H2; auto. inversion H9; auto. subst w2 s t l0. inversion H12. subst w4 s. simpl in H14. rewrite app_nil_r; auto. clear -n0. induction n. contradict n0; auto. destruct n; simpl. auto. simpl in IHn. apply Tail_cons; auto. clear -H5 Hb. simpl. destruct (nat_eq_dec p is). contradict H5; auto. f_equal. induction n. simpl. destruct (nat_eq_dec p u). contradict Hb; auto. auto. simpl. destruct (nat_eq_dec p p); auto. contradict n1; auto. clear -n. induction n; simpl; auto. rewrite <- app_assoc. simpl; auto. destruct n. inversion Ha. simpl in Ha. inversion Ha. subst t l. contradict H6. clear -H1. inversion H1. subst a b l. clear H1. induction n; simpl in H2. inversion H2. auto. inversion H1. apply IHn. inversion H2; auto. apply RFAacc_intro with (remove nat_eq_dec p l) i e; simpl; auto. apply H0 with i e; auto. apply RFAsteps_const with (is:=i) in H; auto. inversion H2. contradict H8; subst p; auto. inversion H2. inversion H9. contradict H12; subst p; auto. inversion H1. simpl. destruct (nat_eq_dec p i); auto. inversion H2. contradict H10; subst x p; auto. assert (e<>p). inversion H2. inversion H9. contradict H12; subst p; auto. clear -H5 H6. induction H5. simpl. destruct (nat_eq_dec p a); auto. contradict H6; auto. simpl. destruct (nat_eq_dec p b); auto. Defined.

Definition EFA2RegExp: forall e cset, (forall s c, In s (EFAstates e) -> EFAtrans e s c<>nil -> In c cset) -> {r| forall w, EFAacc e w <-> Racc r w}. intros. destruct (EFA2RFA e cset H) as [r H0]. destruct (RFA2single_edge r) as [is [es [st [r' H1 [H2 [H3 [H4 [H5 [H6 H7]]]]]]]]]. destruct (RFAsingle2RegExp (st:=st) (i:=is) (e:=es) r') as [ro H8]; auto. intros. exists ro. intros; split; intros. apply H8. apply H1. apply H0; auto. apply H0. apply H1. apply H8; auto. Defined.

Fixpoint repeatl {T:Type} n (l:list T) := match n with 0=>nil | S n'=>l++repeatl n' l end.
Lemma pumping: forall r, {n:nat | forall w, Racc r w -> n<=length w ->exists w1 w2 w3, w=w1++w2++w3 /\ w2<>nil /\ length w1+length w2<=n /\ forall i, Racc r (w1++repeatl i w2++w3)}. intros. destruct (RegExp2EFA r) as [e H]. destruct (EFA2NFA e) as [n H0]. exists (length (NFAstates n)). intros. apply H in H1. apply H0 in H1. inversion H1. assert (length l=S(length w)). apply NFAsteps_length in H5; auto. destruct (head_n_split (S (length (NFAstates n))) l) as [l1 [l2 H9 H10]]. subst l. apply le_n_S in H2. rewrite <- H8 in H2. apply H10 in H2. clear H10. assert (incl (l1++l2) (NFAstates n)). inversion H6. rewrite <- H11 in H5. apply NFAsteps_const in H5; auto. intros x Hx. destruct Hx. subst a x. apply NFAinit_const; auto. apply H5; auto. apply NFAinit_const; auto. assert (incl l1 (NFAstates n)). intros x Hx. apply H9. apply in_or_app; auto. destruct (pegeon_hole nat_eq_dec H10) as [s [l3 [l4 [l5 H11]]]]. rewrite H2; auto. subst l1. rewrite <- app_assoc in H5. simpl in H5. rewrite <- app_assoc in H5. simpl in H5. replace (l3++s::l4++s::l5++l2) with ((l3++s::nil)++l4++s::l5++l2) in H5. apply NFAsteps_app_s_rev with (s:=s) in H5. destruct H5 as [w1 [wa [Ha [Hb Hc]]]]. subst w. exists w1. replace (s::l4++s::l5++l2) with ((s::l4++s::nil)++(l5++l2)) in Hc. apply NFAsteps_app_s_rev with (s:=s) in Hc. destruct Hc as [w2 [w3 [Ha [Hd He]]]]. subst wa. exists w2. exists w3. split; auto. split. apply NFAsteps_length in Hd. simpl in Hd. rewrite app_length in Hd. rewrite plus_comm in Hd. simpl in Hd. inversion Hd. intros D. subst w2. simpl in Hd. inversion H11. split. apply NFAsteps_length in Hb. apply NFAsteps_length in Hd. rewrite app_length in Hb. simpl in Hd. rewrite app_length in Hd. simpl in Hb. simpl in Hd. rewrite plus_comm in Hb. rewrite plus_comm in Hd. inversion Hb. inversion Hd. rewrite app_length in H2. simpl in H2. rewrite app_length in H2. rewrite <- plus_n_Sm in H2. inversion H2. apply plus_le_compat_l. rewrite <- plus_n_Sm. apply le_n_S. apply le_plus_l.
  intros. apply H. apply H0. apply NFAacc_intro with is es ((l3++s::nil)++repeatl i (l4++s::nil)++l5++l2); auto. apply NFAsteps_app with (s:=s); auto. replace (s::repeatl i (l4++s::nil)++l5++l2) with ((s::repeatl i (l4++s::nil))++l5++l2). apply NFAsteps_app with (s:=s); auto. clear -Hd. induction i; simpl; auto. replace (s::(l4++s::nil)++repeatl i (l4++s::nil)) with ((s::l4++s::nil)++repeatl i (l4++s::nil)). apply NFAsteps_app with (s:=s); auto. simpl; auto. clear -i. induction i; simpl; auto. inversion IHi. rewrite app_nil_r. auto. auto. simpl; auto.  destruct l3. simpl in H6. inversion H6. subst s. simpl. auto. simpl in H6. inversion H6. subst n0. simpl; auto. clear -H7. destruct l2. rewrite app_nil_r in H7. rewrite app_nil_r. destruct l5. rewrite app_nil_r. apply Tail_app_rev in H7. inversion H7. destruct l4; inversion H2. apply Tail_app_rev in H1. inversion H1. subst a b s a0. induction i. simpl. rewrite app_nil_r. auto. simpl. destruct i. rewrite app_nil_r. auto. apply Tail_app_rev in IHi. auto. simpl. destruct l4; discriminate. inversion H5. discriminate. discriminate. apply Tail_app_rev in H7. inversion H7. destruct l4; inversion H2. apply Tail_app_rev in H1. inversion H1; auto. discriminate. discriminate. apply Tail_app_rev in H7; auto. discriminate. auto. simpl. f_equal. rewrite <- app_assoc. f_equal; auto. auto. rewrite <- app_assoc; auto. Defined.

End CharType.
