Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l le_n_S le_S_n.

Section CharType.

Variable C: Set.
Variable C_eq_dec: forall x y:C, {x=y}+{x<>y}.

Inductive RegExp: Set:=
| Rnil: RegExp
| Rchar: C -> RegExp
| Rcons: RegExp -> RegExp -> RegExp
| Ror: RegExp -> RegExp -> RegExp
| Rstar: RegExp -> RegExp
.

Inductive Racc: RegExp -> list C -> Prop:=
|RAchar : forall c, Racc (Rchar c) (c::nil)
|RAcons : forall l m r s, Racc r l -> Racc s m -> Racc (Rcons r s) (l++m)
|RAor1  : forall l r s, Racc r l -> Racc (Ror r s) l
|RAor2  : forall l r s, Racc s l -> Racc (Ror r s) l
|RAstar1: forall r, Racc (Rstar r) nil
|RAstar2: forall r l m, l<>nil -> Racc r l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m)
.
Hint Constructors Racc.

Definition Remp:=Rstar Rnil.
Theorem Remp_spec: forall w, Racc Remp w<-> w=nil. Proof. unfold Remp. intros; split; intros. inversion H; auto. inversion H2. subst w; auto. Qed.
Theorem Rnil_spec: forall w, ~Racc Rnil w. Proof. intros w D. inversion D. Qed.
Theorem Rchar_spec: forall w c, Racc (Rchar c) w <-> w=c::nil. Proof. intros; split; intros. inversion H; auto. subst w; auto. Qed.
Definition Rword w:=fold_right (fun c r=>Rcons (Rchar c) r) Remp w.
Theorem Rword_spec: forall w s, Racc (Rword w) s <-> s=w. Proof. induction w; intros; simpl; split; intros. apply Remp_spec; auto. apply Remp_spec; auto. inversion H. inversion H2. simpl. f_equal. apply IHw; auto. subst s. replace (a::w) with ((a::nil)++w); auto. apply RAcons; auto. apply IHw; auto. Qed.
Hint Resolve Remp_spec Rnil_spec Rchar_spec Rword_spec.

Definition Rincl: relation RegExp:= fun r s=>forall w, Racc r w -> Racc s w.
Definition Req: relation RegExp:= fun r s=> Rincl r s /\ Rincl s r.

Theorem Rstar_app: forall r l m, Racc (Rstar r) l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m). Proof. intros r l. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun l=>forall m, Racc (Rstar r) l->Racc (Rstar r) m ->Racc (Rstar r) (l++m)). clear l. intros l IH m H H0. inversion H; auto. rewrite <- app_assoc. apply RAstar2; auto. apply IH; auto. unfold ltof. subst l. rewrite app_length. destruct l0. contradict H2; auto. simpl; auto. Qed.
Theorem Rstar_one: forall r w, Racc r w -> Racc (Rstar r) w. Proof. intros. destruct w; auto. rewrite <- app_nil_r; apply RAstar2; auto. intros D; inversion D. Qed.
Theorem Rstar_incl: forall r s, Rincl r s -> Rincl (Rstar r) (Rstar s). Proof. intros. intros w. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar r) w ->Racc (Rstar s) w). clear w. intros w IH H0. inversion H0; auto. apply RAstar2; auto. apply IH; auto. unfold ltof. subst w. rewrite app_length. destruct l. contradict H2;auto. simpl; auto. Qed.
Hint Resolve Rstar_app Rstar_one Rstar_incl.

Definition Rshortest: forall r, {w| Racc r w & forall s, Racc r s -> length w <= length s}+{forall w, ~Racc r w}. induction r. right; auto. left; exists (c::nil); auto. intros. apply Rchar_spec in H. subst s; auto. destruct IHr1 as [[w H1 H2]|H1]; [destruct IHr2 as [[s H3 H4]|H3]; [left|right]|right]. exists (w++s); auto. intros. inversion H. subst r s1 s0. repeat rewrite app_length. apply le_trans with (length w+length m). apply plus_le_compat_l; auto. apply plus_le_compat_r; auto. intros t D. inversion D. contradict H6; auto. intros t D. inversion D. contradict H2; auto. destruct IHr1 as [[w H1 H2]|H1]; destruct IHr2 as [[s H3 H4]|H3]. left. destruct (le_lt_dec (length w) (length s)). exists w; auto. intros. inversion H; auto. apply le_trans with (length s); auto.
  exists s; auto. intros. inversion H; auto. apply le_trans with (length w); auto. left; exists w; auto. intros. inversion H; auto. contradict H6; auto. left; exists s; auto. intros. inversion H; auto. contradict H6; auto. right. intros w D. inversion D; contradict H4; auto. left; exists nil; auto. intros. simpl; apply le_O_n. Defined.
Definition Rlang': forall r, {l|forall w, Racc r w <-> In w l}+{forall n, exists w, n<=length w /\ Racc r w}. induction r. left. exists nil. intros; split; intros; inversion H. left; exists ((c::nil)::nil). intros; split; intros. left. inversion H; auto. destruct H. subst w; auto. destruct H. destruct IHr1 as [[l1 H1]|H1]; destruct IHr2 as [[l2 H2]|H2]. left. exists (all_pair (app (A:=C)) l1 l2). intros; split; intros. inversion H. apply all_pair_spec1; auto. apply H1; auto. apply H2; auto. apply all_pair_spec2 in H. destruct H as [x [y [H3 [H4 H5]]]]. subst w. apply RAcons. apply H1; auto. apply H2; auto. destruct l1 as [|a l1]. left; exists nil. intros; split; intros; inversion H. apply H1 in H4. inversion H4. right. intros. destruct (H2 n) as [w [H3 H4]]. exists (a++w). split; auto. rewrite app_length. apply le_trans with (m:=length w); auto. apply RAcons; auto. apply H1; auto.
  destruct l2 as [|a l2]. left. exists nil. intros; split; intros; inversion H. apply H2 in H6; inversion H6. right. intros. destruct (H1 n) as [w [H3 H4]]. exists (w++a). split. rewrite app_length. apply le_trans with (length w); auto. apply RAcons; auto. apply H2; auto. right. intros. destruct (H1 n) as [w1 [H3 H4]]. destruct (H2 n) as [w2 [H5 H6]]. exists (w1++w2). split. rewrite app_length. apply le_trans with (length w1); auto. auto.
  destruct IHr1 as [[l1 H1]|H1]; [destruct IHr2 as [[l2 H2]|H2]|]. left; exists (l1++l2). intros; split; intros. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H; [apply H1 in H|apply H2 in H]; auto. right. intros. destruct (H2 n) as [w [H3 H4]]. exists w; auto. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto. destruct IHr as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[x H2 H3]|H2]. destruct x. left. exists (nil::nil). intros; split; intros. inversion H; auto. apply H1 in H5. apply H3 in H5. destruct l0. contradict H4; auto. inversion H5. destruct H. subst w; auto. destruct H. right. intros. apply H1 in H2. clear -H2. induction n. exists (c::x). split; auto. apply le_O_n. destruct IHn as [w [H3 H4]]. exists ((c::x)++w). split; auto. simpl. apply le_n_S. rewrite app_length. apply le_trans with (length w); auto.
  subst l. left; exists (nil::nil). intros; split; intros. inversion H. left; auto. apply H1 in H3. inversion H3. destruct H. subst w; auto. destruct H. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto. Defined.
Definition Rlang: forall r, {l|forall w, Racc r w <-> In w l}+{forall l, exists w, Racc r w /\ ~In w l}. intros. destruct (Rlang' r) as [[l H1]|H1]; [left|right]. exists l; auto. intros. destruct (maxf (length (A:=C)) l) as [[x H3 H4]|H3]. destruct (H1 (S (length x))) as [w [H5 H6]]. exists w. split; auto. intros D. apply H4 in D. contradict H5. apply le_not_lt; auto. subst l. destruct (H1 0) as [w [H3 H4]]. exists w. split; auto. Defined.
Definition Rlongest: forall r, {w| Racc r w & forall s, Racc r s -> length s <= length w}+{forall n, exists s, Racc r s /\ n <= length s}+{forall w, ~Racc r w}. intros. destruct (Rlang' r) as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[w H2 H3]|H2]. left; left; exists w; auto. apply H1; auto. intros. apply H3. apply H1; auto. subst l. right. intros. intros D. apply H1 in D. destruct D. left; right. intros. destruct (H1 n) as [w [H2 H3]]. exists w; auto. Defined.
Definition sum_is_n: forall n, {pl|forall p, In p pl <-> fst p+snd p =n}. induction n. exists ((0,0)::nil). intros; split; intros. destruct H. subst p; auto. destruct H. destruct p. destruct n. destruct n0; auto. simpl in H. inversion H. simpl in H. inversion H. destruct IHn as [pl H]. exists ((0,S n)::map (fun p=>(S(fst p),snd p)) pl). intros. split; intros. destruct H0. subst p; auto. apply in_map_iff in H0. destruct H0 as [q [H1 H2]]. subst p. simpl. f_equal; apply H; auto. destruct p as [x y]. simpl in H0. destruct x. left; auto. right. inversion H0. apply in_map_iff. exists (x, y). split; simpl; auto. apply H. auto. Defined.
Definition Rlang_length: forall r n, {l|forall w, Racc r w/\length w=n <-> In w l}. intros. revert r. apply (Fix lt_wf) with (P:=fun n=>forall r,{l|forall w, Racc r w/\length w=n<->In w l}). clear n. intros n IH r. induction r. exists nil. intros; split; intros. destruct H; inversion H. inversion H. destruct (nat_eq_dec n 1). subst n. exists ((c::nil)::nil). intros; split; intros. destruct H. inversion H; auto. destruct H. subst w; auto. destruct H. exists nil. intros; split; intros. destruct H. contradict n0. inversion H. subst w n; auto. destruct H. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. remember (fun m=>match lt_dec m n with left _ H => match IH m H r1 with exist _ l _ => l end| right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m n with left _ H => match IH m H r2 with exist _ l _ => l end| right _ _ => l2 end) as f2. destruct (sum_is_n n) as [sl H3].
  exists (flat_map (fun p=>all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. inversion H. subst r s w. apply in_flat_map. exists (length l, length m). split. apply H3. subst n; rewrite app_length; auto. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length l) n). destruct (IH (length l) l0 r1). apply i; auto. apply H1. split; auto. destruct m. subst n; rewrite app_nil_r; auto. contradict n0; subst n. rewrite app_length. simpl. rewrite <- plus_n_Sm. auto. subst f2. destruct (lt_dec (length m) n). destruct (IH (length m) l0 r2). apply i; auto. apply H2. split; auto. destruct l; subst n; auto. contradict n0. simpl; rewrite app_length; auto. apply in_flat_map in H. destruct H as [[x y] [H5 H4]]. apply H3 in H5. simpl in H5. subst n. apply all_pair_spec2 in H4. simpl in H4. destruct H4 as [s [t [H6 [H7 H8]]]]. subst w. subst f1. destruct (lt_dec x (x+y)). destruct (IH x l r1). apply i in H6. destruct H6. subst x.
  subst f2. destruct (lt_dec y (length s+y)). destruct (IH y l0 r2). apply i0 in H7. destruct H7. subst y. split; auto. rewrite app_length; auto. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite <- H4. replace (length s) with 0; auto. destruct (length s); auto. contradict n. simpl. apply le_n_S. auto. assert (y=0). destruct y; auto. contradict n. rewrite <- plus_n_Sm; auto. subst y. apply H1 in H6. destruct H6. subst f2. destruct (lt_dec 0 (x+0)). destruct (IH 0 l r2). apply i in H7. destruct H7. destruct t. split; auto. rewrite app_nil_r. auto. inversion H5. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite H0. rewrite H5. replace x with 0; auto. destruct x; auto. contradict n0. simpl. apply le_n_S; auto. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. exists (l1++l2). intros; split; intros. destruct H. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H;[apply H1 in H|apply H2 in H]; destruct H; auto.
  destruct IHr as [l1 H1]. destruct (sum_is_n n) as [sl H2]. remember (fun m=>match lt_dec m n with left _ H  => match IH m H r with exist _ l _ => l end | right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m n with |left _ H => match IH m H (Rstar r) with exist _ l _ => l end | right _ _ => nil end) as f2. destruct n. exists (nil::nil). intros; split; intros. destruct H. inversion H; auto. subst w. destruct l. contradict H4; auto. inversion H0. destruct H. subst w; auto. destruct H. exists (flat_map (fun p=> all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. inversion H. subst w; inversion H0. subst w r0. rewrite app_length in H0. apply in_flat_map. exists (length l, length m). split. apply H2; auto. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length l) (S n)). destruct (IH (length l) l0 r). apply i; auto. apply H1. split; auto. destruct (length m). rewrite <- H0; auto. contradict n0. rewrite <- H0. rewrite <- plus_n_Sm. apply le_n_S; auto. subst f2. destruct (lt_dec (length m) (S n)). destruct (IH (length m) l0 (Rstar r)). apply i. auto. contradict n0. rewrite <- H0. destruct l; auto. contradict H4; auto. simpl. apply le_n_S; auto.
  apply in_flat_map in H. destruct H as [[x y] [H3 H4]]. apply H2 in H3. simpl in H3. simpl in H4. apply all_pair_spec2 in H4. destruct H4 as [s [t [H5 [H6 H7]]]]. subst w. subst f2. destruct (lt_dec y (S n)). destruct (IH y l (Rstar r)). apply i in H6. destruct H6. subst y. subst f1. destruct (lt_dec x (S n)). destruct (IH x l0 r). apply i0 in H5. destruct H5. subst x. split; auto. rewrite app_length; auto. apply H1 in H5. destruct H5. destruct t. split; auto. rewrite app_nil_r; auto. contradict n0. rewrite <- H3. simpl. rewrite <- plus_n_Sm. apply le_n_S; auto. destruct H6. Defined.

Definition Rlang_bound: forall r n, {l|forall w, Racc r w/\length w <=n <-> In w l}. intros. induction n. destruct (Rlang_length r 0) as [l H]. exists l. intros; split; intros. apply H. destruct H0. split; auto. destruct (length w); auto. inversion H1. apply H in H0. destruct H0. split; auto. rewrite <- H1; auto. destruct IHn as [l H1]. destruct (Rlang_length r (S n)) as [m H2]. exists (m++l). intros; split; intros. destruct H. apply in_or_app. inversion H0; [left|right]. apply H2; auto. apply H1; auto. apply in_app_or in H. destruct H. apply H2 in H. destruct H; split; auto. rewrite H0; auto. apply H1 in H. destruct H. split; auto. Defined.
Definition Racc_dec: forall r l, {Racc r l}+{~Racc r l}. intros r l. destruct (Rlang_length r (length l)) as [m H]. destruct (in_dec (list_eq_dec C_eq_dec) l m); [left|right]. apply H in i. destruct i; auto. contradict n. apply H; auto. Defined.

Theorem Rstar_dual: forall r, Req (Rstar r) (Rstar (Rstar r)). Proof. intros. split; intros w H. auto. revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc(Rstar(Rstar r)) w->Racc(Rstar r) w). clear w. intros w IH H. inversion H; auto. subst w r0. inversion H2. contradict H1; subst l; auto. rewrite <- app_assoc. apply RAstar2; auto. apply Rstar_app; auto. apply IH; auto. unfold ltof. rewrite app_length. destruct l. destruct l0. contradict H4; auto. inversion H7. simpl. auto. Qed.
Theorem Rstar_dual2: forall r, Req (Rstar r) (Rcons (Rstar r) (Rstar r)). Proof. intros; split; intros w H. rewrite <- app_nil_r; auto. inversion H. apply Rstar_app; auto. Qed.
Theorem Rstar_or: forall r s, Req (Rstar (Ror r s)) (Rstar (Rcons (Rstar r) (Rstar s))). Proof. intros. split; intros w H; revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Ror r s)) w -> Racc (Rstar (Rcons (Rstar r) (Rstar s))) w). clear w. intros w IH H. inversion H; auto. subst w r0. apply RAstar2; auto. inversion H2. rewrite <- app_nil_r. apply RAcons; auto. rewrite <- app_nil_l; auto. apply IH; auto. unfold ltof. rewrite app_length. destruct l. contradict H1; auto. simpl; auto.
  apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Rcons (Rstar r) (Rstar s))) w->Racc (Rstar (Ror r s)) w). clear w. intros w IH H. inversion H; auto. subst w r0. apply Rstar_app. inversion H2. subst r0 s0 l. apply Rstar_app. revert H5. apply Rstar_incl. intros w Hw. auto. revert H7. apply Rstar_incl. intros w Hw. auto. apply IH; auto. unfold ltof. destruct l. contradict H1; auto. rewrite app_length. simpl. auto. Qed.

(* Deterministic Finite Automata *)
Record DFA: Set := mkDFA {
  DFAstates: list nat; DFAtrans: C->nat->nat;
  DFAinit: nat; DFAaccept: list nat;
  DFAtrans_const: forall c s, In s DFAstates -> In (DFAtrans c s) DFAstates;
  DFAinit_const: In DFAinit DFAstates}.
Definition DFAacc (d:DFA) (w:list C) : Prop := In (fold_right (DFAtrans d) (DFAinit d) w) (DFAaccept d).
Definition DFAacc_dec: forall d w, {DFAacc d w}+{~DFAacc d w}. intros. destruct (in_dec nat_eq_dec (fold_right (DFAtrans d) (DFAinit d) w) (DFAaccept d)); [left|right]; auto. Defined.

(* Non-deterministic Finite Automata *)
Record NFA: Type := mkNFA {
  NFAstates: list nat;
  NFAtrans: C -> nat -> list nat;
  NFAinit: list nat; (* take a list for future extension *)
  NFAaccept: list nat;
  NFAtrans_const: forall c s, In s NFAstates -> incl (NFAtrans c s) NFAstates;
  NFAinit_const: forall s, In s NFAinit -> In s NFAstates
}.
Inductive NFAsteps (n:NFA) : list C -> relation nat:=
| NFAsteps_nil: forall s, NFAsteps n nil s s
| NFAsteps_cons: forall s t u w c, NFAsteps n w s u -> In t (NFAtrans n c u) -> NFAsteps n (c::w) s t
.
Inductive NFAacc (n:NFA) (w:list C) : Prop := NFAacc_intro: forall is es, In es (NFAaccept n) ->In is (NFAinit n) -> NFAsteps n w is es -> NFAacc n w.
Hint Constructors NFAsteps NFAacc.

Definition NFAsteps_states: forall n w sl, {tl| forall t, In t tl <-> exists s, In s sl /\ NFAsteps n w s t}. induction w; intros. exists sl. intros; split; intros. exists t; auto. destruct H as [s [H1 H2]]. inversion H2. subst t; auto. destruct (IHw sl) as [tl H]. exists (flat_map (NFAtrans n a) tl). intros; split; intros. apply in_flat_map in H0. destruct H0 as [x [H1 H2]]. apply H in H1. destruct H1 as [s [H3 H4]]. exists s; split; auto. apply NFAsteps_cons with x; auto.
  destruct H0 as [s [H1 H2]]. inversion H2. subst c w0 s0 t0. apply in_flat_map. exists u; split; auto. apply H. exists s; auto. Defined.
Definition NFAacc_dec: forall n w, {NFAacc n w}+{~NFAacc n w}. intros. destruct (NFAsteps_states n w (NFAinit n)) as [sl H]. destruct findP with (l:=NFAaccept n) (P:=fun s=>In s sl). intros; apply in_dec; apply nat_eq_dec. destruct s as [s H1 H2]. left. apply H in H2. destruct H2 as [is [H3 H4]]. apply NFAacc_intro with is s; auto. right. intros D. inversion D. apply n0 in H0. contradict H0. apply H. exists is; auto. Defined.

(* Non-deterministic Finite Automata with Empty *)
Record EFA: Set := mkEFA {
  EFAstates: list nat; EFAtrans: C->nat->list nat; EFAempty: nat->list nat;
  EFAinit: list nat; (* take a list for future extension *)
  EFAaccept: list nat;
  EFAtrans_const: forall c s, In s EFAstates -> incl (EFAtrans c s) EFAstates;
  EFAempty_const: forall s, In s EFAstates -> incl (EFAempty s) EFAstates;
  EFAinit_const: forall s, In s EFAinit -> In s EFAstates
}.
Inductive EFAsteps (n:EFA) : list C -> relation nat:=
| EFAsteps_nil: forall s, EFAsteps n nil s s
| EFAsteps_empty: forall s t u w, EFAsteps n w s t -> In u (EFAempty n t) -> EFAsteps n w s u
| EFAsteps_cons: forall s t u w c, EFAsteps n w s t -> In u (EFAtrans n c t) -> EFAsteps n (c::w) s u
.
Inductive EFAacc (n:EFA) (w:list C) : Prop := EFAacc_intro: forall is es, In es (EFAaccept n) -> In is (EFAinit n) -> EFAsteps n w is es -> EFAacc n w.
Hint Constructors EFAsteps EFAacc clos_refl_trans.

Theorem EFAsteps_const: forall n w s t, In s (EFAstates n) -> EFAsteps n w s t -> In t (EFAstates n). Proof. intros. induction H0; auto. apply (EFAempty_const n) in H1; auto. apply (EFAtrans_const n) in H1; auto. Qed.
Theorem EFAsteps_cons_rev: forall n w a s t, EFAsteps n (a::w) s t -> exists u v, clos_refl_trans nat (fun s t=>In t (EFAempty n s)) v t /\ In v (EFAtrans n a u) /\ EFAsteps n w s u. Proof. intros. remember (a::w) as aw. revert Heqaw. induction H; intros. inversion Heqaw. apply IHEFAsteps in Heqaw. destruct Heqaw as [q [v [H1 [H2 H3]]]]. exists q. exists v. split; auto. apply rt_trans with t; auto. inversion Heqaw. subst c w0. exists t. exists u; auto. Qed.
Theorem EFAsteps_empties: forall n w s t u, EFAsteps n w s t -> clos_refl_trans nat (fun s t=>In t (EFAempty n s)) t u -> EFAsteps n w s u. Proof. intros. induction H0; auto. apply EFAsteps_empty with x; auto. Qed.

Theorem remove_In2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a x, In x (remove T_eq_dec a l) <-> x<>a /\ In x l. Proof. induction l; simpl; split; intros. destruct H. destruct H; auto. destruct (T_eq_dec a0 a). subst a0. apply IHl in H. destruct H. split; auto. destruct H. subst x. split; auto. apply IHl in H. destruct H; auto. destruct H. destruct (T_eq_dec a0 a). apply IHl. destruct H0; auto. subst a0 a. contradict H; auto. destruct H0; auto. left; auto. right. apply IHl; auto. Qed.
Theorem remove_length2:forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a, In a l -> length (remove T_eq_dec a l) < length l. Proof. induction l; simpl; intros. destruct H. destruct (T_eq_dec a0 a). apply le_n_S. apply remove_length. simpl. apply le_n_S. apply IHl. destruct H; auto. contradict n; auto. Qed.
Definition removeAll {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T):= fold_right (remove T_eq_dec) m l.
Theorem removeAll_In: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, ~In x l /\ In x m <-> In x (removeAll T_eq_dec l m). Proof. induction l; intros; simpl; split; intros. destruct H; auto. split; auto. destruct H. destruct (T_eq_dec x a). subst x; contradict H; auto. apply remove_In2. split; auto. apply IHl with (m:=m) (x:=x). split; auto. apply remove_In2 in H. destruct H. apply IHl in H0. destruct H0. split; auto. contradict H0. destruct H0; auto. contradict H; auto. Qed.
Theorem removeAll_app: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l1 l2 m:list T), removeAll T_eq_dec (l1++l2) m = removeAll T_eq_dec l1 (removeAll T_eq_dec l2 m). Proof. induction l1; simpl; intros; auto. f_equal; auto. Qed.
Theorem removeAll_length: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), length (removeAll T_eq_dec l m) <= length m. Proof. induction l; simpl; intros; auto. eapply le_trans. apply remove_length. apply IHl; auto. Qed.
Theorem removeAll_length2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, In x l -> In x m -> length (removeAll T_eq_dec l m) < length m. Proof. induction l; intros. destruct H. simpl. destruct H. subst x. destruct (in_dec T_eq_dec a l). apply le_lt_trans with (length (removeAll T_eq_dec l m)); auto. apply remove_length. apply IHl with a; auto. apply lt_le_trans with (length (removeAll T_eq_dec l m)). apply remove_length2; auto. apply removeAll_In; auto. apply removeAll_length. eapply le_lt_trans. eapply remove_length. eapply IHl; eauto. Qed.
Definition incl_dec: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), {x|In x l & ~In x m}+{incl l m}. induction l; intros. right. intros x H; inversion H. destruct (in_dec T_eq_dec a m). destruct (IHl m); [left|right]. destruct s. exists x; auto. intros x H. destruct H; auto. subst x; auto. left; exists a; auto. Defined.

Definition EFA_empty_states: forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}. intros n sl. apply (Fix (well_founded_ltof (list nat) (fun l=>length (removeAll nat_eq_dec l (EFAstates n))))) with (P:=fun sl=>incl sl (EFAstates n)->{tl|forall t,In t tl<->exists s,In s sl/\clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}). clear sl. intros sl IH H.
  destruct (incl_dec nat_eq_dec (flat_map (EFAempty n) sl) sl) as [[x H0 H1]|H0]. destruct (IH (flat_map (EFAempty n) sl++sl)) as [tl H2]. unfold ltof. rewrite removeAll_app. apply removeAll_length2 with x; auto. apply removeAll_In. split; auto. apply in_flat_map in H0. destruct H0 as [y [H2 H3]]. apply (EFAempty_const n) in H3; auto.
  intros y Hy. apply in_app_or in Hy. destruct Hy; auto. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. apply (EFAempty_const n) in H4; auto. exists tl. intros t; split; intros. apply H2 in H3. destruct H3 as [s [H4 H5]]. apply in_app_or in H4. destruct H4. apply in_flat_map in H3. destruct H3 as [u [H6 H7]]. exists u. split; auto. apply rt_trans with s; auto. exists s; auto. apply H2. destruct H3 as [s [H4 H5]]. exists s. split; auto. apply in_or_app; auto.
  exists sl. intros; split; intros. exists t; auto. destruct H1 as [s [H2 H3]]. clear -H0 H2 H3. induction H3; auto. apply H0. apply in_flat_map. exists x; auto. Defined.
Definition EFAsteps_states: forall n w sl, incl sl (EFAstates n) -> {tl|forall t, In t tl <-> exists s, In s sl /\ EFAsteps n w s t}. induction w; intros. destruct (EFA_empty_states n H) as [tl H0]. exists tl. intros; split; intros. apply H0 in H1. destruct H1 as [s [H2 H3]]. exists s; split; auto. clear -H3. induction H3; auto. apply EFAsteps_empty with x; auto. clear H3_ H3_0. revert IHclos_refl_trans1. remember nil as w in IHclos_refl_trans2. revert Heqw. induction IHclos_refl_trans2; intros; auto. apply EFAsteps_empty with t; auto. inversion Heqw. apply H0. destruct H1 as [s [H2 H3]]. exists s. split; auto. clear -H3. remember nil as w. revert Heqw. induction H3; intros; auto. apply rt_trans with t; auto. inversion Heqw.
  destruct (IHw sl H) as [tl H0]. assert (incl (flat_map (EFAtrans n a) tl) (EFAstates n)). intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H1 H2]]. apply (EFAtrans_const n a y); auto. apply H0 in H1. destruct H1 as [s [H3 H4]]. apply EFAsteps_const with w s; auto.  destruct (EFA_empty_states n H1) as [ul H2]. exists ul. intros; split; intros. apply H2 in H3. destruct H3 as [u [H4 H5]]. apply in_flat_map in H4. destruct H4 as [v [H7 H6]]. apply H0 in H7. destruct H7 as [x [H8 H9]]. exists x; split; auto. apply EFAsteps_empties with u; auto. apply EFAsteps_cons with v; auto.
  destruct H3 as [s [H4 H5]]. apply H2. remember (a::w) as aw. revert Heqaw. induction H5; intros; auto. inversion Heqaw. destruct IHEFAsteps as [v [H6 H7]]; auto. exists v; split; auto. apply rt_trans with t; auto. inversion Heqaw. subst c w0. exists u. split; auto. apply in_flat_map. exists t; split; auto. apply H0. exists s; auto. Defined.
Definition EFAacc_dec: forall n w, {EFAacc n w}+{~EFAacc n w}. intros. destruct (EFAsteps_states n w) with  (sl:=EFAinit n) as [tl H]. intros x H. apply (EFAinit_const n) in H; auto. destruct findP with (P:=fun s=>In s tl) (l:=EFAaccept n). intros. apply in_dec. apply nat_eq_dec. destruct s as [s H1 H2]. left. apply H in H2. destruct H2 as [is [H3 H4]]. apply EFAacc_intro with is s; auto. right. intros D. inversion D. apply n0 in H0. contradict H0. apply H. exists is; auto. Defined.

Definition EFA2NFA: forall e, {n| forall w, EFAacc e w <-> NFAacc n w}. intros. destruct (EFA_empty_states e (EFAinit_const e)) as [is H]. assert (Hi: incl is (EFAstates e)). intros x Hx. apply H in Hx. destruct Hx as [s [H1 H2]]. apply (EFAinit_const e) in H1. revert H1. clear -H2. induction H2; intros; auto. apply (EFAempty_const e) in H; auto. remember (fun c s=>match in_dec nat_eq_dec s (EFAstates e) with |left H => match EFA_empty_states e (EFAtrans_const e c s H) with exist _ sl _ => sl end |right _ => nil end) as tr. assert (Ht: forall c s, In s (EFAstates e) -> incl (tr c s) (EFAstates e)). intros. subst tr. destruct (in_dec nat_eq_dec s (EFAstates e)); [|contradiction]. destruct (EFA_empty_states e (EFAtrans_const e c s i)) as [tl H1]. intros x Hx. apply H1 in Hx.  destruct Hx as [t [H2 H3]]. assert (In t (EFAstates e)). apply (EFAtrans_const e c s); auto. revert H4. clear -H3. induction H3; intros; auto. apply (EFAempty_const e) in H; auto.
  exists (mkNFA (NFAstates:=EFAstates e) tr is (EFAaccept e) Ht Hi). cut (forall w t, (exists s, In s (EFAinit e) /\ EFAsteps e w s t) <-> exists s, In s is /\ NFAsteps (mkNFA (NFAstates:=EFAstates e) tr is (EFAaccept e) Ht Hi) w s t). intros; split; intros. inversion H1. assert (exists s, In s (EFAinit e) /\ EFAsteps e w s es). exists is0; auto. apply (H0 w es) in H5. destruct H5 as [s [H6 H7]]. apply NFAacc_intro with s es; auto. inversion H1; simpl. assert (exists s, In s is/\ NFAsteps (mkNFA tr is (EFAaccept e) Ht Hi) w s es). exists is0; auto. apply H0 in H5. destruct H5 as [s [H6 H7]]. apply EFAacc_intro with s es; auto.
  induction w; simpl; intros; split; intros. destruct H0 as [s [H1 H2]]. remember nil as w in H2. revert Heqw. induction H2; intros. exists s. split. apply H. exists s; auto. auto. exists u; split; auto. apply H. subst w. exists s; split; auto. apply rt_trans with t; auto. clear -H2. remember nil as w. revert Heqw. induction H2; intros; auto. apply rt_trans with t; auto. inversion Heqw. inversion Heqw. destruct H0 as [s [H1 H2]]. inversion H2. subst s0 t. apply H in H1. destruct H1 as [u [H3 H4]]. exists u; split; auto. clear -H4. induction H4; auto. apply EFAsteps_empty with x; auto. revert IHclos_refl_trans1. remember nil as w in IHclos_refl_trans2. revert Heqw. clear H4_ H4_0. induction IHclos_refl_trans2; intros; auto. apply EFAsteps_empty with t; auto. inversion Heqw.
  destruct H0 as [s [H1 H2]]. destruct (EFAsteps_cons_rev H2) as [u [v [H3 [H4 H5]]]]. assert (exists s, In s (EFAinit e) /\EFAsteps e w s u). exists s; auto. apply IHw in H0. destruct H0 as [q [H6 H7]]. exists q; split; auto. apply NFAsteps_cons with u; simpl; auto. subst tr. destruct (in_dec nat_eq_dec u (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e a u i)) as [tl H8]. apply H8. exists v; split; auto. contradict n. apply EFAsteps_const with w s; auto. apply (EFAinit_const e) in H1; auto.
  destruct H0 as [s [H1 H2]]. inversion H2. subst c w0 s0 t0. simpl in H7. clear H2. assert (exists s, In s is/\NFAsteps (mkNFA tr is (EFAaccept e) Ht Hi) w s u). exists s; auto. apply IHw in H0. clear IHw H4. destruct H0 as [v [H3 H2]]. exists v; split; auto. subst tr. destruct (in_dec nat_eq_dec u (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e a u i)) as [ul H4]. apply H4 in H7. destruct H7 as [q [H8 H9]]. apply EFAsteps_empties with q; auto. apply EFAsteps_cons with u; auto. contradict n. apply EFAsteps_const with w v; auto. apply (EFAinit_const e) in H3; auto. Defined.

Definition NFA2EFA: forall n, {e|forall w, EFAacc e w <-> NFAacc n w}. intros. assert (H: forall s, In s (NFAstates n) -> incl ((fun _=>nil) s) (NFAstates n)). intros. intros x Hx; inversion Hx. exists (mkEFA (NFAtrans n) (fun _ => nil) (NFAinit n) (NFAaccept n) (NFAtrans_const n) H (NFAinit_const n)). intros; split; intros. inversion H0. apply NFAacc_intro with is es; auto. clear -H3. induction H3; auto. simpl in H0. inversion H0. apply NFAsteps_cons with t; auto. inversion H0. apply EFAacc_intro with is es; auto. clear -H3. induction H3; auto. apply EFAsteps_cons with u; auto. Defined.

Definition DFA2NFA: forall d, {n|forall w, DFAacc d w <-> NFAacc n w}. intros. assert (Ht: forall c s, In s (DFAstates d)->incl (DFAtrans d c s::nil) (DFAstates d)). intros. intros x Hx. destruct Hx. subst x. apply DFAtrans_const; auto. destruct H0. assert (Hi: incl (DFAinit d::nil) (DFAstates d)). intros x Hx. destruct Hx. subst x. apply DFAinit_const; auto. destruct H. exists (mkNFA (fun c s=>DFAtrans d c s::nil) (DFAinit d::nil) (DFAaccept d) Ht Hi). unfold DFAacc. cut (forall w s, s=fold_right (DFAtrans d) (DFAinit d) w <-> NFAsteps (mkNFA (fun c s=>DFAtrans d c s::nil) (DFAinit d::nil) (DFAaccept d) Ht Hi) w (DFAinit d) s). intros. split; intros. apply NFAacc_intro with (DFAinit d) (fold_right (DFAtrans d) (DFAinit d) w); auto. left; auto. apply H; auto. inversion H0. simpl in H1. simpl in H2. destruct H2. subst is. apply H in H3. subst es; auto. destruct H2.
  induction w; simpl; split; intros. subst s; auto. inversion H; auto. apply NFAsteps_cons with (fold_right (DFAtrans d) (DFAinit d) w); auto. apply IHw; auto. simpl. subst s; auto. inversion H. simpl in H5. subst c w0 s0 t. destruct H5. subst s. f_equal. apply IHw; auto. destruct H0. Defined.


End CharType.
