Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l le_n_S le_S_n.

Section CharType.

Variable C: Set.
Variable C_eq_dec: forall x y:C, {x=y}+{x<>y}.

Inductive RegExp: Set:=
| Rnil: RegExp
| Rchar: C -> RegExp
| Rcons: RegExp -> RegExp -> RegExp
| Ror: RegExp -> RegExp -> RegExp
| Rstar: RegExp -> RegExp
.

Inductive Racc: RegExp -> list C -> Prop:=
|RAchar : forall c, Racc (Rchar c) (c::nil)
|RAcons : forall l m r s, Racc r l -> Racc s m -> Racc (Rcons r s) (l++m)
|RAor1  : forall l r s, Racc r l -> Racc (Ror r s) l
|RAor2  : forall l r s, Racc s l -> Racc (Ror r s) l
|RAstar1: forall r, Racc (Rstar r) nil
|RAstar2: forall r l m, Racc r l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m)
.
Hint Constructors Racc.

Definition Remp:=Rstar Rnil.
Theorem Remp_spec: forall w, Racc Remp w<-> w=nil. Proof. unfold Remp. intros; split; intros; [|subst w]; auto. inversion H; auto. inversion H1. Qed.
Theorem Rnil_spec: forall w, ~Racc Rnil w. Proof. intros w D. inversion D. Qed.
Theorem Rchar_spec: forall w c, Racc (Rchar c) w <-> w=c::nil. Proof. intros; split; intros. inversion H; auto. subst w; auto. Qed.
Definition Rword w:=fold_right (fun c r=>Rcons (Rchar c) r) Remp w.
Theorem Rword_spec: forall w s, Racc (Rword w) s <-> s=w. Proof. induction w; intros; simpl; split; intros. apply Remp_spec; auto. apply Remp_spec; auto. inversion H. inversion H2. simpl. f_equal. apply IHw; auto. subst s. replace (a::w) with ((a::nil)++w); auto. apply RAcons; auto. apply IHw; auto. Qed.
Hint Resolve Remp_spec Rnil_spec Rchar_spec Rword_spec.

Definition Rincl: relation RegExp:= fun r s=>forall w, Racc r w -> Racc s w.
Definition Req: relation RegExp:= fun r s=> Rincl r s /\ Rincl s r.

Theorem Rstar_app: forall r l m, Racc (Rstar r) l -> Racc (Rstar r) m -> Racc (Rstar r) (l++m). Proof. intros r l m H H0. revert H0. revert m. remember (Rstar r) as r1. revert Heqr1. induction H; intros; try discriminate Heqr1; simpl; auto. rewrite <- app_assoc. apply RAstar2; auto. Qed.
Theorem Rstar_one: forall r w, Racc r w -> Racc (Rstar r) w. Proof. intros. destruct w; auto. rewrite <- app_nil_r; apply RAstar2; auto. Qed.
Theorem Rstar_incl: forall r s, Rincl r s -> Rincl (Rstar r) (Rstar s). Proof. intros. intros w H0. remember (Rstar r) as r1. revert Heqr1. induction H0; intros; try discriminate Heqr1; auto. inversion Heqr1. subst r0. auto. Qed.
Theorem Rstar_rev': forall r w, Racc (Rstar r) w -> w<>nil -> exists l m, Racc r l /\ Racc (Rstar r) m /\ l<>nil /\ w=l++m. intros r w H. remember (Rstar r) as s. revert Heqs. revert r.  induction H; intros; try discriminate Heqs. contradict H; auto. inversion Heqs. subst r0. clear IHRacc1. destruct (list_eq_dec C_eq_dec m nil). subst m. exists l. exists nil. rewrite app_nil_r in H1. auto. destruct IHRacc2 with (r0:=r) as [l' [m' [H2 [H3 [H4 H5]]]]]; auto. subst m. destruct (list_eq_dec C_eq_dec l nil). subst l. exists l'. exists m'; auto. exists l. exists (l'++m'); auto. Qed.
Hint Resolve Rstar_app Rstar_one Rstar_incl Rstar_rev'.

Definition Rshortest: forall r, {w| Racc r w & forall s, Racc r s -> length w <= length s}+{forall w, ~Racc r w}. induction r. right; auto. left; exists (c::nil); auto. intros. apply Rchar_spec in H. subst s; auto. destruct IHr1 as [[w H1 H2]|H1]; [destruct IHr2 as [[s H3 H4]|H3]; [left|right]|right]. exists (w++s); auto. intros. inversion H. subst r s1 s0. repeat rewrite app_length. apply le_trans with (length w+length m). apply plus_le_compat_l; auto. apply plus_le_compat_r; auto. intros t D. inversion D. contradict H6; auto. intros t D. inversion D. contradict H2; auto. destruct IHr1 as [[w H1 H2]|H1]; destruct IHr2 as [[s H3 H4]|H3]. left. destruct (le_lt_dec (length w) (length s)). exists w; auto. intros. inversion H; auto. apply le_trans with (length s); auto.
  exists s; auto. intros. inversion H; auto. apply le_trans with (length w); auto. left; exists w; auto. intros. inversion H; auto. contradict H6; auto. left; exists s; auto. intros. inversion H; auto. contradict H6; auto. right. intros w D. inversion D; contradict H4; auto. left; exists nil; auto. intros. simpl; apply le_O_n. Defined.
Definition Rlang': forall r, {l|forall w, Racc r w <-> In w l}+{forall n, exists w, n<=length w /\ Racc r w}. induction r. left. exists nil. intros; split; intros; inversion H. left; exists ((c::nil)::nil). intros; split; intros. left. inversion H; auto. destruct H. subst w; auto. destruct H. destruct IHr1 as [[l1 H1]|H1]; destruct IHr2 as [[l2 H2]|H2]. left. exists (all_pair (app (A:=C)) l1 l2). intros; split; intros. inversion H. apply all_pair_spec1; auto. apply H1; auto. apply H2; auto. apply all_pair_spec2 in H. destruct H as [x [y [H3 [H4 H5]]]]. subst w. apply RAcons. apply H1; auto. apply H2; auto. destruct l1 as [|a l1]. left; exists nil. intros; split; intros; inversion H. apply H1 in H4. inversion H4. right. intros. destruct (H2 n) as [w [H3 H4]]. exists (a++w). split; auto. rewrite app_length. apply le_trans with (m:=length w); auto. apply RAcons; auto. apply H1; auto.
  destruct l2 as [|a l2]. left. exists nil. intros; split; intros; inversion H. apply H2 in H6; inversion H6. right. intros. destruct (H1 n) as [w [H3 H4]]. exists (w++a). split. rewrite app_length. apply le_trans with (length w); auto. apply RAcons; auto. apply H2; auto. right. intros. destruct (H1 n) as [w1 [H3 H4]]. destruct (H2 n) as [w2 [H5 H6]]. exists (w1++w2). split. rewrite app_length. apply le_trans with (length w1); auto. auto. destruct IHr1 as [[l1 H1]|H1]; [destruct IHr2 as [[l2 H2]|H2]|]. left; exists (l1++l2). intros; split; intros. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H; [apply H1 in H|apply H2 in H]; auto. right. intros. destruct (H2 n) as [w [H3 H4]]. exists w; auto. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto.
  destruct IHr as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[x H2 H3]|H2]. destruct x. left. exists (nil::nil). intros; split; intros. cut (w=nil). intros; subst w; auto. remember (Rstar r) as r1. revert Heqr1. induction H; intros; try discriminate Heqr1; auto. inversion Heqr1; subst r0. apply H1 in H. apply H3 in H. destruct l0. auto. inversion H. destruct H. subst w; auto. destruct H. right. intros. apply H1 in H2. clear -H2. induction n. exists (c::x). split; auto. apply le_O_n. destruct IHn as [w [H3 H4]]. exists ((c::x)++w). split; auto. simpl. apply le_n_S. rewrite app_length. apply le_trans with (length w); auto. subst l. left; exists (nil::nil). intros; split; intros. inversion H. left; auto. apply H1 in H2. inversion H2. destruct H. subst w; auto. destruct H. right. intros. destruct (H1 n) as [w [H3 H4]]. exists w; auto. Defined.
Definition Rlang: forall r, {l|forall w, Racc r w <-> In w l}+{forall l, exists w, Racc r w /\ ~In w l}. intros. destruct (Rlang' r) as [[l H1]|H1]; [left|right]. exists l; auto. intros. destruct (maxf (length (A:=C)) l) as [[x H3 H4]|H3]. destruct (H1 (S (length x))) as [w [H5 H6]]. exists w. split; auto. intros D. apply H4 in D. contradict H5. apply le_not_lt; auto. subst l. destruct (H1 0) as [w [H3 H4]]. exists w. split; auto. Defined.
Definition Rlongest: forall r, {w| Racc r w & forall s, Racc r s -> length s <= length w}+{forall n, exists s, Racc r s /\ n <= length s}+{forall w, ~Racc r w}. intros. destruct (Rlang' r) as [[l H1]|H1]. destruct (maxf (length (A:=C)) l) as [[w H2 H3]|H2]. left; left; exists w; auto. apply H1; auto. intros. apply H3. apply H1; auto. subst l. right. intros. intros D. apply H1 in D. destruct D. left; right. intros. destruct (H1 n) as [w [H2 H3]]. exists w; auto. Defined.
Definition sum_is_n: forall n, {pl|forall p, In p pl <-> fst p+snd p =n}. induction n. exists ((0,0)::nil). intros; split; intros. destruct H. subst p; auto. destruct H. destruct p. destruct n. destruct n0; auto. simpl in H. inversion H. simpl in H. inversion H. destruct IHn as [pl H]. exists ((0,S n)::map (fun p=>(S(fst p),snd p)) pl). intros. split; intros. destruct H0. subst p; auto. apply in_map_iff in H0. destruct H0 as [q [H1 H2]]. subst p. simpl. f_equal; apply H; auto. destruct p as [x y]. simpl in H0. destruct x. left; auto. right. inversion H0. apply in_map_iff. exists (x, y). split; simpl; auto. apply H. auto. Defined.
Definition Rlang_length: forall r n, {l|forall w, Racc r w/\length w=n <-> In w l}. intros. revert r. apply (Fix lt_wf) with (P:=fun n=>forall r,{l|forall w, Racc r w/\length w=n<->In w l}). clear n. intros n IH r. induction r. exists nil. intros; split; intros. destruct H; inversion H. inversion H. destruct (nat_eq_dec n 1). subst n. exists ((c::nil)::nil). intros; split; intros. destruct H. inversion H; auto. destruct H. subst w; auto. destruct H. exists nil. intros; split; intros. destruct H. contradict n0. inversion H. subst w n; auto. destruct H. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. remember (fun m=>match lt_dec m n with left _ H => match IH m H r1 with exist _ l _ => l end| right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m n with left _ H => match IH m H r2 with exist _ l _ => l end| right _ _ => l2 end) as f2. destruct (sum_is_n n) as [sl H3].
  exists (flat_map (fun p=>all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. inversion H. subst r s w. apply in_flat_map. exists (length l, length m). split. apply H3. subst n; rewrite app_length; auto. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length l) n). destruct (IH (length l) l0 r1). apply i; auto. apply H1. split; auto. destruct m. subst n; rewrite app_nil_r; auto. contradict n0; subst n. rewrite app_length. simpl. rewrite <- plus_n_Sm. auto. subst f2. destruct (lt_dec (length m) n). destruct (IH (length m) l0 r2). apply i; auto. apply H2. split; auto. destruct l; subst n; auto. contradict n0. simpl; rewrite app_length; auto. apply in_flat_map in H. destruct H as [[x y] [H5 H4]]. apply H3 in H5. simpl in H5. subst n. apply all_pair_spec2 in H4. simpl in H4. destruct H4 as [s [t [H6 [H7 H8]]]]. subst w. subst f1. destruct (lt_dec x (x+y)). destruct (IH x l r1). apply i in H6. destruct H6. subst x.
  subst f2. destruct (lt_dec y (length s+y)). destruct (IH y l0 r2). apply i0 in H7. destruct H7. subst y. split; auto. rewrite app_length; auto. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite <- H4. replace (length s) with 0; auto. destruct (length s); auto. contradict n. simpl. apply le_n_S. auto. assert (y=0). destruct y; auto. contradict n. rewrite <- plus_n_Sm; auto. subst y. apply H1 in H6. destruct H6. subst f2. destruct (lt_dec 0 (x+0)). destruct (IH 0 l r2). apply i in H7. destruct H7. destruct t. split; auto. rewrite app_nil_r. auto. inversion H5. apply H2 in H7. destruct H7. split; auto. rewrite app_length. rewrite H0. rewrite H5. replace x with 0; auto. destruct x; auto. contradict n0. simpl. apply le_n_S; auto. destruct IHr1 as [l1 H1]. destruct IHr2 as [l2 H2]. exists (l1++l2). intros; split; intros. destruct H. apply in_or_app. inversion H; [left; apply H1|right; apply H2]; auto. apply in_app_or in H. destruct H;[apply H1 in H|apply H2 in H]; destruct H; auto.
  destruct n. exists (nil::nil). intros; split; intros. destruct H. destruct w; auto. inversion H0. destruct H. subst w; auto. destruct H. destruct IHr as [l1 H1]. destruct (sum_is_n (S n)) as [sl H2]. remember (fun m=>match lt_dec m (S n) with left _ H  => match IH m H r with exist _ l _ => l end | right _ _ => l1 end) as f1. remember (fun m=>match lt_dec m (S n) with |left _ H => match IH m H (Rstar r) with exist _ l _ => l end | right _ _ => nil end) as f2. exists (flat_map (fun p=> all_pair (app (A:=C)) (f1 (fst p)) (f2 (snd p))) sl). intros; split; intros. destruct H. destruct (Rstar_rev' H) as [w1 [w2 [H3 [H4 [H5 H6]]]]]; auto. destruct w. inversion H0. discriminate. subst w. apply in_flat_map. exists (length w1, length w2). split. apply H2. rewrite <- H0. rewrite app_length; auto.  simpl. apply all_pair_spec1; simpl. subst f1. destruct (lt_dec (length w1) (S n)). destruct (IH (length w1) l r). apply i; auto. apply H1. split; auto. destruct w2. rewrite <- H0. rewrite app_nil_r; auto. contradict n0. rewrite <- H0. rewrite app_length. simpl. rewrite <- plus_n_Sm. apply le_n_S; apply le_plus_l; auto.
  subst f2. destruct (lt_dec (length w2) (S n)). destruct (IH (length w2) l (Rstar r)); auto. apply i; auto. contradict n0. rewrite <- H0. rewrite app_length. destruct w1. contradict H5; auto. simpl. apply le_n_S; apply le_plus_r. apply in_flat_map in H. destruct H as [[x y] [H3 H4]]. apply H2 in H3. simpl in H3. apply all_pair_spec2 in H4. destruct H4 as [w1 [w2 [H5 [H6 H7]]]]. subst w. subst f1. simpl in H5. destruct (lt_dec x (S n)). destruct (IH x l r). apply i in H5. destruct H5. subst f2. simpl in H6. destruct (lt_dec y (S n)). destruct (IH y l0 (Rstar r)). apply i0 in H6. destruct H6. split. auto. rewrite app_length. subst x y; auto. destruct H6. subst f2. simpl in H6. destruct (lt_dec y (S n)). destruct (IH y l). apply i in H6. destruct H6. apply H1 in H5. destruct H5. destruct y.  destruct w2. rewrite app_nil_r. auto. inversion H0. contradict n0. rewrite <- H3. rewrite <- plus_n_Sm. apply le_n_S; apply le_plus_l. destruct H6. Defined.
Definition Rlang_bound: forall r n, {l|forall w, Racc r w/\length w <=n <-> In w l}. intros. induction n. destruct (Rlang_length r 0) as [l H]. exists l. intros; split; intros. apply H. destruct H0. split; auto. destruct (length w); auto. inversion H1. apply H in H0. destruct H0. split; auto. rewrite <- H1; auto. destruct IHn as [l H1]. destruct (Rlang_length r (S n)) as [m H2]. exists (m++l). intros; split; intros. destruct H. apply in_or_app. inversion H0; [left|right]. apply H2; auto. apply H1; auto. apply in_app_or in H. destruct H. apply H2 in H. destruct H; split; auto. rewrite H0; auto. apply H1 in H. destruct H. split; auto. Defined.
Definition Racc_dec: forall r l, {Racc r l}+{~Racc r l}. intros r l. destruct (Rlang_length r (length l)) as [m H]. destruct (in_dec (list_eq_dec C_eq_dec) l m); [left|right]. apply H in i. destruct i; auto. contradict n. apply H; auto. Defined.

Theorem Rstar_rev: forall r w, Racc (Rstar r) w -> {w1:list C & {w2|w=w1++w2 /\ w1<>nil /\ Racc r w1 /\Racc (Rstar r) w2}}+{w=nil}. intros. destruct (list_eq_dec C_eq_dec w nil). right; auto. left. destruct (splits w) as [wl H1 _]. destruct (findP (fun p=>fst p<>nil/\Racc r (fst p)/\Racc (Rstar r) (snd p)) wl) as [[[w1 w2] H2]|H2]. intros p H0. destruct (list_eq_dec C_eq_dec (fst p) nil); [right|]. contradict e. destruct e; auto. destruct (Racc_dec r (fst p)); [|right]. destruct (Racc_dec (Rstar r) (snd p)); [left|right]; auto. contradict n1. destruct n1; destruct H3; auto. contradict n1. destruct n1; destruct H3; auto. destruct a. destruct H3. exists w1. exists w2. split; auto. apply H1 in H2. subst w; auto. exfalso. destruct (Rstar_rev' H) as [l [m [H3 [H4 [H5 H6]]]]]; auto. subst w. cut (In (l,m) wl). intros. apply H2 in H0. contradict H0. simpl; auto. apply H1. auto. Defined.
Theorem Rstar_dual: forall r, Req (Rstar r) (Rstar (Rstar r)). Proof. intros. split; intros w H. auto. revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc(Rstar(Rstar r)) w->Racc(Rstar r) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]; auto. subst w. apply Rstar_app; auto. apply IH; auto. unfold ltof. destruct w1. contradict H3; auto. rewrite app_length. apply le_n_S; apply le_plus_r. subst w; auto. Qed.
Theorem Rstar_dual2: forall r, Req (Rstar r) (Rcons (Rstar r) (Rstar r)). Proof. intros; split; intros w H. rewrite <- app_nil_r; auto. inversion H. apply Rstar_app; auto. Qed.
Theorem Rstar_or: forall r s, Req (Rstar (Ror r s)) (Rstar (Rcons (Rstar r) (Rstar s))). Proof. intros. split; intros w H; revert H. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Ror r s)) w -> Racc (Rstar (Rcons (Rstar r) (Rstar s))) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]. subst w. apply RAstar2; auto. inversion H3. rewrite <- app_nil_r; auto. rewrite <- app_nil_l; auto. apply IH; auto. unfold ltof. rewrite app_length. destruct w1. contradict H2; auto. simpl; auto. subst w; auto.
  apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>Racc (Rstar (Rcons (Rstar r) (Rstar s))) w->Racc (Rstar (Ror r s)) w). clear w. intros w IH H. destruct (Rstar_rev H) as [[w1 [w2 [H1 [H2 [H3 H4]]]]]|H1]; subst w; auto. inversion H3; auto. subst w1 r0 s0. apply Rstar_app. apply Rstar_app. revert H5. apply Rstar_incl. intros w Hw. auto. revert H7. apply Rstar_incl. intros w Hw. auto. apply IH; auto. unfold ltof. remember (l++m) as w1. destruct w1. contradict H2; auto. rewrite app_length. simpl. auto. Qed.

(* Deterministic Finite Automata *)
Record DFA: Set := mkDFA {
  DFAstates: list nat; DFAtrans: nat->C->nat;
  DFAinit: nat; DFAaccept: list nat;
  DFAtrans_const: forall c s, In s DFAstates -> In (DFAtrans s c) DFAstates;
  DFAinit_const: In DFAinit DFAstates;
  DFAacc_const: incl DFAaccept DFAstates}.
Definition DFAacc (d:DFA) (w:list C) : Prop := In (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d).
Definition DFAacc_dec: forall d w, {DFAacc d w}+{~DFAacc d w}. intros. destruct (in_dec nat_eq_dec (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d)); [left|right]; auto. Defined.

Inductive Head {T:Type}: T -> list T -> Prop := Head_intro: forall a l, Head a (a::l).
Inductive Tail {T:Type}: T -> list T -> Prop := Tail_nil: forall a, Tail a (a::nil) | Tail_cons: forall  a b l, Tail a l -> Tail a (b::l).
Hint Constructors Head Tail.
Definition Head_dec': forall {T:Type} (l:list T), {a| Head a l & forall b, Head b l -> b=a}+{l=nil}. intros. destruct l. right; auto. left; exists t; auto. intros. inversion H; auto. Defined.
Definition Tail_dec': forall {T:Type} (l:list T), {a| Tail a l & forall b, Tail b l -> b=a}+{l=nil}. intros. destruct l. right; auto. left. induction l. exists t; auto. intros. inversion H; auto. inversion H2. destruct IHl as [b H1 H2]. destruct l. exists a; auto. intros. inversion H. inversion H4; auto. inversion H8. exists b. inversion H1; auto. intros. apply H2. inversion H. inversion H4; auto. Defined.
Definition Tail_dec: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (a:T) l, {Tail a l}+{~Tail a l}. intros. destruct (Tail_dec' l) as [[b H1 H2]|H1]. destruct (T_eq_dec a b). subst b; left; auto. right. contradict n; auto. subst l; right. intros D; inversion D. Defined.
Definition tail: forall {T:Type} (l:list T), {a:T & {m | l=m++a::nil}}+{l=nil}. induction l. right; auto. destruct IHl. destruct s as [b [m H]]. left. exists b. exists (a::m); auto. simpl. f_equal; auto. subst l. left. exists a. exists nil; auto. Defined.
Theorem Tail_In: forall {T:Type} (l:list T) t, Tail t l -> In t l. Proof. intros. induction H; auto. Qed.

Definition ubound_sig: forall (l:list nat), {a|forall x, In x l->x<a & forall b, (forall x, In x l->x<b) -> a<=b}. induction l. exists 0; intros. destruct H. apply le_O_n. destruct IHl as [m Ha Hb]. destruct (le_lt_dec m a). exists (S a); intros. destruct H. subst x; auto. apply lt_le_trans with m; auto. apply H. left; auto. exists m; intros; auto. destruct H; auto. subst x; auto. Defined.
Definition ubound (l:list nat): nat := let (n,_,_):= ubound_sig l in n.
Definition Disjoint {T:Type} : relation (list T):= fun l m =>forall x, ~(In x l /\ In x m).
Theorem Disjoint_comm: forall {T:Type} (l m:list T), Disjoint l m -> Disjoint m l. Proof. unfold Disjoint. intros. intros D. destruct D. absurd (In x l/\In x m); auto. Qed.
Theorem Disjoint_In1: forall {T:Type} l m (x:T), Disjoint l m -> In x l -> ~In x m. Proof. intros. intros D. unfold Disjoint in H. absurd (In x l/\In x m); auto. Qed.
Theorem ubound_Disjoint: forall l m, Disjoint l (map (plus (ubound l)) m). Proof. intros. unfold ubound. destruct (ubound_sig l) as [n H _]. intros x D. destruct D. absurd (x<n); auto. apply le_not_lt. apply in_map_iff in H1. destruct H1 as [y [H2 H3]]. subst x. auto. Qed.
Hint Resolve Tail_In Disjoint_comm Disjoint_In1 ubound_Disjoint.

Theorem remove_In2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a x, In x (remove T_eq_dec a l) <-> x<>a /\ In x l. Proof. induction l; simpl; split; intros. destruct H. destruct H; auto. destruct (T_eq_dec a0 a). subst a0. apply IHl in H. destruct H. split; auto. destruct H. subst x. split; auto. apply IHl in H. destruct H; auto. destruct H. destruct (T_eq_dec a0 a). apply IHl. destruct H0; auto. subst a0 a. contradict H; auto. destruct H0; auto. left; auto. right. apply IHl; auto. Qed.
Theorem remove_length2:forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l:list T) a, In a l -> length (remove T_eq_dec a l) < length l. Proof. induction l; simpl; intros. destruct H. destruct (T_eq_dec a0 a). apply le_n_S. apply remove_length. simpl. apply le_n_S. apply IHl. destruct H; auto. contradict n; auto. Qed.
Definition removeAll {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T):= fold_right (remove T_eq_dec) m l.
Theorem removeAll_In: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, ~In x l /\ In x m <-> In x (removeAll T_eq_dec l m). Proof. induction l; intros; simpl; split; intros. destruct H; auto. split; auto. destruct H. destruct (T_eq_dec x a). subst x; contradict H; auto. apply remove_In2. split; auto. apply IHl with (m:=m) (x:=x). split; auto. apply remove_In2 in H. destruct H. apply IHl in H0. destruct H0. split; auto. contradict H0. destruct H0; auto. contradict H; auto. Qed.
Theorem removeAll_app: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l1 l2 m:list T), removeAll T_eq_dec (l1++l2) m = removeAll T_eq_dec l1 (removeAll T_eq_dec l2 m). Proof. induction l1; simpl; intros; auto. f_equal; auto. Qed.
Theorem removeAll_length: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), length (removeAll T_eq_dec l m) <= length m. Proof. induction l; simpl; intros; auto. eapply le_trans. apply remove_length. apply IHl; auto. Qed.
Theorem removeAll_length2: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T) x, In x l -> In x m -> length (removeAll T_eq_dec l m) < length m. Proof. induction l; intros. destruct H. simpl. destruct H. subst x. destruct (in_dec T_eq_dec a l). apply le_lt_trans with (length (removeAll T_eq_dec l m)); auto. apply remove_length. apply IHl with a; auto. apply lt_le_trans with (length (removeAll T_eq_dec l m)). apply remove_length2; auto. apply removeAll_In; auto. apply removeAll_length. eapply le_lt_trans. eapply remove_length. eapply IHl; eauto. Qed.
Definition incl_dec: forall {T:Type} (T_eq_dec:forall x y:T, {x=y}+{x<>y}) (l m:list T), {x|In x l & ~In x m}+{incl l m}. induction l; intros. right. intros x H; inversion H. destruct (in_dec T_eq_dec a m). destruct (IHl m); [left|right]. destruct s. exists x; auto. intros x H. destruct H; auto. subst x; auto. left; exists a; auto. Defined.
Definition commonList: forall {T:Type} (T_eq_dec:forall x y:T,{x=y}+{x<>y}) (l m:list T), {c|forall x, In x c<->In x l /\ In x m}. intros. exists (filter (dec2b (fun x=>in_dec T_eq_dec x m)) l). intros; split; intros. induction l. inversion H. simpl in H. remember (dec2b (fun x=>in_dec T_eq_dec x m) a) as b. destruct b. destruct H. subst a. symmetry in Heqb. apply dec2b_true in Heqb. auto. destruct IHl; auto. destruct IHl; auto. destruct H. induction l. destruct H. simpl. destruct H. subst a. remember (dec2b (fun y=>in_dec T_eq_dec y m) x) as b. symmetry in Heqb. destruct b; auto. apply dec2b_false in Heqb. contradiction. destruct (dec2b (fun y=>in_dec T_eq_dec y m) a); auto. Defined.
Definition inv_func: forall {T U:Type} (U_eq_dec:forall x y:U, {x=y}+{x<>y}) (f:T->U) l (d:T), (forall x y, In x l->In y l->f x=f y->x=y) -> {g:U->T|forall x, In x l->g (f x)=x & forall y, ~In y (map f l)->g y=d}. intros. exists (fun y=>match findP (fun x=>f x=y) l (fun x _=>U_eq_dec (f x) y) with inleft _ (exist2 _ _ f _ _) => f  | inright _ _ => d end). intros. destruct (findP (fun y=>f y=f x) l (fun y _=>U_eq_dec (f y) (f x))) as [[a H1 H2]|H1]; auto. absurd (f x=f x); auto. intros. destruct (findP (fun x=>f x=y) l (fun x _=>U_eq_dec (f x) y)) as [[a H1 H2]|H1]; auto.  contradict H0. subst y. apply in_map_iff. exists a; auto. Defined.

(* Non-deterministic Finite Automata *)
Record NFA: Type := mkNFA {
  NFAstates: list nat;
  NFAtrans: nat -> C -> list nat;
  NFAinit: list nat; (* take a list for future extension *)
  NFAaccept: list nat;
  NFAtrans_const: forall c s, In s NFAstates -> incl (NFAtrans s c) NFAstates;
  NFAinit_const: incl NFAinit NFAstates;
  NFAacc_const: incl NFAaccept NFAstates;
}.
Inductive NFAsteps (n:NFA) : list C -> list nat -> Prop:=
| NFAsteps_nil: forall s, NFAsteps n nil (s::nil)
| NFAsteps_cons: forall s t l w c, NFAsteps n w (t::l) -> In t (NFAtrans n s c) -> NFAsteps n (c::w) (s::t::l)
.
Inductive NFAacc (n:NFA) (w:list C) : Prop := NFAacc_intro: forall is es l, In es (NFAaccept n) ->In is (NFAinit n) -> NFAsteps n w l -> Head is l -> Tail es l -> NFAacc n w.
Hint Constructors NFAsteps NFAacc.

Theorem NFAsteps_const: forall n w s l, NFAsteps n w (s::l) -> In s (NFAstates n) -> incl l (NFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. intros x Hx. destruct Hx. inversion H. subst w s0 a l0. intros x Hx. destruct Hx. subst x. apply NFAtrans_const in H6; auto. apply IHl with w0 t in H1; auto. apply NFAtrans_const in H6; auto. Qed.
Definition NFAsteps_states': forall n w s, {sl| forall l, In l sl <-> Head s l /\ NFAsteps n w l}. induction w; intros. exists ((s::nil)::nil); intros; split; intros. destruct H. subst l; auto. destruct H. destruct H. inversion H0. subst l. inversion H. subst a s0 l. left; auto.
  exists (flat_map (fun t=>let (sl,_):= IHw t in map (cons s) sl) (NFAtrans n s a)). intros; split; intros. apply in_flat_map in H. destruct H as [t [H1 H2]]. destruct (IHw t) as [sl H3]. apply in_map_iff in H2. destruct H2 as [m [H4 H5]]. subst l. split; auto. apply H3 in H5. destruct H5. inversion H. subst a0 m. auto. destruct H. apply in_flat_map. inversion H0. subst a w0 l. inversion H. subst a s0 l. exists t. split; auto. destruct (IHw t) as [sl H6]. apply in_map_iff. exists (t::l0); auto. split; auto. apply H6. auto. Defined.
Definition NFAsteps_states: forall n w sl, {tl| forall t, In t tl <-> exists s, In s sl /\ exists l, NFAsteps n w l /\ Head s l /\ Tail t l & incl sl (NFAstates n) -> incl tl (NFAstates n)}. intros. exists (map (fun l=>match tail l with inleft (existT _  a _) => a |inright _ => 0 end) (flat_map (fun s=>let (l,_):=NFAsteps_states' n w s in l) sl)). intros; split; intros. apply in_map_iff in H. destruct H as [x [H H0]]. apply in_flat_map in H0. destruct H0 as [y [H0 H1]]. destruct (NFAsteps_states' n w y) as [l H2]. apply H2 in H1. destruct H1. destruct (tail x) as [[a [m H4]]|H4]. subst x a. exists y. split; auto. exists (m++t::nil); auto. split; auto. split; auto. clear -m. induction m; simpl; auto. subst x t. inversion H1.
  destruct H as [s [H1 [l [H2 [H3 H4]]]]]. apply in_map_iff. exists l. split. destruct (tail l) as [[a [m H5]]|H5]. subst l. clear -H4. induction m. inversion H4; auto. inversion H1. apply IHm. inversion H4; auto. destruct m; inversion H2; auto. subst l. inversion H4. apply in_flat_map. exists s. split; auto. destruct (NFAsteps_states' n w s). apply i. auto. intros. intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. destruct (NFAsteps_states' n w z) as [tl H5]. apply H5 in H4. destruct H4. destruct (tail y) as [[a [m H4]]|H4]. subst a y. inversion H0. subst a. destruct m. inversion H6. subst x l. apply H; auto. inversion H6. subst n0 l. simpl in H2. apply NFAsteps_const in H2. apply H2. apply in_or_app. right; auto. apply H; auto. subst y. inversion H0.  Defined.

Definition NFAacc_dec: forall n w, {NFAacc n w}+{~NFAacc n w}. intros. destruct (NFAsteps_states n w (NFAinit n)) as [tl H _]. destruct findP with (l:=tl) (P:=fun s=>In s (NFAaccept n)) as [[s H0]|H0]. intros. apply in_dec. apply nat_eq_dec. left. apply H in H0.  destruct H0 as [is [H1 [l [H2 [H3 H4]]]]]. apply NFAacc_intro with is s l; auto. right. intros D. inversion D. contradict H1. apply H0. apply H. exists is. split; auto. exists l; auto. Defined.

Theorem NFAsteps_app: forall n w1 l1, NFAsteps n w1 l1 -> forall w2 l2 s, NFAsteps n w2 (s::l2) -> Tail s l1 -> NFAsteps n (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply NFAsteps_cons; auto. apply IHNFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem NFAsteps_app_s_rev: forall n l1 l2 w s, NFAsteps n w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists (c::w0); auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n0 l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists (c::w1). exists w2. split; simpl; f_equal; auto. Qed.
Theorem NFAsteps_app_w_rev: forall n w1 w2 l, NFAsteps n (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2) /\ Tail s l1. Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|t l]. inversion H. exists t. exists (t::nil). exists l; auto. inversion H. subst c0 w l. apply IHw1 in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. exists u. destruct l1. inversion Hb. inversion Ha. subst n0 l0. exists (s::t::l1). exists l2. split; auto. Qed.
Theorem NFAsteps_parteq: forall n1 n2 w l st, incl l st -> (forall s c, In s st -> NFAtrans n1 s c = NFAtrans n2 s c) -> NFAsteps n1 w l -> NFAsteps n2 w l. Proof. intros. induction H1; auto. apply NFAsteps_cons; auto. apply IHNFAsteps. intros x Hx; auto. rewrite <- H0; auto. Qed.

(* Non-deterministic Finite Automata with Empty *)
Record EFA: Set := mkEFA {
  EFAstates: list nat; EFAtrans: nat->C->list nat; EFAempty: nat->list nat;
  EFAinit: list nat; (* take a list for future extension *)
  EFAaccept: list nat;
  EFAtrans_const: forall c s, In s EFAstates -> incl (EFAtrans s c) EFAstates;
  EFAempty_const: forall s, In s EFAstates -> incl (EFAempty s) EFAstates;
  EFAinit_const: incl EFAinit EFAstates;
  EFAacc_const: incl EFAaccept EFAstates;
}.
Inductive EFAsteps (n:EFA) : list C -> list nat -> Prop:=
| EFAsteps_nil: forall s, EFAsteps n nil (s::nil)
| EFAsteps_empty: forall s t l w, EFAsteps n w (t::l) -> In t (EFAempty n s) -> EFAsteps n w (s::t::l)
| EFAsteps_cons: forall s t l w c, EFAsteps n w (t::l) -> In t (EFAtrans n s c) -> EFAsteps n (c::w) (s::t::l)
.
Inductive EFAacc (n:EFA) (w:list C) : Prop := EFAacc_intro: forall is es l, In es (EFAaccept n) -> In is (EFAinit n) -> EFAsteps n w l -> Head is l -> Tail es l -> EFAacc n w.
Hint Constructors EFAsteps EFAacc clos_refl_trans.

Theorem EFAsteps_const: forall n w s l, In s (EFAstates n) -> EFAsteps n w l -> Head s l -> incl l (EFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. inversion H1. intros x Hx. destruct Hx. subst x. inversion H1. subst a a0 l0. auto. inversion H1. subst a0 a l0. clear H1. inversion H0. subst l. destruct H2. subst w0 s0 l. apply IHl with w t in H2; auto. apply EFAempty_const in H6; auto. subst w s0 l. apply IHl with w0 t in H2; auto. apply EFAtrans_const in H6; auto. Qed.
Theorem EFAsteps_app: forall e w1 l1, EFAsteps e w1 l1 -> forall w2 l2 s, EFAsteps e w2 (s::l2) -> Tail s l1 -> EFAsteps e (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply EFAsteps_empty; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2. inversion H5; auto. apply EFAsteps_cons; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem EFAsteps_app_s_rev: forall e l1 l2 w s, EFAsteps e w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w0 s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists w; auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists w1. exists w2. split; auto.
  subst s0. inversion H0. subst a t l1. exists nil. exists (c::w0). simpl in H2. subst l2. auto. subst a b l0. destruct l1. inversion H7. inversion H2. subst n l. replace (t0::l1++l2) with ((t0::l1)++l2) in H4; auto. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H6 [H8 H9]]]]. exists (c::w1). exists w2. split; auto. subst w0. auto. Qed.
Theorem EFAsteps_cons_rev: forall n w c l, EFAsteps n (c::w) l -> exists s t l1 l2, l=l1++t::l2 /\ Tail s l1 /\ EFAsteps n nil l1 /\ EFAsteps n w (t::l2) /\ In t (EFAtrans n s c). Proof. intros n w c l H. remember (c::w) as w' in H. revert Heqw'. revert c w. induction H; intros. inversion Heqw'. apply IHEFAsteps in Heqw'. destruct Heqw' as [s' [t' [l1' [l2' [H1 [H2 [H3 [H4 H5]]]]]]]].  exists s'. exists t'. exists (s::l1'). exists l2'. split. simpl; f_equal; auto. split ; auto. split; auto. destruct l1'. inversion H3. inversion H1. subst n0 l. apply EFAsteps_empty; auto.
  inversion Heqw'. subst c0 w0. exists s. exists t. exists (s::nil). exists l; auto. Qed.
Theorem EFAsteps_app_w_rev: forall e w1 w2 l, EFAsteps e (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ Tail s l1 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|s l]. inversion H. exists s. exists (s::nil). exists l; auto. destruct (EFAsteps_cons_rev H) as [s [t [l1 [l2 [H1 [H2 [H3 [H4 H5]]]]]]]]. subst l. destruct (IHw1 w2 (t::l2) H4) as [u [m1 [m2 [H6 [H7 [H8 H9]]]]]]. destruct m1. inversion H8. inversion H6. subst n l2. exists u. exists (l1++t::m1). exists m2. split; auto. rewrite <- app_assoc; auto. split. clear -H7. induction l1; simpl; auto. split; auto. replace (c::w1) with (nil++c::w1); auto. apply EFAsteps_app with s; auto. Qed.
Definition EFA_empty_states': forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}. intros n sl. apply (Fix (well_founded_ltof (list nat) (fun l=>length (removeAll nat_eq_dec l (EFAstates n))))) with (P:=fun sl=>incl sl (EFAstates n)->{tl|forall t,In t tl<->exists s,In s sl/\clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}). clear sl. intros sl IH H.
  destruct (incl_dec nat_eq_dec (flat_map (EFAempty n) sl) sl) as [[x H0 H1]|H0]. destruct (IH (flat_map (EFAempty n) sl++sl)) as [tl H2]. unfold ltof. rewrite removeAll_app. apply removeAll_length2 with x; auto. apply removeAll_In. split; auto. apply in_flat_map in H0. destruct H0 as [y [H2 H3]]. apply (EFAempty_const n) in H3; auto.
  intros y Hy. apply in_app_or in Hy. destruct Hy; auto. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. apply (EFAempty_const n) in H4; auto. exists tl. intros t; split; intros. apply H2 in H3. destruct H3 as [s [H4 H5]]. apply in_app_or in H4. destruct H4. apply in_flat_map in H3. destruct H3 as [u [H6 H7]]. exists u. split; auto. apply rt_trans with s; auto. exists s; auto. apply H2. destruct H3 as [s [H4 H5]]. exists s. split; auto. apply in_or_app; auto.
  exists sl. intros; split; intros. exists t; auto. destruct H1 as [s [H2 H3]]. clear -H0 H2 H3. induction H3; auto. apply H0. apply in_flat_map. exists x; auto. Defined.
Theorem EFAsteps_incl: forall e1 e2 w l st, incl l st -> (forall s t, In s st-> In t (EFAempty e1 s) -> In t st -> In t (EFAempty e2 s)) -> (forall s c t, In s st -> In t (EFAtrans e1 s c) -> In t st -> In t (EFAtrans e2 s c)) -> EFAsteps e1 w l -> EFAsteps e2 w l. Proof. intros. induction H2; auto. apply EFAsteps_empty; auto. apply IHEFAsteps. intros x Hx; auto. apply EFAsteps_cons; auto. apply IHEFAsteps. intros x Hx; auto. Qed.

Definition EFA_empty_states: forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ exists l, EFAsteps n nil l /\ Head s l /\ Tail t l}. intros. destruct (EFA_empty_states' n H) as [tl H0]. exists tl. intros; split; intros. apply H0 in H1. destruct H1 as [s [H2 H3]]. exists s. split; auto. clear -H3. induction H3. exists (x::y::nil); auto. exists (x::nil); auto. destruct IHclos_refl_trans1 as [l [H1 [H2 H3]]]. destruct IHclos_refl_trans2 as [m [H4 [H5 H6]]]. inversion H5. subst a m. exists (l++l0). split. assert (EFAsteps n (nil++nil) (l++l0)). apply EFAsteps_app with y; auto. simpl in H; auto. split. inversion H2; simpl; auto. inversion H6. rewrite app_nil_r; auto. clear -H7. induction l; simpl; auto.
  apply H0. destruct H1 as [s [H2 [l [H3 [H4 H5]]]]]. exists s. split; auto. clear H2. revert dependent s. revert dependent t. clear -H3. induction l; intros. inversion H3. inversion H4. subst a0 a l0. inversion H3. subst s0 l. inversion H5. apply rt_refl. inversion H1. subst w s0 l. inversion H5. subst a b l. apply rt_trans with t0. apply rt_step; auto. apply IHl; auto. Defined.

Definition EFAsteps_states: forall n w sl, incl sl (EFAstates n) -> {tl|forall t, In t tl <-> exists s, In s sl /\ exists l, EFAsteps n w l /\ Head s l /\ Tail t l}. induction w as [|c w]; intros. destruct (EFA_empty_states n H) as [tl H0]. exists tl. auto.
  destruct (EFA_empty_states n H) as [tl H0]. assert (H1: incl (flat_map (fun s=>EFAtrans n s c) tl) (EFAstates n)). intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H1 H2]]. apply EFAtrans_const in H2; auto. destruct (H0 y). destruct (H3 H1) as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hc. subst a l. apply EFAsteps_const with (s:=s) in Hb; auto. destruct (IHw (flat_map (fun s=>EFAtrans n s c) tl) H1) as [ul H2]. clear IHw. exists ul. intros; split; intros. apply H2 in H3. destruct H3 as [s [Ha [l [Hb [Hc Hd]]]]]. clear H2. apply in_flat_map in Ha. destruct Ha as [x [H3 H2]]. apply H0 in H3. destruct H3 as [y [H4 [m [H5 [H6 H7]]]]]. exists y. split; auto. exists (m++l). split. replace (c::w) with (nil++c::w); auto. apply EFAsteps_app with x; auto. inversion Hc. subst a l. apply EFAsteps_cons; auto. split. inversion H6; simpl; auto. clear -Hd. induction m; simpl; auto.
  apply H2. clear H2. destruct H3 as [s [H4 [l [H5 [H6 H7]]]]]. destruct (EFAsteps_cons_rev H5) as [u [v [l1 [l2 [Ha [Hb [Hc [Hd He]]]]]]]]. subst l. exists v. split. apply in_flat_map. exists u. split; auto. apply H0. exists s. split; auto. exists l1; auto. split; auto. split; auto. destruct l1. inversion Hc. inversion H6; auto. exists (v::l2). split; auto. split; auto. clear -H7. induction l1; simpl; auto. inversion H7; auto. destruct l1; inversion H2. Defined. 
Definition EFAacc_dec: forall n w, {EFAacc n w}+{~EFAacc n w}. intros. destruct (EFAsteps_states n w) with  (sl:=EFAinit n) as [tl H]. intros x H. apply (EFAinit_const n) in H; auto. destruct findP with (P:=fun s=>In s tl) (l:=EFAaccept n). intros. apply in_dec. apply nat_eq_dec. destruct s as [s H1 H2]. left. apply H in H2. destruct H2 as [is [H4 [l [H5 [H6 H7]]]]]. apply EFAacc_intro with is s l; auto. right. intros D. inversion D. apply n0 in H0. contradict H0. apply H. exists is. split; auto. exists l; auto. Defined.

Definition EFA2NFA: forall e, {n| forall w, EFAacc e w <-> NFAacc n w}. intros. destruct (EFA_empty_states e (EFAinit_const e)) as [is H]. assert (Hi: incl is (EFAstates e)). intros x Hx. apply H in Hx. destruct Hx as [s [H1 [l [H2 [H3 H4]]]]]. apply (EFAinit_const e) in H1. inversion H3. subst a l. apply EFAsteps_const with (s:=s) in H2; auto. remember (fun s c=>match in_dec nat_eq_dec s (EFAstates e) with |left H => match EFA_empty_states e (EFAtrans_const e c s H) with exist _ sl _ => sl end |right _ => nil end) as tr. assert (Ht: forall c s, In s (EFAstates e) -> incl (tr s c) (EFAstates e)). intros. subst tr. destruct (in_dec nat_eq_dec s (EFAstates e)); [|contradiction]. destruct (EFA_empty_states e (EFAtrans_const e c s i)) as [tl H1]. intros x Hx. apply H1 in Hx.  destruct Hx as [t [H2 [l [H3 [H4 H5]]]]]. inversion H4. subst a l. assert (In t (EFAstates e)). apply (EFAtrans_const e c s); auto. apply EFAsteps_const with (s:=t) in H3; auto.
  exists (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)). cut (forall w t, (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail t l) <-> exists s, In s is /\ exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\ Tail t l). intros; split; intros. inversion H1. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail es l). exists is0. split; auto. exists l; auto. apply (H0 w es) in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply NFAacc_intro with s es m; auto. inversion H1. assert (exists s, In s is/\ exists l, NFAsteps (mkNFA tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\Tail es l). exists is0; split; auto. exists l; auto. apply H0 in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply EFAacc_intro with s es m; auto.
  intros w. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>forall t, (exists s, In s (EFAinit e)/\(exists l, EFAsteps e w l/\Head s l/\Tail t l))<->(exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l/\Head s l/\Tail t l)). clear w. intros w IH t. destruct (tail w) as [[c [w' H1]]|H1]. subst w. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. apply EFAsteps_app_w_rev in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. subst l. apply EFAsteps_cons_rev in Hd. destruct Hd as [v [w [m1 [m2 [H5 [H6 [H7 [H8 H9]]]]]]]]. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w' l/\Head s l/\Tail v l). exists s. split; auto. destruct m1. inversion H7. inversion H5. subst n l2. exists (l1++m1); auto. split; auto. replace w' with (w'++nil). apply EFAsteps_app with u; auto. rewrite app_nil_r; auto. split. destruct l1. inversion Hc. inversion H3; simpl; auto. inversion H6. subst v m1 a. rewrite app_nil_r; auto. clear -H10. induction l1; simpl; auto. apply IH in H0. clear IH. destruct H0 as [x [Hd [l [He [Hf Hg]]]]]. exists x. split; auto. exists (l++t::nil). split. apply NFAsteps_app with v; auto. apply NFAsteps_cons; auto.
  simpl. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0. exists w. split; auto. exists (w::m2). split; auto. split; auto. destruct l2. destruct m1. inversion H7. inversion H5. destruct m1; inversion H10. clear -H5 H4. assert (Tail t (n::l2)). induction l1; auto. apply IHl1. inversion H4; auto. destruct l1; inversion H2. destruct m1. inversion H5. subst u m2. auto. inversion H5. rewrite H2 in H. clear -H. induction m1; auto. apply IHm1. inversion H; auto. destruct m1; inversion H3. contradict n. apply Hi in Hd. inversion Hf. subst a l. apply NFAsteps_const in He. simpl in He. inversion Hg; auto.  simpl; auto. split. inversion Hf; simpl; auto. clear -l. induction l; simpl; auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  destruct H0 as [u [H1 [l [H2 [H3 H4]]]]]. apply NFAsteps_app_w_rev in H2. destruct H2 as [v [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. assert (exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w' l/\Head s l/\Tail v l). exists u. split; auto. exists m1; split; auto. split; auto. destruct m1. inversion Hb. inversion H3; auto. apply IH in H0. clear IH. destruct H0 as [x [H5 [l [H6 [H7 H8]]]]]. exists x; split; auto. inversion Hc. subst c0 w s m2. clear Hc. simpl in H12. inversion H10. subst t0 l0. clear H10.  assert (s=t). clear -H4. induction m1; simpl; auto. inversion H4; auto. inversion H1. apply IHm1. inversion H4; auto. destruct m1; inversion H2. subst s. clear H4. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0 in H12. destruct H12 as [s [H13 [m [H14 [H15 H16]]]]]. exists (l++m). split. apply EFAsteps_app with v; auto. inversion H15. subst a m. apply EFAsteps_cons; auto. split. inversion H7; simpl; auto. clear -H16. induction l; simpl; auto. contradict n. inversion H7. subst a l.  clear -H8 H5 H6. apply EFAinit_const in H5. inversion H8. auto. subst a b l0. apply EFAsteps_const with (s:=x) in H6; auto. clear -c. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. exists t. split. apply H. exists s. split; auto. exists l; auto. exists (t::nil); auto. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. inversion H2. subst l. inversion H3. subst a s0 l. inversion H4. subst a t. apply H in H1. destruct H1 as [t [Ha [l [Hb [Hc Hd]]]]]. exists t. split; auto. exists l; auto. inversion H6. Qed.
 
Definition NFA2EFA: forall n, {e|forall w, EFAacc e w <-> NFAacc n w}. intros. assert (H: forall s, In s (NFAstates n) -> incl ((fun _=>nil) s) (NFAstates n)). intros. intros x Hx; inversion Hx. exists (mkEFA (NFAtrans n) (fun _ => nil) (NFAtrans_const n) H (NFAinit_const n) (NFAacc_const n)). intros; split; intros. inversion H0. clear H0. simpl in H1. simpl in H2. apply NFAacc_intro with is es l; auto. clear -H3. induction H3; auto. simpl in H0. inversion H0. inversion H0. apply EFAacc_intro with is es l; auto. clear -H3. induction H3; auto. Defined.

Definition DFA2NFA: forall d, {n|forall w, DFAacc d w <-> NFAacc n w}. intros. assert (Ht: forall c s, In s (DFAstates d)->incl (DFAtrans d s c::nil) (DFAstates d)). intros. intros x Hx. destruct Hx. subst x. apply DFAtrans_const; auto. destruct H0. assert (Hi: incl (DFAinit d::nil) (DFAstates d)). intros x Hx. destruct Hx. subst x. apply DFAinit_const; auto. destruct H. exists (mkNFA (fun s c=>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)). unfold DFAacc. cut (forall w s t, t=fold_left (DFAtrans d) w s <-> exists l, NFAsteps (mkNFA (fun s c =>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)) w l /\ Head s l /\Tail t l). intros. split; intros. destruct (H w (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d))). destruct H1 as [l [H3 [H4 H5]]]; auto. apply NFAacc_intro with (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d)) l; auto. simpl. auto. inversion H0. clear H0. simpl in H1. simpl in H2. destruct H2; [|destruct H0]. subst is. assert (es=fold_left (DFAtrans d) w (DFAinit d)). apply H. exists l; auto. rewrite <- H0; auto.
  induction w; intros; split; intros. simpl in H. subst t. exists (s::nil); auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. subst l. inversion H2. subst a s0 l. inversion H3. subst t; auto. inversion H4. simpl in H. subst t. destruct (IHw (DFAtrans d s a) (fold_left (DFAtrans d) w (DFAtrans d s a))). clear IHw H0. destruct H as [l [H1 [H2 H3]]]; auto. exists (s::l). split; auto. inversion H2. subst a0 l. apply NFAsteps_cons; auto. simpl. auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. clear H1. simpl in H6. destruct H6; [|destruct H1]. subst a w0 l t0. simpl. apply IHw. clear IHw. inversion H2. subst s0 a l. exists (DFAtrans d s c::l0); auto. split; auto. split; auto. inversion H3; auto. Defined.
Definition DFA2EFA: forall d, {e|forall w, DFAacc d w <-> EFAacc e w}. intros. destruct (DFA2NFA d) as [n H]. destruct (NFA2EFA n) as [e H0]. exists e. intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition NFA2DFA: forall n, {d|forall w, NFAacc n w <-> DFAacc d w}. intros. remember (fun s c=>ps2i nat_eq_dec (NFAstates n) (flat_map (fun s=>NFAtrans n s c) (i2ps nat_eq_dec (NFAstates n) s))) as t. assert (Hu: forall c s, In s (seq 0 (psSize nat_eq_dec (NFAstates n))) -> In (t s c) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros. subst t. apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H4 H5]]. apply NFAtrans_const in H5; auto. apply i2ps_spec1 in H4; auto. apply in_seq in H. destruct H; auto. assert (Hj: In (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) (seq 0 (psSize nat_eq_dec (NFAstates n)))). apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply NFAinit_const; auto. destruct (contain_powerSet nat_eq_dec (NFAstates n) (NFAaccept n)) as [al H4]. assert (Hac: incl (map (ps2i nat_eq_dec (NFAstates n)) al) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros x Hx. apply in_seq. split. apply le_O_n. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply ps2i_spec1; auto. assert (Exists (equiv y) al). apply Exists_exists. exists y; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. exists (mkDFA t (ps2i nat_eq_dec (NFAstates n)  (NFAinit n)) Hu Hj Hac).
  assert (H5: forall w, fold_left t w (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) = let (tl,_,_) := NFAsteps_states n w (NFAinit n) in ps2i nat_eq_dec (NFAstates n) tl). apply (Fix (well_founded_ltof (list C) (length (A:=C)))). intros w IH. destruct (tail w) as [[c [w' H1]]|H1]. subst w. destruct (NFAsteps_states n (w'++c::nil) (NFAinit n)) as [tl H1 Ht]. rewrite fold_left_app. rewrite IH. clear IH. destruct (NFAsteps_states n w' (NFAinit n)) as [ul H0 Hv]. simpl. subst t. apply ps2i_spec3. intros x; split; intros. apply in_flat_map in H. destruct H as [y [H5 H6]]. apply i2ps_spec3 in H5. apply H1. apply H0 in H5. destruct H5 as [s [Ha [l [Hb [Hc Hd]]]]]. exists s. split; auto. exists (l++x::nil); split. apply NFAsteps_app with y; auto. split. inversion Hc; simpl; auto. clear -l. induction l; simpl; auto. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H1 in H. destruct H as [s [H5 [l [H6 [H7 H8]]]]]. apply in_flat_map. apply NFAsteps_app_w_rev in H6. destruct H6 as [t [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. inversion Hc. subst c0 w s0 m2. inversion H6. subst t0 l. clear Hc H6. assert (x=s0). clear -H8. induction m1. inversion H8; auto. inversion H1. apply IHm1. inversion H8; auto. destruct m1; inversion H2. subst s0. exists t. split; auto. apply i2ps_spec3. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H0. destruct m1. inversion Hb. inversion H7. subst n0 a l. exists s. split; auto. exists (s::m1); auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. destruct (NFAsteps_states n nil (NFAinit n)) as [ul H0 Hv]. simpl. apply ps2i_spec3. intros x; split; intros. apply H0. exists x; split; auto. exists (x::nil); auto. apply H0 in H. destruct H as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hb. subst l. inversion Hc. subst a s0 l. inversion Hd. subst a x. auto. inversion H2.
  intros; split; intros. inversion H. unfold DFAacc; simpl. rewrite H5. destruct (NFAsteps_states n w (NFAinit n)) as[tl H7 H8]. apply in_map_iff. assert (Exists (equiv tl) al). apply H4. split. apply H8. intros x Hx. apply NFAinit_const; auto. exists es; split; auto. apply H7. exists is; split; auto. exists l; auto. apply Exists_exists in H9. destruct H9 as [x [Ha Hb]]. exists x; split; auto. apply ps2i_spec3. apply equiv_sym; auto. unfold DFAacc in H. simpl in H. apply in_map_iff in H. destruct H as [x [H1 H2]]. rewrite H5 in H1. destruct (NFAsteps_states n w (NFAinit n)) as [ul H6 H7]. apply ps2i_spec2 in H1. assert (Exists (equiv ul) al). apply Exists_exists. exists x. split; auto. apply equiv_sym; auto. apply H4 in H. destruct H. destruct H0 as [y [H8 H9]]. apply H6 in H8. destruct H8 as [s [Ha [l [Hb [Hc Hd]]]]]. apply NFAacc_intro with s y l; auto. assert (Exists (equiv x) al). apply Exists_exists. exists x; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. apply H7. intros y Hy. apply NFAinit_const; auto. Defined.

Definition EFA2DFA: forall e, {d|forall w, EFAacc e w <-> DFAacc d w}. intros. destruct (EFA2NFA e) as [n H]. destruct (NFA2DFA n) as [d H0]. exists d; intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition EFA_map: forall e (f:nat->nat), (forall x y, In x (EFAstates e) -> In y (EFAstates e) -> f x=f y -> x=y) -> {e'|EFAstates e'=map f (EFAstates e) & forall w, EFAacc e w <-> EFAacc e' w}. intros e. destruct e as [st tr emp ini acc Htr Hemp Hini Hacc]. simpl. intros. destruct (inv_func nat_eq_dec f st 0 H) as [g Hg1 _]. remember (fun s c=>map f (tr (g s) c)) as tr'. assert (Htr': forall c s, In s (map f st) -> incl (tr' s c) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst tr'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Htr in H4; auto. remember (fun s=>map f (emp (g s))) as emp'. assert (Hemp': forall s, In s (map f st)->incl (emp' s) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst emp'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Hemp in H4; auto. assert (Hini': forall s, In s (map f ini)->In s (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. apply in_map_iff. exists x; split; auto. assert (Hacc': incl (map f acc) (map f st)). intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply in_map_iff. exists y; split; auto.
  exists (mkEFA tr' emp' Htr' Hemp' Hini' Hacc'); auto. intros; split; intros; inversion H0. simpl in H1. simpl in H2. clear H0. apply EFAacc_intro with (f is) (f es) (map f l); simpl; auto. apply in_map_iff. exists es; split; auto. apply in_map_iff. exists is; auto. assert (H6:incl l st). apply EFAsteps_const with (s:=is) in H3; auto. subst emp' tr'. clear -H3 H6 Hg1. revert H3. revert H6. revert w. induction l; intros. inversion H3. inversion H3; simpl; auto. subst a w0 l. apply EFAsteps_empty; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. simpl in H4. apply in_map_iff. exists t. split; auto. rewrite Hg1; auto. subst a w l. apply EFAsteps_cons; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. rewrite Hg1; auto. apply in_map_iff. exists t; split; auto. inversion H4; simpl; auto. clear -H5. induction H5; simpl; auto.
  simpl in H1. simpl in H2. clear H0. apply in_map_iff in H1. destruct H1 as [es' [H6 H1]]. subst es. apply in_map_iff in H2. destruct H2 as [is' [H6 H2]]. subst is. apply EFAacc_intro with is' es' (map g l); simpl; auto. assert (H6:incl l (map f st)). apply EFAsteps_const with (s:=f is') in H3; auto. simpl. apply in_map_iff. exists is'; split; auto.  revert H3. revert H6. revert w. subst emp' tr'. clear -Hg1. induction l; intros. inversion H3. inversion H3; simpl; auto. apply EFAsteps_empty; auto. subst w0 a l. apply IHl; auto. intros x Hx; auto. simpl. simpl in H4. subst a w0 l. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Hemp in H5; auto. cut (In s (map f st)); intros. apply in_map_iff in H. destruct H as [x [H7 H8]]. subst s. rewrite Hg1; auto. apply H6; auto. apply EFAsteps_cons; auto. subst w a l. apply IHl; auto. intros x Hx; auto. simpl. subst w a l. simpl in H4. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Htr in H5; auto. cut (In s (map f st)); intros; auto. apply in_map_iff in H. destruct H as [x [H8 H7]]. subst s. rewrite Hg1; auto. inversion H4; simpl. rewrite Hg1; auto. apply Hacc in H1. clear -H1 H5 Hg1. induction l. inversion H5. simpl. inversion H5; auto. simpl. rewrite Hg1; auto. Defined.

Definition Rnil_DFA: {d|forall w, Racc Rnil w <-> DFAacc d w}. assert (Ha:forall (c:C) s, In s (0::nil) -> In 0 (0::nil)). intros. left; auto. assert (Hb:In 0 (0::nil)). left; auto. assert (Hc: incl nil (0::nil)). intros x Hx; inversion Hx. exists (mkDFA (fun _ _=>0) 0 Ha Hb Hc). intros; split; intros. inversion H. inversion H. Defined.
Definition Rchar_DFA: forall c, {d|forall w, Racc (Rchar c) w <-> DFAacc d w}. intros. remember (fun s c'=>if C_eq_dec c' c then if nat_eq_dec s 0 then 1 else 2 else 2) as tr. assert (Ha:forall c s, In s (0::1::2::nil) -> In (tr s c) (0::1::2::nil)). intros c' s H. subst tr. destruct (C_eq_dec c' c). destruct (nat_eq_dec s 0); auto. auto. assert (Hb:In 0 (0::1::2::nil)); auto. assert (Hc:incl (1::nil) (0::1::2::nil)). intros x Hx. destruct Hx. subst x; auto. destruct H. exists (mkDFA tr 0 Ha Hb Hc). intros; split; intros. inversion H. subst c0 w. unfold DFAacc. simpl. left. subst tr. destruct (C_eq_dec c c). destruct (nat_eq_dec 0 0); auto. contradict n; auto. contradict n; auto. unfold DFAacc in H. simpl in H. destruct H; [|destruct H]. destruct w as [|c' w]; simpl in H. inversion H. subst tr. destruct (C_eq_dec c' c). subst c'. destruct (nat_eq_dec 0 0). destruct w; auto. simpl in H. absurd (1=2); auto. rewrite H at 1. clear -w. destruct (C_eq_dec c0 c). induction w; simpl; auto. destruct (C_eq_dec a c); auto. induction w; simpl; auto. destruct (C_eq_dec a c); auto. contradict n; auto. absurd (1=2); auto. rewrite H at 1. clear -n. induction w; simpl; auto. destruct (C_eq_dec a c); auto. Defined.
Definition EFA_or: forall e1 e2, {eo|forall w, EFAacc eo w <-> EFAacc e1 w \/ EFAacc e2 w}. intros. destruct e1 as [st1 tr1 emp1 ini1 acc1 Htr1 Hemp1 Hini1 Hacc1]. destruct (EFA_map e2 (plus (ubound st1))) as [e3 H0 H1]. intros. apply plus_reg_l with (ubound st1); auto. destruct e3 as [st3 tr3 emp3 ini3 acc3 Htr3 Hemp3 Hini3 Hacc3]. simpl in H0. assert (H2: Disjoint st1 st3). subst st3; auto. remember (fun s c=>if in_dec nat_eq_dec s st1 then tr1 s c else tr3 s c) as tr. assert (Htr: forall c s, In s (st1++st3) -> incl (tr s c) (st1++st3)). subst tr. intros s c H x Hx. apply in_app_or in H. apply in_or_app. destruct (in_dec nat_eq_dec c st1). left. apply Htr1 in Hx; auto. apply Htr3 in Hx; auto. destruct H; auto; contradiction. remember (fun s=>if in_dec nat_eq_dec s st1 then emp1 s else emp3 s) as emp. assert (Hemp: forall s, In s (st1++st3) -> incl (emp s) (st1++st3)). intros s H x Hx. subst emp. apply in_app_or in H. apply in_or_app. destruct (in_dec nat_eq_dec s st1). apply Hemp1 in Hx; auto. apply Hemp3 in Hx; auto. destruct H; auto; contradiction. assert (Hini: incl (ini1++ini3) (st1++st3)). intros x Hx. apply in_or_app. apply in_app_or in Hx. destruct Hx; auto.  assert (Hacc: incl (acc1++acc3) (st1++st3)). intros x Hx. apply in_or_app. apply in_app_or in Hx. destruct Hx; auto. exists (mkEFA tr emp Htr Hemp Hini Hacc). intros; split; intros.
  inversion H. simpl in H3. simpl in H4. clear H. apply in_app_or in H4. destruct H4; [left|right]. assert (incl l st1). subst tr emp. apply Hini1 in H. inversion H6. subst a l. clear -H5 H Hemp1 Htr1. revert H5 H. revert w is. induction l0; intros. inversion H5. intros x Hx. destruct Hx. subst x s; auto. destruct H1. intros x Hx. destruct Hx. subst x; auto. inversion H5. subst w0 s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1); [|contradiction]. apply Hemp1 in H7; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. subst w s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1); [|contradiction]. apply Htr1 in H7. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. apply EFAacc_intro with is es l; simpl; intros; auto. apply in_app_or in H3. destruct H3; auto. apply Hacc3 in H3. contradict H3. apply Disjoint_In1 with st1; auto. apply EFAsteps_incl with (st:=st1) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. apply H1. assert (incl l st3). apply Hini3 in H. inversion H6. subst a l emp tr. clear -H H5 Hemp3 Htr3 H2. revert H5 H. revert w is. induction l0; intros. intros x Hx. destruct Hx. subst x; auto. destruct H0. inversion H5. simpl in H7. subst w0 s t l0. destruct (in_dec nat_eq_dec is st1). contradict H. apply Disjoint_In1 with st1; auto. apply Hemp3 in H7. intros x Hx. destruct Hx. subst x; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. 
  subst w s t l0. simpl in H7. destruct (in_dec nat_eq_dec is st1). contradict H. apply Disjoint_In1 with st1; auto. apply Htr3 in H7. intros x Hx. destruct Hx. subst x; auto. destruct H0. subst x; auto. apply IHl0 in H4; auto. auto. apply EFAacc_intro with is es l; simpl; intros; auto. apply in_app_or in H3. destruct H3; auto. apply Hacc1 in H3. contradict H3. apply Disjoint_In1 with st3; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr emp Htr Hemp Hini Hacc); simpl; intros; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto. contradict H8; apply Disjoint_In1 with st1; auto. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H8; apply Disjoint_In1 with st1; auto.
  destruct H. inversion H. apply EFAacc_intro with is es l; simpl; auto. apply in_or_app; auto. apply in_or_app; auto. apply EFAsteps_incl with (e1:=mkEFA tr1 emp1 Htr1 Hemp1 Hini1 Hacc1) (st:=st1); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H5; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. apply H1 in H. inversion H. apply EFAacc_intro with is es l; simpl; auto. apply in_or_app; auto. apply in_or_app; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr3 emp3 Htr3 Hemp3 Hini3 Hacc3); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H5; auto. subst emp. destruct (in_dec nat_eq_dec s st1); auto. contradict H8. eapply Disjoint_In1; eauto. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H8. eapply Disjoint_In1; eauto. Defined.
Definition EFA_cons: forall e1 e2, {eo|forall w, EFAacc eo w <-> exists w1 w2, w=w1++w2 /\ EFAacc e1 w1 /\ EFAacc e2 w2}. intros. destruct e1 as [st1 tr1 emp1 ini1 acc1 Htr1 Hemp1 Hini1 Hacc1]. destruct (EFA_map e2 (plus (ubound st1))) as [e3 H H0]. intros. eapply plus_reg_l; eauto. destruct e3 as [st3 tr3 emp3 ini3 acc3 Htr3 Hemp3 Hini3 Hacc3]. simpl in H. assert (Disjoint st1 st3). subst st3; auto. remember (fun s c=>if in_dec nat_eq_dec s st1 then tr1 s c else tr3 s c) as tr. remember (fun s=>if in_dec nat_eq_dec s st3 then emp3 s else if in_dec nat_eq_dec s acc1 then emp1 s++ini3 else emp1 s) as emp. assert (Htr: forall c s, In s (st1++st3) -> incl (tr s c) (st1++st3)). intros. intros x Hx. apply in_app_or in H2. subst tr. apply in_or_app. destruct (in_dec nat_eq_dec s st1). apply Htr1 in Hx; auto. apply Htr3 in Hx; auto. destruct H2; auto; contradiction. assert (Hemp: forall s, In s (st1++st3) -> incl (emp s) (st1++st3)). intros. intros x Hx. apply in_or_app. apply in_app_or in H2. subst emp. destruct (in_dec nat_eq_dec s st3). apply Hemp3 in Hx; auto. destruct H2; [|contradiction]. destruct (in_dec nat_eq_dec s acc1). apply in_app_or in Hx. destruct Hx. apply Hemp1 in H3; auto. apply Hini3 in H3; auto. apply Hemp1 in Hx; auto. assert (Hini: incl ini1 (st1++st3)). intros x Hx. apply in_or_app. apply Hini1 in Hx; auto. assert (Hacc: incl acc3 (st1++st3)). intros x Hx. apply in_or_app. apply Hacc3 in Hx; auto. clear H. exists (mkEFA tr emp Htr Hemp Hini Hacc). intros; split; intros.
  admit.
  destruct H as [w1 [w2 [Hw [H2 H3]]]]. subst w. apply H0 in H3. clear H0. inversion H2. clear H2. simpl in H0. simpl in H. inversion H3. clear H3. simpl in H2. simpl in H7. apply EFAacc_intro with is es0 (l++l0); simpl; auto. apply EFAsteps_app with es; auto. apply EFAsteps_incl with (st:=st1) (e1:=mkEFA tr1 emp1 Htr1 Hemp1 Hini1 Hacc1); simpl; intros; auto. apply EFAsteps_const with (s:=is) in H4; auto. subst emp. destruct (in_dec nat_eq_dec s st3). contradict i. apply Disjoint_In1 with st1; auto. destruct (in_dec nat_eq_dec s acc1). apply in_or_app; auto. auto. subst tr. destruct (in_dec nat_eq_dec s st1); auto; contradiction. inversion H9. subst a l0. apply EFAsteps_empty; simpl; auto. apply EFAsteps_incl with (st:=st3) (e1:=mkEFA tr3 emp3 Htr3 Hemp3 Hini3 Hacc3); simpl; intros; auto. apply EFAsteps_const with (s:=is0) in H8; auto. subst emp. destruct (in_dec nat_eq_dec s st3); auto; contradiction. subst tr. destruct (in_dec nat_eq_dec s st1); auto. contradict H3. apply Disjoint_In1 with st1; auto. subst emp. destruct (in_dec nat_eq_dec es st3). contradict i; apply Disjoint_In1 with st1; auto. destruct (in_dec nat_eq_dec es acc1); [|contradiction]. apply in_or_app; auto. inversion H5; simpl; auto. clear -H10. induction l; simpl; auto. Defined.


Definition RegExp_EFA: forall r, {e|forall w, Racc r w <-> EFAacc e w}. induction r. destruct Rnil_DFA as [d H]. destruct (DFA2EFA d) as [e H0]. exists e. intros; split; intros. apply H0; apply H; auto. apply H; apply H0; auto. destruct (Rchar_DFA c) as [d H]. destruct (DFA2EFA d) as [e H0]. exists e. intros; split; intros. apply H0; apply H; auto. apply H; apply H0; auto. admit.
  destruct IHr1 as [e1 H1]. destruct IHr2 as [e2 H2]. destruct (EFA_or e1 e2) as [e H]. exists e. intros; split; intros. apply H. inversion H0; [left; apply H1|right; apply H2]; auto. apply H in H0. destruct H0; [apply H1 in H0|apply H2 in H0]; auto.
  destruct IHr as [e H]. admit. Defined.

End CharType.
