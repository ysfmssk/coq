Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import ModEq.


Set Implicit Arguments.

Inductive Combi: nat -> relation (nat):= Combi_intro: forall n k a, k<=n -> fact n=fact k*fact (n-k)*a -> Combi n k a.
Hint Constructors Combi.
Theorem Combi_add: forall n k b c, Combi n (S k) b -> Combi n k c -> Combi (S n) (S k) (b+c). Proof. intros. inversion H. inversion H0.  clear -H1 H2 H7. apply Combi_intro; auto. replace (S n-S k) with (n-k); auto. rewrite mult_plus_distr_l. assert (forall k, fact (S k)=(S k)*fact k). simpl; auto. assert (fact (n-k)=(n-k)*fact (n-S k)). replace (n-k) with (S(n-S k)). simpl; auto. rewrite minus_Sn_m; auto. symmetry. rewrite H at 2. rewrite H0 at 1. replace (fact (S k)*((n-k)*fact (n-S k))*b) with ((n-k)*(fact (S k)*fact(n-S k)*b)). rewrite <- H2. rewrite <-  mult_assoc. rewrite <- mult_assoc. rewrite <- mult_assoc in H7. rewrite <- H7. rewrite <- mult_plus_distr_r. rewrite H. f_equal. rewrite <- plus_n_Sm. f_equal. rewrite plus_comm. rewrite <- le_plus_minus; auto. rewrite mult_comm. rewrite <- mult_assoc. rewrite <- mult_assoc. rewrite <- mult_assoc. f_equal. rewrite mult_comm. rewrite <- mult_assoc. apply mult_comm. Qed.
Theorem Combi_0: forall n, Combi n 0 1. Proof. intros. apply Combi_intro; auto. simpl. rewrite <- minus_n_O. rewrite mult_1_r. simpl. rewrite plus_comm; auto. Qed.
Theorem Combi_n: forall n, Combi n n 1. Proof. intros. apply Combi_intro; auto. rewrite mult_1_r. rewrite <- minus_n_n. simpl. rewrite mult_1_r; auto. Qed.
Theorem Combi_1: forall n, n<>0 -> Combi n 1 n. Proof. induction n; intros. contradict H; auto. destruct n. apply Combi_n. replace (S (S n)) with (S n+1) at 2. apply Combi_add; auto. apply Combi_0. simpl. rewrite plus_comm; auto. Qed.
Theorem Combi_unique: forall n k a b, Combi n k a -> Combi n k b -> a=b. Proof. intros. inversion H. inversion H0. apply Nat.mul_cancel_l with (fact (n-k)). apply fact_nz. apply Nat.mul_cancel_l with (fact k). apply fact_nz. repeat rewrite mult_assoc. rewrite <- H2. auto. Qed.
Theorem Combi_nz: forall n k x, Combi n k x -> x<>0. Proof. intros. inversion H. destruct x; auto. rewrite mult_0_r in H1. contradict H1. clear -n. induction n; simpl; auto. contradict IHn. destruct (fact n); auto. inversion IHn. Qed.
Definition combi_sig: forall n k, {a|Combi n k a}+{n<k}. induction n; intros. destruct (nat_eq_dec k 0); [left|right]. subst k.  exists 1. apply Combi_0. destruct k; auto. destruct k. left; exists 1. apply Combi_0. destruct (le_lt_dec k n); [left|right]; auto. apply le_lt_or_eq in l. destruct (nat_eq_dec k n). exists 1. subst k; apply Combi_n. destruct (IHn (S k)) as [[a H]|H]. destruct (IHn k) as [[b H1]|H1]. exists (a+b). apply Combi_add; auto. contradict H1. destruct l; auto. contradict H. destruct l; auto. Defined.
Definition combi n k (H:k<=n): nat. refine (match combi_sig n k with inleft (exist _ a _) => a |inright _ => _ end). contradict l; auto. Defined.
Definition combi' (n k:nat) : nat := match combi_sig n k with |inleft (exist _ a _) => a |inright _ => 0 end.
Theorem combi'_n: forall n, combi' n n = 1. Proof. intros. unfold combi'. destruct (combi_sig n n) as [[a H]|H]. apply Combi_unique with n n; auto. apply Combi_n. contradict H; auto. Qed.
Theorem combi'_0: forall n, combi' n 0 = 1. Proof. intros. unfold combi'. destruct (combi_sig n 0) as [[a H]|H]. apply Combi_unique with n 0; auto. apply Combi_0. contradict H; auto. Qed.
Theorem combi'_1: forall n, combi' n 1 = n. Proof. unfold combi'. intros. destruct (combi_sig n 1) as [[a H]|H]; auto. destruct (nat_eq_dec n 0). subst n. inversion H. inversion H0. apply Combi_unique with n 1; auto. apply Combi_1; auto. inversion H; auto. inversion H1. Qed.
Theorem combi'_odd_2: forall n, ~Divide 2 n -> Divide n (combi' n 2). Proof. intros. unfold combi'. destruct (combi_sig n 2) as [[a H0]|H0]. inversion H0. subst n0 k a0. rewrite mult_comm in H2. rewrite mult_assoc in H2. replace (fact n) with (n*(n-1)*fact (n-2)) in H2. apply Nat.mul_cancel_r in H2. replace (fact 2) with 2 in H2; auto. destruct (divmod 2 (n-1)) as [[q [r [H3 H4] _]]|H3]; [|inversion H3]. inversion H4. contradict H. rewrite le_plus_minus with 1 n; auto. subst r. rewrite H3. rewrite plus_comm. rewrite <- plus_assoc; auto. inversion H6. subst r. rewrite <- plus_n_O in H3. rewrite H3 in H2. rewrite mult_assoc in H2. apply Nat.mul_cancel_r in H2; auto. subst a; rewrite mult_comm; auto. inversion H8. auto. symmetry. replace n with (S (S (n-2))) at 1. rewrite fact_S. rewrite <- mult_assoc. f_equal. rewrite minus_Sn_m; auto. simpl. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O; auto. rewrite fact_S. f_equal. rewrite minus_Sn_m; auto. rewrite minus_Sn_m; auto. simpl. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O; auto. auto. Qed.

Theorem poly_combi: forall x y n, pow (x+y) n = fold_right plus 0 (map (fun k=>combi' n k*pow x (n - k)*pow y k) (seq 0 (S n))). Proof. induction n. simpl; auto. rewrite powS. rewrite seqS. rewrite map_app. replace (map (fun k=>combi' (S n) k*pow x (S n-k)*pow y k) (0+S n::nil)) with (pow y (S n)::nil). rewrite fold_plus_app. rewrite IHn. rewrite mult_plus_distr_r. rewrite seqS at 2. rewrite map_app. rewrite fold_plus_app. rewrite mult_plus_distr_l. rewrite plus_assoc. f_equal. replace (seq 0 (S n)) with (0::seq 1 n). simpl. rewrite mult_plus_distr_l. rewrite <- plus_assoc. f_equal. repeat rewrite mult_1_r. rewrite <- plus_n_O. f_equal. rewrite combi'_0. rewrite <- minus_n_O; auto. rewrite mult_fold_plus. rewrite mult_fold_plus. repeat rewrite mult_0_r. rewrite map_map. rewrite map_map. replace (seq 0 n) with (map (fun x=>x-1) (seq 1 n)). rewrite map_map. rewrite fold_plus_map.
  f_equal. apply map_ext_in. clear IHn. intros a Ha. apply in_seq in Ha. destruct Ha. simpl in H0. apply le_S_n in H0. destruct a. inversion H. replace (S a -1) with a. replace (combi' (S n) (S a)) with (combi' n (S a)+combi' n a). repeat rewrite mult_plus_distr_r. f_equal. rewrite mult_comm. repeat rewrite <- mult_assoc. f_equal. rewrite mult_comm. symmetry. rewrite mult_comm. rewrite <- mult_assoc. f_equal. rewrite <- powS. f_equal. rewrite minus_Sn_m; auto. rewrite mult_comm. repeat rewrite <- mult_assoc. f_equal. f_equal. rewrite powS; auto. unfold combi'. destruct (combi_sig n (S a)) as [[b H1]|H1]. destruct (combi_sig n a) as [[c H2]|H2]. destruct (combi_sig (S n) (S a)) as [[d H3]|H3]. apply Combi_unique with (S n) (S a); auto. apply Combi_add; auto. absurd (S n<n); auto. apply lt_le_trans with (S a); auto. contradict H2; auto. contradict H1; auto. simpl. rewrite <- minus_n_O; auto.
  cut (forall m, map (fun x=>x-1) (seq (S m) n)=seq m n). intros; auto. clear -n. induction n; simpl; intros; auto. rewrite <- minus_n_O. f_equal. auto. auto. simpl. repeat rewrite <- plus_n_O. f_equal. rewrite combi'_n. rewrite <- minus_n_n. rewrite pow0. auto. simpl. f_equal. rewrite combi'_n. rewrite <- minus_n_n. rewrite pow0. auto. Qed.
