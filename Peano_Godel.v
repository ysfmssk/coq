Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import ModEq.
Require Import Peano_LQ.
Require Import Peano_Func.
Require Import Peano_rfunc.

(* pairing function *)
Definition pair_lt: relation (nat*nat) := fun p q => fst p+snd p<fst q+snd q \/ fst p+snd p=fst q+snd q /\ snd p<snd q.
Theorem wf_pair_lt : well_founded pair_lt. Proof. cut (forall z x y, x+y<=z -> Acc pair_lt (x,y)). intros. intros p. destruct p as [x y]. apply H with (x+y); auto. induction z; intros. inversion H. apply plus_is_O in H1. destruct H1; subst x y. apply Acc_intro. unfold pair_lt. intros. simpl in H0. destruct H0. inversion H0. destruct H0. inversion H1.
 apply le_lt_or_eq in H. destruct H; auto. revert H. revert x. induction y; intros. rewrite <- plus_n_O in H. subst x. apply Acc_intro. intros p H. destruct p as [x y]. unfold pair_lt in H. simpl in H. destruct H. rewrite <- plus_n_O in H; auto. destruct H. inversion H0. apply Acc_intro. intros p H0.
 destruct p as [x' y']. unfold pair_lt in H0. simpl in H0. destruct H0. apply IHz. apply le_S_n. rewrite <- H; auto. destruct H0. apply le_S_n in H1. apply le_lt_or_eq in H1. destruct H1. assert (Acc pair_lt (S x, y)). apply IHy. rewrite <- H. rewrite <- plus_n_Sm; auto. inversion H2. apply H3. unfold pair_lt. right. simpl. split; auto. rewrite H0. rewrite plus_n_Sm; auto. subst y'. apply IHy. rewrite H0; auto. Qed.

Inductive Pairing: nat -> nat -> nat -> Prop:=
|Pairing00: Pairing 0 0 0
|PairingX: forall y n, Pairing 0 y n -> Pairing (S y) 0 (S n)
|PairingY: forall x y n, Pairing (S x) y n -> Pairing x (S y) (S n)
.
Hint Constructors Pairing.

Lemma div'_plus_mult: forall n x y, n<>0 -> div' x n+y = div' (x+y*n) n. Proof. intros. unfold div'. destruct (divmod n x) as [[q [r [H1 H2] H3]]|H1]; [|contradiction]. destruct (divmod n (x+y*n)) as [[q' [r' [H4 H5] H6]]|H4]; [|contradiction]. destruct (H6 (q+y) r); auto. rewrite H1. rewrite plus_comm. rewrite plus_assoc. f_equal. rewrite <- mult_plus_distr_r. f_equal; auto. Qed.
Lemma div'_mult_self: forall n x, n<>0 -> div' (x*n) n = x. Proof. intros. unfold div'. destruct (divmod n (x*n)) as [[q [r [H1 H2] H3]]|H1]; [|contradiction]. destruct (H3 x 0); auto. Qed.
Lemma div'_le: forall n x y, x<=y -> div' x n<=div' y n. Proof. intros. replace y with (x+(y-x));[|rewrite <- le_plus_minus]; auto. unfold div'. destruct (divmod n x) as [[q [r [H1 H2] H3]]|H1]; destruct (divmod n (x+(y-x))) as [[s [t [H4 H5] H6]]|H4]; auto. destruct (le_lt_dec q s); auto. rewrite H1 in H4 at 1. absurd (n<=t); auto. apply plus_le_reg_l with (s*n). rewrite <- H4. apply le_trans with (q*n). replace (s*n+n) with (S s*n). apply mult_le_compat_r; auto. simpl; auto. rewrite <- plus_assoc; auto. subst n; inversion H2. Qed.
Theorem Pairing_unique: forall x y n m, Pairing x y n -> Pairing x y m -> n=m. Proof. intros x y. remember (x,y) as p. replace x with (fst p); [|subst p]; auto. replace y with (snd p); [|subst p]; auto. clear Heqp x y. apply (Fix wf_pair_lt) with (P:=fun p=>forall n m, Pairing (fst p) (snd p) n->Pairing (fst p) (snd p) m->n=m). clear p. intros p IH. destruct p as [x y]. simpl; intros. destruct y; [destruct x|]. inversion H; inversion H0; auto.
  inversion H; inversion H0. subst y y0 n m. f_equal. apply IH with (0,x); auto. unfold pair_lt; simpl. rewrite <- plus_n_O; auto. inversion H; inversion H0. subst x0 y0 x1 y1 n m. f_equal. apply IH with (S x, y); auto. unfold pair_lt; simpl. rewrite <- plus_n_Sm; auto. Qed.
Definition pairn x y: nat := div' ((x+y)*(S(x+y))) 2 + y.
Theorem pairn_spec: forall x y, Pairing x y (pairn x y). Proof. intros. remember (x,y) as p. replace x with (fst p); [|subst p]; auto. replace y with (snd p); [|subst p]; auto. clear Heqp x y. revert p. apply (Fix wf_pair_lt). intros p IH. destruct p as [x y]. simpl. destruct y; [destruct x|]; simpl; auto. replace (pairn (S x) 0) with (S (pairn 0 x)). apply PairingX. apply (IH (0,x)). unfold pair_lt; simpl. rewrite <- plus_n_O; auto.
  unfold pairn. repeat rewrite <- plus_n_O. simpl. rewrite plus_n_Sm. rewrite div'_plus_mult; auto. f_equal. simpl. rewrite plus_comm. simpl. f_equal. f_equal. rewrite <- mult_plus_distr_l. symmetry. rewrite plus_comm. rewrite mult_n_Sm. f_equal; auto. replace (pairn x (S y)) with (S(pairn (S x) y)). apply PairingY. apply (IH (S x,y)). unfold pair_lt; simpl. rewrite <- plus_n_Sm; auto. unfold pairn. rewrite <- plus_n_Sm. f_equal. f_equal. f_equal. f_equal. rewrite <- plus_n_Sm; auto. f_equal. rewrite <- plus_n_Sm; auto. Qed.
Hint Resolve Pairing_unique pairn_spec.
Theorem pairn_le: forall x y, x+y <= pairn x y. Proof. intros. unfold pairn. apply plus_le_compat_r. apply le_trans with (div' (x*2) 2). rewrite div'_mult_self; auto. apply div'_le. destruct (nat_eq_dec x 0). subst x; auto. apply le_trans with ((x+y)*2). apply mult_le_compat_r; auto. apply mult_le_compat_l. apply le_n_S. destruct x. contradict n; auto. apply le_n_S; auto. Qed.
Theorem pairn_le_x: forall x y, x <= pairn x y. Proof. intros. apply le_trans with (x+y); auto. apply pairn_le. Qed.
Theorem pairn_le_y: forall x y, y <= pairn x y. Proof. intros. apply le_trans with (x+y); auto. apply pairn_le. Qed.
Hint Resolve  pairn_le pairn_le_x pairn_le_y.

Definition unpair_p (n:nat): nat. refine (match maxP (fun m=>div' (m*S m) 2<=n) _ (n:=S n) with |inleft (exist _ p _) => p |inright _ => _ end). intros. apply le_dec. absurd (div' (0*S 0) 2<=n); auto. Defined.
Lemma unpair_p_spec: forall n, MaxP (fun m=>div' (m*S m) 2<=n) (unpair_p n). Proof. intros. unfold unpair_p. destruct (maxP (fun m=>div' (m*S m) 2<=n)) as [[m H]|H]. apply H. intros. apply lt_not_le. apply le_trans with x; auto. destruct (nat_eq_dec x 0). subst x; inversion H0. apply le_trans with (div' (x*2) 2). rewrite div'_mult_self; auto. apply div'_le. apply mult_le_compat_l. destruct x; auto. absurd (div' (0*S 0) 2<=n); auto. Qed.
Definition sndn (n:nat) := n - div' (unpair_p n*S (unpair_p n)) 2.
Definition fstn (n:nat) := unpair_p n - sndn n.
Theorem pairn_id: forall n, pairn (fstn n) (sndn n) = n. Proof. intros. assert (MaxP (fun m=>div' (m*S m) 2<=n) (unpair_p n)). apply unpair_p_spec. unfold fstn. unfold pairn. replace (unpair_p n- sndn n+sndn n) with (unpair_p n). unfold sndn. rewrite <- le_plus_minus; auto. inversion H; auto. rewrite plus_comm. rewrite <- le_plus_minus; auto.
  unfold sndn. inversion H. subst n0. clear H. destruct (le_lt_dec (n-div' (unpair_p n*S(unpair_p n)) 2) (unpair_p n)); auto. absurd (S (unpair_p n)<=unpair_p n); auto. apply H1. replace (S(unpair_p n)*S(S(unpair_p n))) with (unpair_p n*S(unpair_p n)+(S(unpair_p n))*2). rewrite <- div'_plus_mult; auto. replace n with (div' (unpair_p n*S(unpair_p n)) 2+(n-div' (unpair_p n*S(unpair_p n)) 2)) at 4. apply plus_le_compat_l; auto. rewrite <- le_plus_minus; auto. rewrite mult_comm. rewrite <- mult_plus_distr_l. f_equal. rewrite plus_comm; auto. Qed.
Theorem unpair_p_id: forall x y, unpair_p (pairn x y) = x+y. Proof. intros. unfold pairn. assert (MaxP (fun m=>div' (m*S m) 2 <= (div' ((x+y)*S(x+y)) 2 + y)) (unpair_p (div' ((x+y)*S (x+y)) 2+y))). apply unpair_p_spec. inversion H. subst n. apply le_antisym; auto. destruct (le_lt_dec (unpair_p (div' ((x+y)*S(x+y)) 2 +y)) (x+y)); auto. contradict H0. apply lt_not_le. apply lt_le_trans with (div' ((S(x+y))*S (S(x+y))) 2). replace (S (x+y)*S (S(x+y))) with ((x+y)*S(x+y)+(S(x+y))*2). rewrite <- div'_plus_mult; auto. rewrite <- plus_n_Sm. apply le_n_S. apply plus_le_compat_l; auto. rewrite mult_comm. rewrite <- mult_plus_distr_l. f_equal. rewrite plus_comm; auto. apply div'_le. apply le_trans with (unpair_p (div' ((x+y)*S(x+y)) 2 +y)*S(S(x+y))). apply mult_le_compat_r; auto. apply mult_le_compat_l; auto. Qed.
Theorem sndn_id: forall x y, sndn (pairn x y) = y. Proof. intros. unfold sndn. rewrite unpair_p_id. unfold pairn. rewrite minus_plus; auto. Qed.
Theorem fstn_id: forall x y, fstn (pairn x y) = x. Proof. intros. unfold fstn. rewrite unpair_p_id. rewrite sndn_id. rewrite plus_comm. rewrite minus_plus; auto. Qed.
Theorem fstn_le: forall n, fstn n<=n. Proof. intros. rewrite <- pairn_id. auto. Qed.
Theorem sndn_le: forall n, sndn n<=n. Proof. intros. rewrite <- pairn_id. auto. Qed.
Theorem sndn_lt: forall n, n<>0 -> sndn n < n. Proof. intros. rewrite <- pairn_id. remember (fstn n) as x. remember (sndn n) as y. unfold pairn. remember (x+y) as p. destruct p. destruct x. destruct y. contradict H. apply Pairing_unique with 0 0; auto. rewrite Heqx at 1. rewrite Heqy. rewrite <- pairn_id; auto. rewrite <- plus_n_Sm in Heqp. inversion Heqp. inversion Heqp. apply lt_le_trans with (1+y); auto. apply plus_le_compat_r. replace 1 with (div' 2 2) at 1. apply div'_le. apply le_trans with (S(S p)); auto. simpl; auto. unfold div'. destruct (divmod 2 2) as [[q [r [H1 H2] H3]]|H1]. destruct (H3 1 0); auto. inversion H1. Qed.
Theorem fstn_lt: forall n, 2<=n -> fstn n < n. Proof. intros. rewrite <- pairn_id. remember (fstn n) as x. remember (sndn n) as y. destruct (nat_eq_dec y 0). rewrite e. subst y. unfold pairn. repeat rewrite <- plus_n_O. destruct (le_lt_dec x 1). contradict H. apply le_not_lt. rewrite <- pairn_id with n. rewrite e. rewrite <- Heqx. inversion l. unfold pairn; simpl; auto. inversion H0. simpl; auto. unfold lt. replace (S x) with (div' ((S x)*2) 2) at 1; auto. apply div'_le. rewrite mult_comm. apply mult_le_compat_r; auto. apply div'_mult_self; auto. apply lt_le_trans with (x+y); auto. destruct y. contradict n0; auto. rewrite <- plus_n_Sm; auto. Qed.
Hint Resolve pairn_id unpair_p_id sndn_id fstn_id fstn_le sndn_le sndn_lt fstn_lt.

Theorem pairn_injective1: forall x y x' y', pairn x y = pairn x' y' -> x=x'. Proof. intros. replace x with (fstn (pairn x y)); auto. replace x' with (fstn (pairn x' y')); auto. Qed.
Theorem pairn_injective2: forall x y x' y', pairn x y = pairn x' y' -> y=y'. Proof. intros. replace y with (sndn (pairn x y)); auto. replace y' with (sndn (pairn x' y')); auto. Qed.
Hint Resolve pairn_injective1 pairn_injective2.

Theorem PR2_pairn : PR2 pairn. Proof. unfold pairn. apply PR2_Comp2 with plus (fun x y=>div' ((x+y)*S(x+y)) 2) (fun _ y=>y); auto. apply PR2_Comp2 with div' (fun x y=>(x+y)*S(x+y)) (fun _ _=>2); auto. apply PR2_Comp2 with mult plus (fun x y=>S(x+y)); auto. apply PR2_Comp1 with S plus; auto. Qed.
Theorem PR1_unpair_p: PR1 unpair_p. Proof. destruct PR2_maxP with (P:=fun m n=>div' (m*S m) 2<=n) as [f [H1 H2]]. apply PRP2_Comp2; auto. apply PR2_Comp2 with div' (fun x _=>x*S x) (fun _ _=>2); auto. apply PR2_Comp2 with mult (fun x _=>x) (fun x _=>S x); auto. apply PR2_Comp1 with S (fun x _=>x); auto. apply PR1_Comp1 with pred (fun n=> (f (S n) n)); auto. apply PR1_Comp2 with f S id; auto. intros n. destruct (H2 (S n) n) as [H3 [H4 H5]]. remember (f (S n) n) as x. destruct x. absurd (div' (0*S 0) 2 <= n); auto. simpl. destruct (H5 x); auto. assert (MaxP (fun m=>div' (m*S m) 2<=n) (unpair_p n)). apply unpair_p_spec. inversion H6. subst n0. clear H6.
  apply le_antisym; auto. apply H0; auto. apply le_n_S. replace n with (pairn (fstn n) (sndn n)); auto. rewrite unpair_p_id; auto. Qed.
Hint Resolve PR2_pairn PR1_unpair_p.
Theorem PR1_sndn: PR1 sndn. Proof. unfold sndn. apply PR1_Comp2 with minus id (fun n=>div' (unpair_p n*S(unpair_p n)) 2); auto. apply PR1_Comp2 with div' (fun n=>unpair_p n*S(unpair_p n)) (fun _=>2); auto. apply PR1_Comp2 with mult unpair_p (fun n=>S (unpair_p n)); auto. apply PR1_Comp1 with S unpair_p; auto. Qed.
Theorem PR1_fstn: PR1 fstn. Proof. unfold fstn. apply PR1_Comp2 with minus unpair_p sndn; auto. apply PR1_sndn. Qed.
Hint Resolve PR1_fstn PR1_sndn.

(* list encode : (length, (0-th element, (1-st element, (2nd element, ...)))) *)
Fixpoint list_encode' (l:list nat) : nat := match l with |nil =>0 (* dummy *) |n::l' => match l' with nil => n |_::_ => pairn n (list_encode' l') end end.
Lemma list_encode'_injective: forall l m, length l=length m -> list_encode' l=list_encode' m -> l=m. Proof. induction l; intros. destruct m; auto. inversion H. destruct m. inversion H. inversion H. simpl in H0. destruct l. destruct m. subst n; auto. inversion H2. destruct m. inversion H2. f_equal. apply pairn_injective1 in H0; auto.  apply IHl; auto. apply pairn_injective2 in H0; auto. Qed.
Definition list_encode (l:list nat) : nat := pairn (length l) (list_encode' l).
Theorem list_encode_injective: forall l m, list_encode l = list_encode m -> l=m. Proof. unfold list_encode. intros. apply list_encode'_injective. apply pairn_injective1 in H; auto. apply pairn_injective2 in H; auto. Qed.

Fixpoint list_decode' (l n:nat) : list nat := match l with |O => nil |S l' => match l' with |O => n::nil |S _=>  fstn n::list_decode' l' (sndn n) end end.
Lemma list_decode'_length: forall l n, length (list_decode' l n) = l. Proof. induction l; intros; simpl; auto. destruct l; auto. simpl. f_equal. apply IHl. Qed.
Lemma list_decode'_spec: forall n l, l<>0 -> list_encode' (list_decode' l n) = n. Proof. intros n. apply (Fix lt_wf) with (P:=fun n=>forall l, l<>0->list_encode' (list_decode' l n) = n). clear n. intros n IH l H. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. replace (list_decode' l 0) with (repeat 0 l). clear IH H. induction l; simpl; auto. rewrite IHl. replace (pairn 0 0) with 0; auto. destruct l; auto. clear IH H. induction l; simpl; auto. replace (fstn 0) with 0; auto. replace (sndn 0) with 0; auto. rewrite <- IHl. destruct l; auto.
  destruct l; simpl; auto. contradict H; auto. destruct l; auto. remember (list_decode' (S l) (sndn n)) as nl. simpl. destruct nl. absurd (0=S l); auto. replace 0 with (length (A:=nat) nil); auto. rewrite Heqnl. apply list_decode'_length. rewrite Heqnl.  rewrite IH; auto. Qed.
Definition list_decode_sig : forall n, {l|list_encode l=n}+{forall l, list_encode l <> n}. refine (fun n=>if nat_eq_dec (fstn n) 0 then if nat_eq_dec (sndn n) 0 then inleft (exist _ nil _) else inright _ else inleft (exist _ (list_decode' (fstn n) (sndn n)) _)). unfold list_encode. simpl. rewrite <- e at 1. rewrite <- e0. auto. intros. contradict n0. unfold list_encode in n0. assert (length l=0). rewrite <- e. rewrite <- n0. rewrite fstn_id; auto. destruct l. simpl in n0. rewrite <- n0. auto. inversion H. unfold list_encode. rewrite list_decode'_length. rewrite list_decode'_spec; auto. Defined.
Theorem list_encode'_le: forall l x, In x l -> x <= list_encode' l. Proof. induction l; intros. inversion H. simpl. destruct l. inversion H. subst x; auto. inversion H0. destruct H. subst x; auto. apply le_trans with (list_encode' (n::l)); auto. Qed.
Theorem list_encode_lt: forall l x, In x l -> x < list_encode l. Proof. intros. unfold list_encode. apply lt_le_trans with (length l+list_encode' l); auto. destruct l. destruct H. apply le_lt_trans with (list_encode' (n::l)). apply list_encode'_le; auto. remember (list_encode' (n::l)) as y. simpl; auto. Qed.
Hint Resolve list_encode_injective list_encode'_le list_encode_lt.

Theorem MapR_unique: forall {T U:Type} (R:T->U->Prop) l m1 m2, (forall x y1 y2, In x l->R x y1->R x y2->y1=y2) -> MapR R l m1 -> MapR R l m2 -> m1=m2. Proof. induction l; simpl; intros. inversion H0; inversion H1; auto. inversion H0; inversion H1. subst a0 l0 m1 a1 l1 m2. f_equal. apply H with a; auto. apply IHl; auto. intros. apply H with x; auto. Qed.
Theorem MapR_build_fail: forall {T U:Type} (R:T->U->Prop) (S:T->Prop) l, (forall x, In x l->{y|R x y}+{S x}) -> {m|MapR R l m}+{x|In x l & S x}. induction l; intros. left; exists nil; auto. destruct IHl as [[m H]|[x H H0]]. intros; apply X; auto. destruct (X a) as [[y H0]|H0]; auto. left; exists (y::m); auto. right; exists a; auto. right; exists x; auto. Defined.

(* Godel function for each type *)
Inductive Godel_f : Func -> nat -> Prop :=
|Gf_FZero: Godel_f FZero 0
|Gf_FSucc: Godel_f FSucc 1
|Gf_FProj: forall n, Godel_f (FProj n) (pairn 2 n)
|Gf_FComp: forall f n l ns, Godel_f f n -> MapR Godel_f l ns -> Godel_f (FComp f l) (pairn 3 (pairn n (list_encode ns)))
|Gf_FRecu: forall f g n m, Godel_f f n -> Godel_f g m -> Godel_f (FRecu f g) (pairn 4 (pairn n m))
.
Hint Constructors Godel_f.
Theorem Godel_f_unique: forall f n m, Godel_f f n -> Godel_f f m -> n=m. Proof. intros f. apply (Fix (well_founded_ltof Func funcDepth)) with (P:=fun f=>forall n m, Godel_f f n->Godel_f f m->n=m). clear f. intros f IH n m H H0. inversion H; inversion H0; auto; subst f; try discriminate H3; try discriminate H5; try discriminate H7. inversion H3; subst n1; auto. inversion H7; subst f1 l0. f_equal. f_equal. apply IH with f0; auto. unfold ltof; simpl; auto. f_equal. eapply MapR_unique; [|eapply H2|]; auto. intros. apply IH with x; auto. unfold ltof; simpl. apply le_n_S. apply le_trans with (maxl (map funcDepth l)); auto. apply maxl_le; auto. apply in_map_iff; exists x; auto.
  inversion H7. subst f1 g. f_equal. f_equal. apply IH with f0; auto. unfold ltof; simpl; auto. apply IH with g0; auto. unfold ltof; simpl; auto. Qed.
Definition godel_f_sig: forall f, {n|Godel_f f n}. apply (Fix (well_founded_ltof Func funcDepth)). intros f IH. destruct f. exists 0; auto. exists 1; auto. exists (pairn 2 n); auto. destruct (IH f) as [n H]. unfold ltof. simpl; auto. destruct MapR_build with (l:=l) (R:=fun f n=>Godel_f f n) as [ns H1]. intros. apply IH. unfold ltof. simpl. apply le_n_S. apply le_trans with (maxl (map funcDepth l)); auto. apply maxl_le. apply in_map_iff. exists x; auto. exists (pairn 3 (pairn n (list_encode ns))); auto. destruct (IH f1) as [n H]. unfold ltof; simpl; auto. destruct (IH f2) as [m H0]. unfold ltof; simpl; auto. exists (pairn 4 (pairn n m)); auto. Defined.
Definition godel_f (f:Func):nat := match godel_f_sig f with exist _ n _ => n end.
Theorem godel_f_spec: forall f, Godel_f f (godel_f f). Proof. intros. unfold godel_f. destruct (godel_f_sig f); auto. Qed.
Definition godel_f_inv: forall n, {f|Godel_f f n}+{forall f,~Godel_f f n}. apply (Fix lt_wf). intros n IH. destruct (le_lt_dec 2 n) as [Hn|Hn]. destruct (nat_eq_dec (fstn n) 2). left. exists (FProj (sndn n)). rewrite <- pairn_id. rewrite e; auto. destruct (nat_eq_dec (fstn n) 3). destruct (IH (fstn (sndn n))) as [[f H0]|H0]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict Hn; subst n; auto. destruct (list_decode_sig (sndn (sndn n))) as [[l H1]|H1]. destruct (MapR_build_fail (T:=nat) (U:=Func)) with (l:=l) (R:=fun (y:nat) f=>Godel_f f y) (S:=fun y=>forall f, ~Godel_f f y) as [[fl H2]|[g H2]]. intros; apply IH; auto. apply le_lt_trans with (sndn (sndn n)). rewrite <- H1; auto. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict Hn; subst n; auto.
  left; exists (FComp f fl); auto. rewrite <- pairn_id. rewrite e. rewrite <- pairn_id with (sndn n). rewrite <- H1; auto. right. intros. intros C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (2=3); auto. rewrite <- e. rewrite <- H3; auto. assert (l=ns). apply list_encode_injective. rewrite H1. rewrite <- H5. repeat rewrite sndn_id; auto. subst ns. destruct in_MapR_2 with (R:=Godel_f) (l:=l0) (m:=l) (x:=g) as [x [H6 H7]]; auto. contradict H6; auto. absurd (4=3); auto. rewrite <- e at 2. rewrite <- H5; auto.
  right. intros g C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (2=3); auto. rewrite <- e. rewrite <- H2; auto. absurd (list_encode ns=list_encode ns); auto. replace (list_encode ns) with (sndn (sndn n)) at 2; auto. rewrite <- H4. repeat rewrite sndn_id; auto. absurd (4=3); auto. rewrite <- e at 2. rewrite <- H4; auto. right. intros f C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (2=3); auto. rewrite <- e. rewrite <- H1; auto. contradict H. replace n1 with (fstn (sndn n)); auto. rewrite <- H3. rewrite sndn_id; auto. absurd (4=3); auto. rewrite <- e at 2. rewrite <- H3; auto.
  destruct (nat_eq_dec (fstn n) 4). destruct (IH (fstn (sndn n))) as [[f H]|H]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict Hn; subst n; auto. destruct (IH (sndn (sndn n))) as [[g H1]|H1]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict Hn; subst n; auto. left; exists (FRecu f g). rewrite <- pairn_id. rewrite e. rewrite <- pairn_id with (sndn n); auto. right. intros g C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (2=4); auto. rewrite <- e. rewrite <- H2; auto. absurd (3=4); auto. rewrite <- e. rewrite <- H4; auto. contradict H2. replace m with (sndn (sndn n)); auto. rewrite <- H4. repeat rewrite sndn_id; auto.
  right. intros f C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (2=4); auto. rewrite <- e. rewrite <- H1; auto. absurd (3=4); auto. rewrite <- e. rewrite <- H3; auto. contradict H0. replace n2 with (fstn (sndn n)); auto. rewrite <- H3. rewrite sndn_id; auto. right. intros f C. inversion C. contradict Hn; subst n; auto. contradict Hn; subst n; auto. absurd (fstn n=2); auto. rewrite <- H0; auto. contradict n1. rewrite <- H2; auto. contradict n2. rewrite <- H2; auto.
  destruct (nat_eq_dec n 0). subst n. left; exists FZero; auto. assert (n=1). inversion Hn; auto. inversion H0. contradiction. inversion H2. subst n. left; exists FSucc; auto. Defined.
Theorem Godel_f_injective: forall n f g, Godel_f f n -> Godel_f g n -> f=g. Proof. intros n. apply (Fix lt_wf) with (P:=fun n=>forall f g, Godel_f f n->Godel_f g n->f=g). clear n. intros n IH f g H H0. inversion H; inversion H0; auto; subst n. inversion H4. absurd (2<=0); auto. rewrite <- H4 at 2; auto. absurd (3<=0); auto. rewrite <- H6 at 2; auto. absurd (4<=0); auto. rewrite <- H6 at 2; auto. inversion H4. absurd (2<=1); auto. rewrite <- H4 at 2; auto. absurd (3<=1); auto. rewrite <- H6 at 2; auto. absurd (4<=1); auto. rewrite <- H6 at 2; auto. absurd (2<=0); auto. rewrite H4 at 2; auto. absurd (2<=1); auto. rewrite H4 at 2; auto. f_equal. rewrite <- sndn_id with 2 n1. rewrite H4; auto. absurd (3=2); auto. rewrite <- fstn_id with 3 (pairn n1 (list_encode ns)). rewrite H6; auto.
  absurd (4=2); auto. rewrite <- fstn_id with 4 (pairn n1 m). rewrite H6; auto. absurd (3<=0); auto. rewrite H6 at 2; auto. absurd (3<=1); auto. rewrite H6 at 2; auto. absurd (2=3); auto. rewrite <- fstn_id with 3 (pairn n0 (list_encode ns)). rewrite <- H6; auto. apply pairn_injective2 in H8. assert (n1=n0). apply pairn_injective1 in H8; auto. subst n1. apply pairn_injective2 in H8. apply list_encode_injective in H8. subst ns0. f_equal. apply IH with n0; auto. apply le_lt_trans with (pairn n0 (list_encode ns)); auto. replace (pairn n0 (list_encode ns)) with (sndn (pairn 3 (pairn n0 (list_encode ns)))) at 1; auto. apply sndn_lt. intros C. absurd (3<=0); auto. rewrite <- C at 2; auto. apply MapR_sym in H2. apply MapR_sym in H6. apply MapR_unique with (R:=fun x y=>Godel_f y x) (l1:=ns); auto. intros.
  apply IH with x; auto. apply le_lt_trans with (pairn n0 (list_encode ns)). apply le_trans with (list_encode ns); auto. replace (pairn n0 (list_encode ns)) with (sndn (pairn 3 (pairn n0 (list_encode ns)))) at 1; auto. apply sndn_lt. intros C. absurd (3<=0); auto. rewrite <- C at 2; auto. absurd (4=3); auto. rewrite <- fstn_id with 4 (pairn n1 m).  rewrite H8; auto. absurd (4<=0); auto. rewrite H6 at 2; auto. absurd (4<=1); auto. rewrite H6 at 2; auto. absurd (2=4); auto. rewrite <- fstn_id with 4 (pairn n0 m); auto.  rewrite <- H6; auto. absurd (3=4); auto. rewrite <- fstn_id with 4 (pairn n0 m). rewrite <- H8; auto. apply pairn_injective2 in H8. assert (n1=n0). apply pairn_injective1 in H8; auto. subst n1. apply pairn_injective2 in H8. subst m0. f_equal.
  apply IH with n0; auto. apply le_lt_trans with (pairn n0 m); auto. replace (pairn n0 m) with (sndn (pairn 4 (pairn n0 m))) at 1; auto. apply sndn_lt. intros C. absurd (4<=0); auto. rewrite <- C at 2; auto. apply IH with m; auto. apply le_lt_trans with (pairn n0 m); auto. replace (pairn n0 m) with (sndn (pairn 4 (pairn n0 m))) at 1; auto. apply sndn_lt. intros C. absurd (4<=0); auto. rewrite <- C at 2; auto. Qed.
Theorem godel_f_injective: forall f g, godel_f f = godel_f g -> f=g. Proof. intros. unfold godel_f in H. destruct (godel_f_sig f). destruct (godel_f_sig g). subst x0. apply Godel_f_injective with x; auto. Qed.
Hint Resolve Godel_f_injective godel_f_injective godel_f_spec.

Inductive Godel_t: Term -> nat -> Prop :=
|Gt_Var: forall x, Godel_t (Var x) (pairn 0 x)
|Gt_FuncT: forall f l n ns, Godel_f f n -> MapR Godel_t l ns -> Godel_t (FuncT f l) (pairn 1 (pairn n (list_encode ns)))
.
Hint Constructors Godel_t.
Theorem Godel_t_unique: forall t n m, Godel_t t n -> Godel_t t m -> n=m. Proof. intros t. apply (Fix (well_founded_ltof Term termDepth)) with (P:=fun t=>forall n m, Godel_t t n->Godel_t t m->n=m). clear t. intros t IH n m H H0. inversion H; inversion H0; subst t. inversion H3; auto. inversion H5. inversion H5. inversion H7. subst f0 l0. f_equal. f_equal. apply Godel_f_unique with f; auto. f_equal. apply MapR_unique with (R:=Godel_t) (l0:=l); auto. intros. apply IH with x; auto. unfold ltof. simpl. apply le_n_S. apply maxl_le. apply in_map_iff. exists x; auto. Qed.
Theorem Godel_t_injective: forall n t s, Godel_t t n -> Godel_t s n -> t=s. Proof. intros n. apply (Fix lt_wf) with (P:=fun n=>forall t s,Godel_t t n->Godel_t s n->t=s). clear n. intros n IH t s H H0. inversion H; inversion H0; subst n. apply pairn_injective2 in H4. subst x0; auto. apply pairn_injective1 in H6; inversion H6. apply pairn_injective1 in H6; inversion H6. apply pairn_injective2 in H8. assert (n0=n1). apply pairn_injective1 in H8; auto. subst n1. apply pairn_injective2 in H8. apply list_encode_injective in H8. subst ns0. f_equal. apply Godel_f_injective with n0; auto. apply MapR_unique with (R:=fun x y=>Godel_t y x) (l1:=ns); auto. intros. apply IH with x; auto. apply le_lt_trans with (pairn n0 (list_encode ns)). apply le_trans with (list_encode ns); auto. replace (pairn n0 (list_encode ns)) with (sndn (pairn 1 (pairn n0 (list_encode ns)))) at 1; auto. apply sndn_lt. intros C. absurd (1<=0); auto. rewrite <- C at 2; auto. Qed.
Definition godel_t_sig: forall t, {n|Godel_t t n}. apply (Fix (well_founded_ltof Term termDepth)). intros t IH. destruct t. exists (pairn 0 n); auto. destruct (godel_f_sig f) as [n H]. destruct (MapR_build (T:=Term) (U:=nat)) with (R:=Godel_t) (l:=l). intros. apply IH. unfold ltof. simpl. apply le_n_S. apply maxl_le. apply in_map_iff. exists x; auto. exists (pairn 1 (pairn n (list_encode x))); auto. Defined.
Definition godel_t (t:Term) : nat := match godel_t_sig t with exist _ n _ => n end.
Theorem godel_t_spec: forall t, Godel_t t (godel_t t). Proof. intros. unfold godel_t. destruct (godel_t_sig t); auto. Qed.
Definition godel_t_inv: forall n, {t|Godel_t t n}+{forall t, ~Godel_t t n}. apply (Fix lt_wf). intros n IH. destruct (nat_eq_dec (fstn n) 0) as [Hn|Hn]. left. exists (Var (sndn n)). rewrite <- pairn_id. rewrite Hn; auto. destruct (nat_eq_dec (fstn n) 1) as [Hm|Hm]. destruct (godel_f_inv (fstn (sndn n))) as [[f H]|H]. destruct (list_decode_sig (sndn (sndn n))) as [[l H0]|H0]. destruct (MapR_build_fail (T:=nat) (U:=Term)) with (l:=l) (R:=fun x y=>Godel_t y x) (S:=fun y=>forall t, ~Godel_t t y) as [[ts H1]|[x H1]]. intros. apply IH. apply le_lt_trans with (list_encode l); auto. rewrite H0. apply le_lt_trans with (sndn n); auto. apply sndn_lt. intros C. subst n. absurd (1<=0); auto. left; exists (FuncT f ts). rewrite <- pairn_id. rewrite Hm. rewrite <- pairn_id with (sndn n). rewrite <- H0. apply Gt_FuncT; auto. right. intros t C. inversion C. absurd (1=0); auto. rewrite <- Hm. rewrite <- H3; auto.
  assert (l=ns). apply list_encode_injective. rewrite H0. rewrite <- H5. repeat rewrite sndn_id; auto. subst ns. apply in_MapR_2 with (x:=x) in H3; auto. destruct H3 as [s [H6 H7]]. contradict H6; auto. right. intros t C. inversion C. subst n. rewrite fstn_id in Hm. inversion Hm. absurd (list_encode ns=list_encode ns); auto. replace (list_encode ns) with (sndn (sndn n)) at 2; auto. subst n. repeat rewrite sndn_id; auto. right. intros t C. inversion C. subst n. rewrite fstn_id in Hm. inversion Hm. contradict H0. replace n0 with (fstn (sndn n)); auto. subst n. rewrite sndn_id; auto. right. intros t C. inversion C. contradict Hn. subst n; auto. contradict Hm. subst n; auto. Defined.
Theorem godel_t_injective: forall t s, godel_t t = godel_t s -> t=s. Proof. intros. unfold godel_t in H. destruct (godel_t_sig t). destruct (godel_t_sig s). subst x0. apply Godel_t_injective with x; auto. Qed.
Hint Resolve Godel_t_unique Godel_t_injective godel_t_spec godel_t_injective.

Inductive Godel_F: Formula -> nat -> Prop :=
|GF_Equal: forall t u n m, Godel_t t n -> Godel_t u m -> Godel_F (Equal t u) (pairn 0 (pairn n m))
|GF_Neg: forall f n, Godel_F f n -> Godel_F (Neg f) (pairn 1 n)
|GF_Imply: forall f g n m, Godel_F f n -> Godel_F g m -> Godel_F (Imply f g) (pairn 2 (pairn n m))
|GP_Any: forall x f n, Godel_F f n -> Godel_F (Any x f) (pairn 3 (pairn x n))
.
Hint Constructors Godel_F.
Theorem Godel_F_unique: forall f n m, Godel_F f n -> Godel_F f m -> n=m. Proof. intros. revert H0. revert m. induction H; intros. inversion H1. f_equal. f_equal. apply Godel_t_unique with t; auto. apply Godel_t_unique with u; auto. inversion H0. f_equal; auto. inversion H1. f_equal. f_equal; auto. inversion H0. f_equal. f_equal; auto. Qed. 
Theorem Godel_F_injective: forall n f g, Godel_F f n -> Godel_F g n -> f=g. Proof. intros n.  apply (Fix lt_wf) with (P:=fun n=>forall f g,Godel_F f n->Godel_F g n->f=g). clear n. intros n IH f g H H0. inversion H; inversion H0; subst n f g. apply pairn_injective2 in H8. assert (n0=n1). apply pairn_injective1 in H8; auto. subst n1. apply pairn_injective2 in H8. subst m0. f_equal. apply Godel_t_injective with n0; auto. apply Godel_t_injective with m; auto. apply pairn_injective1 in H7; inversion H7. apply pairn_injective1 in H8; inversion H8. apply pairn_injective1 in H7; inversion H7. apply pairn_injective1 in H7; inversion H7. apply pairn_injective2 in H6. subst n1. f_equal. apply IH with n0; auto. replace n0 with (sndn (pairn 1 n0)) at 1; auto. apply sndn_lt; auto. intros C. absurd (1<=0); auto. rewrite <- C at 2; auto. apply pairn_injective1 in H7; inversion H7. apply pairn_injective1 in H6; inversion H6. apply pairn_injective1 in H8; inversion H8. apply pairn_injective1 in H7; inversion H7.
  apply pairn_injective2 in H8. f_equal. apply pairn_injective1 in H8. subst n1. apply IH with n0; auto. apply le_lt_trans with (pairn n0 m); auto. replace (pairn n0 m) with (sndn (pairn 2 (pairn n0 m))) at 1; auto. apply sndn_lt. intros C. absurd (2<=0); auto. rewrite <- C at 2; auto. apply pairn_injective2 in H8. subst m0. apply IH with m; auto. apply le_lt_trans with (pairn n0 m); auto. replace (pairn n0 m) with (sndn (pairn 2 (pairn n0 m))) at 1; auto. apply sndn_lt. intros C. absurd (2<=0); auto. rewrite <- C at 2; auto. apply pairn_injective1 in H7; inversion H7. apply pairn_injective1 in H7; inversion H7. apply pairn_injective1 in H6; inversion H6. apply pairn_injective1 in H7; inversion H7. apply pairn_injective2 in H6. f_equal. apply pairn_injective1 in H6; auto. apply pairn_injective2 in H6. subst n1. apply IH with n0; auto. apply le_lt_trans with (pairn x n0); auto. replace (pairn x n0) with (sndn (pairn 3 (pairn x n0))) at 1; auto. apply sndn_lt. intros C. absurd (3<=0); auto. rewrite <- C at 2; auto. Qed.
Definition godel_F_sig: forall f, {n|Godel_F f n}. induction f. exists (pairn 0 (pairn (godel_t t) (godel_t t0))). apply GF_Equal; auto. destruct IHf as [n H]. exists (pairn 1 n); auto. destruct IHf1 as [n H]. destruct IHf2 as [m H0]. exists (pairn 2 (pairn n m)); auto. destruct IHf as [m H]. exists (pairn 3 (pairn n m)); auto. Defined.
Definition godel_F (f:Formula) := match godel_F_sig f with exist _ n _ => n end.
Theorem godel_F_spec: forall f, Godel_F f (godel_F f). Proof. intros. unfold godel_F. destruct (godel_F_sig f); auto. Qed.
Definition godel_F_inv: forall n, {f|Godel_F f n}+{forall f, ~Godel_F f n}. apply (Fix lt_wf). intros n IH. destruct (nat_eq_dec (fstn n) 0). destruct (godel_t_inv (fstn (sndn n))) as [[t H]|H]. destruct (godel_t_inv (sndn (sndn n))) as [[u H0]|H0]. left; exists (t==u); auto. rewrite <- pairn_id. rewrite e. rewrite <- pairn_id with (sndn n); auto. right. intros f C. inversion C. contradict H2. replace m with (sndn (sndn n)); auto. subst n. repeat rewrite sndn_id; auto. absurd (1=0); auto. rewrite <- e at 2. subst n; auto. absurd (2=0); auto. rewrite <- e at 2. subst n; auto. absurd (3=0); auto. rewrite <- e at 2. subst n; auto. right. intros f C. inversion C. contradict H0. replace n0 with (fstn (sndn n)); auto. subst n. rewrite sndn_id; auto. absurd (1=0); auto. rewrite <- e at 2; auto. subst n; auto. absurd (2=0); auto. rewrite <- e at 2. subst n; auto. absurd (3=0); auto. rewrite <- e at 2. subst n; auto.
  destruct (nat_eq_dec (fstn n) 1). destruct (IH (sndn n)) as [[f H]|H]. apply sndn_lt. contradict n0. subst n; auto. left; exists (!f). rewrite <- pairn_id. rewrite e; auto. right. intros f C. inversion C. absurd (0=1); auto. rewrite <- e; subst n; auto. contradict H0. replace n1 with (sndn n); subst n; auto. absurd (2=1); auto. rewrite <- e at 2; subst n; auto. absurd (3=1); auto. rewrite <- e at 2; subst n; auto. destruct (nat_eq_dec (fstn n) 2). destruct (IH (fstn (sndn n))) as [[f H]|H]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict n0; subst n; auto. destruct (IH (sndn (sndn n))) as [[g H0]|H0]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict n0; subst n; auto. left; exists (f==>g). rewrite <- pairn_id. rewrite e. rewrite <- pairn_id with (sndn n); auto. right. intros g C. inversion C. absurd (0=2); auto. rewrite <- e; subst n; auto. absurd (1=2); auto. rewrite <- e; subst n; auto. contradict H2. replace m with (sndn (sndn n)); auto. subst n. repeat rewrite sndn_id; auto. absurd (3=2); auto. rewrite <- e at 2; subst n; auto.
  right. intros f C. inversion C. absurd (0=2); auto. rewrite <- e; subst n; auto. absurd (1=2); auto. rewrite <- e; subst n; auto. contradict H0. replace n2 with (fstn (sndn n)); auto. subst n; rewrite sndn_id; auto.  absurd (3=2); auto. rewrite <- e at 2; subst n; auto. destruct (nat_eq_dec (fstn n) 3). destruct (IH (sndn (sndn n))) as [[f H]|H]. apply le_lt_trans with (sndn n); auto. apply sndn_lt. contradict n0; subst n; auto. left; exists (Any (fstn (sndn n)) f). rewrite <- pairn_id. rewrite e. replace (pairn 3 (sndn n)) with (pairn 3 (pairn (fstn (sndn n)) (sndn (sndn n)))); auto. right. intros f C. inversion C. absurd (0=3); auto. rewrite <- e; subst n; auto. absurd (1=3); auto. rewrite <- e; subst n; auto. absurd (2=3); auto. rewrite <- e; subst n; auto. contradict H0. replace n3 with (sndn (sndn n)); auto. subst n. repeat rewrite sndn_id; auto. right. intros f C. inversion C. contradict n0; subst n; auto. contradict n1; subst n; auto. contradict n2; subst n; auto. contradict n3; subst n; auto. Defined.
Theorem godel_F_injective: forall f g, godel_F f = godel_F g -> f=g. Proof. unfold godel_F. intros. destruct (godel_F_sig f). destruct (godel_F_sig g). subst x0. apply Godel_F_injective with x; auto. Qed.
Hint Resolve Godel_F_unique Godel_F_injective godel_F_spec godel_F_injective.

Inductive GSource : Set :=
|GS_T: Term -> GSource
|GS_F: Formula -> GSource
|GS_LT: list Term -> GSource
|GS_LF: list Formula -> GSource
.

Inductive Godel: GSource -> nat -> Prop :=
|Go_T: forall t n, Godel_t t n -> Godel (GS_T t) (pairn 0 n)
|Go_F: forall f n, Godel_F f n -> Godel (GS_F f) (pairn 1 n)
|Go_LT: forall tl ns, MapR Godel_t tl ns -> Godel (GS_LT tl) (pairn 2 (list_encode ns))
|Go_LF: forall fl ns, MapR Godel_F fl ns -> Godel (GS_LF fl) (pairn 3 (list_encode ns))
.
Hint Constructors Godel.

Theorem Godel_unique: forall g n m, Godel g n -> Godel g m -> n=m. Proof. intros. revert H0. revert m. induction H; intros; inversion H0; f_equal. apply Godel_t_unique with t; auto. apply Godel_F_unique with f; auto. f_equal. apply MapR_unique with (R:=Godel_t) (l:=tl); auto. intros. apply Godel_t_unique with x; auto. f_equal. apply MapR_unique with (R:=Godel_F) (l:=fl); auto. intros. apply Godel_F_unique with x; auto. Qed.
Theorem Godel_injective: forall n f g, Godel f n -> Godel g n -> f=g. Proof. intros n. apply (Fix lt_wf) with (P:=fun n=>forall f g, Godel f n->Godel g n->f=g). clear n. intros n IH f g H H0. inversion H; inversion H0; subst n; try (apply pairn_injective1 in H6; inversion H6; fail). apply pairn_injective2 in H6. subst n1. f_equal. apply Godel_t_injective with n0; auto. apply pairn_injective2 in H6; subst n1. f_equal. apply Godel_F_injective with n0; auto. f_equal. apply pairn_injective2 in H6. apply list_encode_injective in H6. subst ns0. apply MapR_unique with (R:=fun x y=>Godel_t y x) (l:=ns); auto. intros. apply Godel_t_injective with x; auto. apply pairn_injective2 in H6. apply list_encode_injective in H6. subst ns0. f_equal. apply MapR_unique with (R:=fun x y=>Godel_F y x) (l:=ns); auto. intros. apply Godel_F_injective with x; auto. Qed.
Definition godel_sig: forall g, {n|Godel g n}. induction g. exists (pairn 0 (godel_t t)); auto. exists (pairn 1 (godel_F f)); auto. exists (pairn 2 (list_encode (map godel_t l))). apply Go_LT. induction l; simpl; auto. exists (pairn 3 (list_encode (map godel_F l))). apply Go_LF. induction l; simpl; auto. Defined.
Definition godel (g:GSource) := match godel_sig g with exist _ n _ => n end.
Theorem godel_spec: forall g, Godel g (godel g). Proof. intros. unfold godel. destruct (godel_sig g); auto. Qed.
Definition godel_inv: forall n, {g|Godel g n}+{forall g, ~Godel g n}. intros. destruct (nat_eq_dec (fstn n) 0). destruct (godel_t_inv (sndn n)) as [[t H]|H]. left; exists (GS_T t). rewrite <- pairn_id. rewrite e; auto. right. intros g C. inversion C. contradict H0. replace n0 with (sndn n); auto. subst n; auto. absurd (1=0); auto. rewrite <- e at 2; subst n; auto. absurd (2=0); auto. rewrite <- e at 2; subst n; auto. absurd (3=0); auto. rewrite <- e at 2; subst n; auto. destruct (nat_eq_dec (fstn n) 1). destruct (godel_F_inv (sndn n)) as [[f H]|H]. left; exists (GS_F f). rewrite <- pairn_id. rewrite e; auto. right. intros g C. inversion C. absurd (0=1); auto. rewrite <- e; subst n; auto. contradict H0. replace n1 with (sndn n); auto. subst n; auto. absurd (2=1); auto. rewrite <- e at 2; subst n; auto. absurd (3=1); auto. rewrite <- e at 2; subst n; auto.
  destruct (nat_eq_dec (fstn n) 2). destruct (list_decode_sig (sndn n)) as [[ns H]|H]. destruct (MapR_build_fail (T:=nat) (U:=Term)) with (R:=fun x y=>Godel_t y x) (S:=fun y=>forall t, ~Godel_t t y) (l:=ns) as [[ts H0]|[x H0 H1]]. intros. apply godel_t_inv. left; exists (GS_LT ts). rewrite <- pairn_id. rewrite e. rewrite <- H; auto. right. intros g C. inversion C. absurd (0=2); auto. rewrite <- e; subst n; auto. absurd (1=2); auto. rewrite <- e; subst n; auto. assert (ns=ns0). apply list_encode_injective. rewrite H. subst n; auto. subst ns0. apply in_MapR_2 with (x:=x) in H2 as [y [H5 H6]]; auto. contradict H5; auto. absurd (3=2); auto. rewrite <- e at 2; subst n; auto. right. intros g C. inversion C. absurd (0=2); auto. rewrite <- e; subst n; auto. absurd (1=2); auto. rewrite <- e; subst n; auto. absurd (list_encode ns=list_encode ns); auto. replace (list_encode ns) with (sndn n) at 2; auto. subst n; auto. absurd (3=2); auto. rewrite <- e at 2; subst n; auto.
  destruct (nat_eq_dec (fstn n) 3). destruct (list_decode_sig (sndn n)) as [[ns H]|H]. destruct (MapR_build_fail (T:=nat) (U:=Formula)) with (R:=fun x y=>Godel_F y x) (S:=fun y=>forall f, ~Godel_F f y) (l:=ns) as [[fs H0]|[x H0 H1]]. intros. apply godel_F_inv. left; exists (GS_LF fs). rewrite <- pairn_id. rewrite e. rewrite <- H; auto. right. intros g C. inversion C. absurd (0=3); auto. rewrite <- e; subst n; auto. absurd (1=3); auto. rewrite <- e; subst n; auto. absurd (2=3); auto. rewrite <- e; subst n; auto. assert (ns=ns0). apply list_encode_injective. rewrite H. subst n; auto. subst ns0. apply in_MapR_2 with (x:=x) in H2 as [y [H5 H6]]; auto. contradict H5; auto. right; intros g C. inversion C.  absurd (0=3); auto. rewrite <- e; subst n; auto.  absurd (1=3); auto. rewrite <- e; subst n; auto. absurd (2=3); auto. rewrite <- e; subst n; auto. absurd (list_encode ns=list_encode ns); auto. replace (list_encode ns) with (sndn n) at 2; auto. subst n; auto. right. intros g C. inversion C. contradict n0; subst n; auto. contradict n1; subst n; auto. contradict n2; subst n; auto. contradict n3; subst n; auto. Defined.
Theorem godel_injective: forall f g, godel f=godel g->f=g. Proof. unfold godel. intros. destruct (godel_sig f). destruct (godel_sig g). subst x0. apply Godel_injective with x; auto. Qed.
Hint Resolve Godel_unique Godel_injective godel_spec godel_injective.

