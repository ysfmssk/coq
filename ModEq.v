Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.

Require Import list_util.

Set Implicit Arguments.

Fixpoint pow n a:= match a with |0 => 1 |S a' => n * pow n a' end.
Theorem pow0: forall n, pow n 0 = 1. Proof. simpl; auto. Qed.
Theorem pow0n: forall n, n<>0->pow 0 n=0. Proof. intros. destruct n. contradict H; auto. auto. Qed.
Theorem powS: forall n a, pow n (S a) = n * pow n a. Proof. intros; simpl; auto. Qed.
Theorem pow_plus: forall n a b, pow n (a+b) = pow n a* pow n b. Proof. induction a; simpl; intros; auto. rewrite <- mult_assoc; f_equal; auto. Qed.
Theorem pow_mult: forall p a b, pow p (a*b) = pow (pow p b) a. Proof. induction a; intros; simpl; auto. rewrite pow_plus. f_equal; auto. Qed.
Theorem pow_mult2: forall a b k, pow (a*b) k = pow a k*pow b k. Proof. induction k; simpl; auto. repeat rewrite <- mult_assoc. f_equal. rewrite IHk. repeat rewrite mult_assoc. f_equal; auto. apply mult_comm. Qed.
Theorem pow_nz: forall p n, p<>0 -> pow p n <> 0. Proof. induction n; simpl; intros; auto. intros C. apply mult_is_O in C. destruct C; try contradiction. apply IHn in H. contradiction. Qed.
Theorem seqS: forall n m, seq n (S m)=seq n m++(n+m::nil). Proof. intros n m. revert n. induction m. simpl; intros. rewrite <- plus_n_O; auto. intros. simpl. f_equal. replace (n+S m) with ((S n)+m). rewrite <- IHm. auto. rewrite <- plus_n_Sm; auto. Qed.
Theorem fold_mult_app: forall a l m, fold_right mult a (l++m) = fold_right mult 1 l * fold_right mult a m. Proof. induction l; simpl; intros; auto. rewrite <- mult_assoc. f_equal; auto. Qed.
Theorem fact_fold: forall n, fact n = fold_right mult 1 (seq 1 n). Proof. induction n. simpl; auto. rewrite seqS. rewrite fold_mult_app. simpl. rewrite mult_1_r. rewrite <- IHn. rewrite <- mult_n_Sm. rewrite plus_comm. f_equal; auto. apply mult_comm. Qed.
Lemma fact_nz: forall n, fact n<>0. Proof. induction n; simpl; auto. contradict IHn. destruct (fact n); auto. simpl in IHn. inversion IHn. Qed.

Hint Resolve pow0 pow0n powS pow_plus pow_mult pow_mult2 pow_nz seqS fold_mult_app fact_fold fact_nz.
Hint Resolve le_plus_l le_plus_r le_n_S le_S_n le_not_lt lt_not_le lt_le_weak plus_assoc plus_comm mult_assoc mult_comm mult_plus_distr_r mult_plus_distr_l seq_NoDup.
Definition nat_eq_dec: forall x y:nat, {x=y}+{x<>y}. induction x; intros; destruct y. left; auto. right; auto. right; auto. destruct (IHx y); [subst y; left|right]; auto. Defined.

Inductive DiffN: nat-> relation nat:= DiffN_0: forall x, DiffN 0 x x|DiffN_S: forall n x y, DiffN n x y -> DiffN (S n) x (S y).
Definition ModEq (n:nat): relation nat := clos_refl_sym_trans nat (DiffN n).
Hint Constructors DiffN.

Theorem plus_DiffN: forall x y, DiffN x y (x+y). Proof. induction x; intros; simpl; auto. Qed.
Theorem DiffN_plus: forall n x y, DiffN n x y -> y=n+x. Proof. intros. induction H; simpl; auto. Qed.
Hint Resolve plus_DiffN DiffN_plus.

Theorem ModEq_refl: forall n x, ModEq n x x. Proof. intros. apply rst_refl. Qed.
Theorem ModEq_sym: forall n x y, ModEq n x y -> ModEq n y x. Proof. intros. apply rst_sym. auto. Qed.
Theorem ModEq_trans: forall n x y z, ModEq n x y -> ModEq n y z -> ModEq n x z. Proof. intros. apply rst_trans with y; auto. Qed.
Theorem DiffN_ModEq: forall n x y, DiffN n x y -> ModEq n x y. Proof. intros. apply rst_step; auto. Qed.
Theorem ModEq0_eq: forall x y, ModEq 0 x y -> x=y. Proof. intros. induction H; auto. apply DiffN_plus in H. subst y; auto. rewrite IHclos_refl_sym_trans1; auto. Qed.
Theorem ModEq1: forall x y, ModEq 1 x y. Proof. cut (forall n, ModEq 1 0 n). intros. apply ModEq_trans with 0; auto. apply ModEq_sym; auto. induction n. apply ModEq_refl. apply ModEq_trans with n; auto. apply rst_step; auto. Qed.
Hint Resolve ModEq_refl ModEq_sym ModEq_trans DiffN_ModEq ModEq0_eq ModEq1.

Theorem multN_ModEq: forall n q r, ModEq n r (q*n+r). Proof. induction q; simpl; intros; auto. apply ModEq_trans with (q*n+r); auto. rewrite <- plus_assoc. auto. Qed.
Theorem ModEq_multN_ex: forall n x y, ModEq n x y -> exists q, y=q*n+x \/ x=q*n+y. Proof. intros. induction H. exists 1. left. rewrite mult_1_l. auto. exists 0; left; auto. destruct (IHclos_refl_sym_trans) as [q [H1|H1]];exists q; auto. destruct IHclos_refl_sym_trans1 as [p [H1|H1]]; destruct IHclos_refl_sym_trans2 as [q [H2|H2]].
  subst y z. exists (q+p); left. rewrite plus_assoc; f_equal. symmetry; auto. subst y. destruct (le_lt_dec p q). exists (q-p); right. apply plus_reg_l with (p*n). rewrite H2. rewrite plus_assoc; f_equal. replace (q*n) with ((p+(q-p))*n). auto. f_equal. symmetry; apply le_plus_minus; auto. exists (p-q); left. apply plus_reg_l with (q*n). rewrite <- H2. rewrite plus_assoc; f_equal. rewrite <- mult_plus_distr_r; f_equal. apply le_plus_minus; auto.
  subst x z. destruct (le_lt_dec p q). exists (q-p); left. rewrite plus_assoc; f_equal. rewrite <- mult_plus_distr_r; f_equal. rewrite plus_comm; apply le_plus_minus; auto. exists (p-q); right. rewrite plus_assoc; f_equal. rewrite <- mult_plus_distr_r; f_equal. rewrite plus_comm; apply le_plus_minus; auto. subst x y. exists (p+q); right. rewrite plus_assoc; f_equal. symmetry; auto. Qed.
Hint Resolve multN_ModEq ModEq_multN_ex.

Definition divmod: forall n x, {q:nat & {r|x=q*n+r /\ r<n & forall q' r', x=q'*n+r' -> r'<n -> q'=q /\ r'=r}}+{n=0}. intros n. apply (Fix lt_wf). intros x IH. destruct (nat_eq_dec n 0) as [Hn|Hn]; [right|left]; auto. destruct (le_lt_dec n x) as [Hx|Hx]. assert (H:x=n+(x-n)). apply le_plus_minus; auto. destruct (IH (x-n)) as [[q [r [H1 H2] H3]]|H1].
  rewrite H at 2. generalize (x-n) as a; intros. destruct n. contradict Hn; auto. simpl; auto. exists (S q); exists r. split; auto. rewrite H. simpl. rewrite <- plus_assoc. f_equal; auto. intros. destruct q'. simpl in H0. contradict H4. rewrite <- H0; auto. destruct (H3 q' r'); auto. apply plus_reg_l with n. rewrite <- H. simpl in H0. rewrite plus_assoc; auto.
  contradiction. exists 0; exists x. simpl; auto. intros. destruct q'. simpl in H; auto. contradict Hx. subst x. simpl. rewrite <- plus_assoc; auto. Defined.
Definition modN n (nz:n<>0) x := match divmod n x with |inleft (existT _ _ (exist2 _ _ r _ _)) => r |inright H => False_rec nat (nz H) end.

Theorem modN_le: forall n (nz:n<>0) x, modN nz x < n. Proof. intros. unfold modN. destruct (divmod n x) as [[q [r [H1 H2] _]]|H1]; [auto|contradiction]. Qed.
Theorem modN_le_eq: forall n (nz:n<>0) x, x<n -> modN nz x=x. Proof. intros. unfold modN. destruct (divmod n x) as [[q [r [H1 H2] _]]|H1]; [|contradiction]. destruct q; auto. contradict H; subst x; simpl. rewrite <- plus_assoc; auto. Qed.
Theorem modN_ModEq: forall n (nz:n<>0) x, ModEq n x (modN nz x). Proof. intros. unfold modN. destruct (divmod n x) as [[q [r [H1 H2] _]]|H1]; [|contradiction]. subst x; auto. Qed.
Hint Resolve modN_ModEq modN_le modN_le_eq.
Theorem modN_eq__ModEq: forall n (nz:n<>0) x y, modN nz x=modN nz y -> ModEq n x y. Proof. intros. apply ModEq_trans with (modN nz x); auto. rewrite H; auto. Qed.
Theorem ModEq__modN_eq: forall n (nz:n<>0) x y, ModEq n x y -> modN nz x=modN nz y. Proof. intros. cut (ModEq n (modN nz x) (modN nz y)); intros. destruct (ModEq_multN_ex H0). destruct x0. simpl in H1. destruct H1; auto. simpl in H1. destruct H1. rewrite <- plus_assoc in H1. absurd (modN nz y < n); auto. rewrite H1; auto. rewrite <- plus_assoc in H1. absurd (n<= modN nz x); auto. rewrite H1; auto. apply ModEq_trans with x; auto. apply ModEq_trans with y; auto. Qed.
Definition ModEq_multN: forall n x y, ModEq n x y -> {q|y=q*n+x}+{q|x=q*n+y}. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. left; exists 0. simpl. subst n. auto. destruct (divmod n x) as [[q [r [H1 H2] _]]|H1]; [|contradiction]. destruct (divmod n y) as [[s [t [H3 H4] _]]|H3]; [|contradiction]. assert (r=t). cut (ModEq n r t). intros. destruct (ModEq_multN_ex H0) as [z [H5|H6]]. subst t. destruct z; auto. contradict H4; simpl; rewrite <- plus_assoc; auto. subst r. destruct z; auto. contradict H2; simpl; rewrite <- plus_assoc; auto.
  subst x y. apply ModEq_trans with (q*n+r); auto. apply ModEq_trans with (s*n+t); auto. subst t x y. destruct (le_lt_dec q s). left; exists (s-q). rewrite plus_assoc; f_equal. rewrite <- mult_plus_distr_r; f_equal. rewrite plus_comm; apply le_plus_minus; auto. right; exists (q-s). rewrite plus_assoc; f_equal. rewrite <- mult_plus_distr_r; f_equal. rewrite plus_comm; apply le_plus_minus; auto. Qed.
Theorem ModEq_le_eq: forall n x y, ModEq n x y -> x<n -> y<n -> x=y. Proof. intros. destruct (nat_eq_dec n 0) as [nz|nz]. subst n; inversion H0. rewrite <- modN_le_eq with n nz x; auto. rewrite <- modN_le_eq with n nz y; auto. apply ModEq__modN_eq; auto. Qed.
Hint Resolve modN_eq__ModEq ModEq__modN_eq ModEq_le_eq.

Theorem ModEq_plus': forall n a b c, ModEq n a b -> ModEq n (c+a) (c+b). Proof. intros. destruct (ModEq_multN H) as [[q H1]|[q H1]]. subst b. replace (c+(q*n+a)) with (q*n+(c+a)); auto. repeat rewrite plus_assoc; f_equal. auto. subst a. replace (c+(q*n+b)) with (q*n+(c+b)); auto. repeat rewrite plus_assoc; f_equal; auto. Qed.
Theorem ModEq_plus: forall n a b c d, ModEq n a b -> ModEq n c d -> ModEq n (a+c) (b+d). Proof. intros. apply ModEq_trans with (a+d). apply ModEq_plus'; auto. rewrite plus_comm. replace (b+d) with (d+b); auto. apply ModEq_plus'; auto. Qed.
Theorem ModEq_mult': forall n a b c, ModEq n a b -> ModEq n (c*a) (c*b). Proof. induction c; intros; simpl; auto. apply ModEq_plus; auto. Qed.
Theorem ModEq_mult: forall n a b c d, ModEq n a b -> ModEq n c d -> ModEq n (a*c) (b*d). Proof. intros. apply ModEq_trans with (a*d); auto. apply ModEq_mult'; auto. rewrite mult_comm. replace (b*d) with (d*b); auto. apply ModEq_mult'; auto. Qed.
Theorem ModEq_minus: forall n a b c, ModEq n (c+a) (c+b) -> ModEq n a b. Proof. intros. destruct (ModEq_multN H) as [[q H1]|[q H1]]. replace (q*n+(c+a)) with (c+(q*n+a)) in H1. apply plus_reg_l in H1. subst b; auto. rewrite plus_comm. rewrite <- plus_assoc; f_equal; auto. replace (q*n+(c+b)) with (c+(q*n+b)) in H1. apply plus_reg_l in H1. subst a; auto. rewrite plus_comm. rewrite <- plus_assoc; f_equal; auto. Qed.
Hint Resolve ModEq_plus' ModEq_plus ModEq_mult' ModEq_mult ModEq_minus.

Definition ModEq_dec: forall n x y,{ModEq n x y}+{~ModEq n x y}. intros. destruct (nat_eq_dec n 0). subst n. destruct (nat_eq_dec x y); [subst y; left|right]; auto. destruct (nat_eq_dec (modN n0 x) (modN n0 y)); [left|right]; auto. apply modN_eq__ModEq with (nz:=n0); auto. Defined.
Definition Divide: relation nat:= fun n => ModEq n 0.
Theorem multN_Divide: forall n q, Divide n (q*n). Proof. intros. replace (q*n) with (q*n+0); auto. apply ModEq_sym. auto. Qed.
Definition Divide_multN: forall n x, Divide n x -> {q|x=q*n}. intros. destruct (ModEq_multN H) as [[q H1]|[q H1]]. exists q; rewrite <- plus_n_O in H1; auto. exists 0; auto. destruct x; auto. rewrite <- plus_n_Sm in H1. inversion H1. Defined.
Theorem Divide_trans: forall x y z, Divide x y -> Divide y z -> Divide x z. Proof. intros. destruct (Divide_multN H) as [a H1]. destruct (Divide_multN H0) as [b H2]. subst y z. rewrite mult_assoc; auto. apply multN_Divide. Qed.
Theorem Divide_le_or_0: forall x y, Divide x y -> x<=y \/ y=0. Proof. intros. destruct (Divide_multN H) as [q H1]. subst y. destruct q; simpl; auto. Qed.
Theorem Divide_le: forall x y, Divide x y -> y<>0 -> x<=y. Proof. intros. destruct (Divide_le_or_0 H); auto. contradiction. Qed.
Theorem Divide_n0: forall n, Divide n 0. Proof. intros. replace 0 with (0*n); auto. apply multN_Divide. Qed.
Theorem Divide_refl: forall n, Divide n n. Proof. intros. replace n with (1*n) at 2; auto. apply multN_Divide. rewrite mult_1_l; auto. Qed.
Theorem Divide_antisym: forall x y, Divide x y -> Divide y x -> x=y. Proof. intros. destruct (Divide_le_or_0 H). destruct (Divide_le_or_0 H0). apply le_antisym; auto. subst x. destruct (Divide_multN H). subst y; auto. subst y. destruct (Divide_multN H0). subst x; auto. Qed.
Theorem Divide1: forall x, Divide 1 x. Proof. intros. replace x with (x*1). apply multN_Divide. auto. rewrite mult_1_r; auto. Qed.
Theorem Divide_plus: forall n x y, Divide n x -> Divide n y -> Divide n (x+y). Proof. intros. unfold Divide. replace 0 with (0+0); auto. Qed.
Theorem Divide_minus: forall n x y, Divide n x -> Divide n (x+y) -> Divide n y. Proof. intros. unfold Divide. apply ModEq_minus with x; auto. rewrite <- plus_n_O; auto. apply ModEq_trans with 0; auto. Qed.
Theorem Divide_mult: forall n x y, Divide x y -> Divide (n*x) (n*y). Proof. intros. destruct (Divide_multN H) as [m H0]. subst y. replace (n*(m*x)) with (m*(n*x)). apply multN_Divide. rewrite mult_comm. rewrite <- mult_assoc; auto. Qed.
Theorem Divide_div: forall n x y, n<>0 -> Divide (n*x) (n*y) -> Divide x y. Proof. intros. destruct (Divide_multN H0) as [m H1]. symmetry in H1. rewrite mult_comm in H1. rewrite <- mult_assoc in H1. apply Nat.mul_cancel_l in H1; auto. subst y; rewrite mult_comm; apply multN_Divide. Qed.
Theorem fact_Divide: forall n d, d<=n -> d<>0 -> Divide d (fact n). Proof. intros. induction H. destruct d. contradict H0; auto. replace (fact (S d)) with ((S d)*fact d); auto. rewrite mult_comm; auto. apply multN_Divide. apply Divide_trans with (fact m); auto. simpl. apply Divide_plus. apply Divide_refl. apply multN_Divide. Qed.
Hint Resolve multN_Divide Divide_trans Divide_le_or_0 Divide_le Divide_n0 Divide_refl Divide_antisym Divide1 Divide_plus Divide_minus Divide_mult Divide_div fact_Divide.
Definition Divide_dec: forall x y, {Divide x y}+{~Divide x y}. intros. destruct (ModEq_dec x 0 y); [left|right]; auto. Defined.

Inductive MaxP (P:nat->Prop) : nat->Prop := MaxP_intro: forall n, P n -> (forall m, P m -> m<=n) -> MaxP P n.
Inductive MinP (P:nat->Prop) : nat->Prop := MinP_intro: forall n, P n -> (forall m, P m -> n<=m) -> MinP P n.
Inductive PnumN (P:nat->Prop) : relation nat := PnumN0: PnumN P 0 0 |PnumN_P: forall n m, PnumN P n m -> P n -> PnumN P (S n) (S m) |PnumN_NP: forall n m, PnumN P n m -> ~P n -> PnumN P (S n) m.
Inductive Pnum (P:nat->Prop) (n:nat): Prop:= Pnum_intro: forall m, (forall m', m<=m' -> PnumN P m' n) -> Pnum P n.
Hint Constructors MaxP MinP PnumN Pnum.

Definition minP: forall P n (P_dec:forall x, x<n->{P x}+{~P x}), {m|MinP P m}+{forall x, x<n->~P x}. induction n; intros. right. intros. inversion H. destruct IHn as [[m H]|H]. intros. apply P_dec; auto. left; exists m; auto. destruct (P_dec n); [|left|right]; auto. exists n. apply MinP_intro; auto. intros. destruct (le_lt_dec n m); auto. absurd (P m); auto. intros. apply le_S_n in H0. apply le_lt_or_eq in H0. destruct H0; [|subst n]; auto. Qed.
Definition maxP: forall P n (P_dec:forall x, x<n->{P x}+{~P x}), {m|(forall x, n<=x->~P x)->MaxP P m}+{forall x, x<n->~P x}. induction n; intros. right. intros. inversion H. destruct (P_dec n); auto. left. exists n. intros. apply MaxP_intro; auto. intros. destruct (le_lt_dec m n); auto. contradict H0; auto. destruct IHn as [[m H]|H]. intros; apply P_dec; auto. left; exists m. intros. apply H; intros. destruct (le_lt_or_eq n x H1); auto. subst x; auto. right; intros. destruct (le_lt_or_eq x n); auto. subst n; auto. Defined.
Definition pnumN: forall P n (P_dec:forall x, x<n->{P x}+{~P x}), {m|PnumN P n m}. induction n; intros. exists 0; auto. destruct IHn as [m Hm]. intros; apply P_dec; auto. destruct (P_dec n); auto. exists  (S m); auto. exists m; auto. Defined.
Definition findP: forall P n (P_dec:forall x, x<n->{P x}+{~P x}), {m|P m & m < n}+{forall x, x<n->~P x}. induction n; intros. right. intros. inversion H. destruct IHn as [[m H1 H2]|H1]. intros; apply P_dec; auto. left; exists m; auto. destruct (P_dec n); [|left|right]; auto. exists n; auto. intros. apply le_S_n in H. apply le_lt_or_eq in H. destruct H; auto. subst n; auto. Defined.

Theorem PnumN_unique: forall P n m m', PnumN P n m -> PnumN P n m' -> m=m'. Proof. intros. revert m' H0. induction H; intros. inversion H0; auto. inversion H1; try contradiction. f_equal; auto. inversion H1; try contradiction; auto. Qed.
Theorem PnumN_incr: forall P n m n' m', PnumN P n m -> PnumN P n' m' -> n<=n' -> m<=m'. Proof. intros. revert m m' H H0. induction H1; intros. replace m' with m; auto. apply PnumN_unique with P n; auto. inversion H0. subst n0 m'. auto. auto. Qed.
Lemma PnumN_lt: forall P Q n a b, PnumN P n a -> PnumN Q n b -> a < b -> exists x, x<n /\ ~P x /\ Q x. Proof. induction n; intros. inversion H0. subst b. inversion H1. inversion H; inversion H0. subst n0 a n1 b. destruct (IHn m m0) as [x [Ha [Hb Hc]]]; auto. exists x; auto. subst n0 a n1 b. destruct (IHn m m0) as [x [Ha [Hb Hc]]]; auto. exists x; auto. exists n; auto. subst n0 m n1 m0. destruct (IHn a b) as [x [Ha [Hb Hc]]]; auto. exists x; auto. Qed.
Lemma PnumN_ex: forall P n m, PnumN P n m -> m<>0 <-> exists x, x<n /\ P x. Proof. intros. induction H. split; intros. contradict H; auto. destruct H as [x [H1 H2]]. inversion H1. split; intros. exists n; auto. discriminate. split; intros. apply IHPnumN in H1. destruct H1 as [x [H1 H2]]. exists x; auto. apply IHPnumN. destruct H1 as [x [H1 H2]]. exists x. inversion H1; auto. subst x; contradiction. Qed.
Lemma PnumN_or: forall P Q n a b c, PnumN P n a -> PnumN Q n b -> PnumN (fun n =>P n\/Q n) n c -> c<=a+b. Proof. induction n; intros. inversion H; inversion H0; inversion H1; auto. inversion H; inversion H0; inversion H1; simpl; auto. rewrite <- plus_n_Sm; auto. contradict H12; auto. rewrite <- plus_n_Sm; auto. contradict H12; auto. destruct H12; contradiction. Qed.
Lemma PnumN_equiv: forall P Q n m, (forall x, x<n-> P x<->Q x) -> PnumN P n m -> PnumN Q n m. Proof. intros. induction H0; auto. apply PnumN_P; auto. apply H; auto. apply PnumN_NP; auto. contradict H1; apply H; auto. Qed.
Lemma PnumN_one: forall (P:nat->Prop) n x, x<n -> P x -> (forall y, y<n -> P y -> y=x) -> PnumN P n 1. Proof. intros P n x H. induction H; simpl; intros. apply PnumN_P; auto. cut (forall y, y<x->~P y). intros. clear H0 H. induction x; auto. apply PnumN_NP; auto. intros. intros C. assert (y=x); auto. contradict H1; subst y; auto. apply PnumN_NP; auto. contradict H. apply H1 in H; auto. subst x; auto. Qed.
Lemma PnumN_zero: forall (P:nat->Prop) n, (forall x, x<n->~P x) -> PnumN P n 0. Proof. induction n; intros; auto. apply PnumN_NP; auto. Qed.
Theorem Pnum_unique: forall P n m, Pnum P n -> Pnum P m -> n=m. Proof. intros. inversion H; inversion H0. apply PnumN_unique with P (max m0 m1). apply H1. apply Nat.le_max_l. apply H2. apply Nat.le_max_r. Qed.
Hint Resolve PnumN_unique PnumN_incr PnumN_lt PnumN_ex PnumN_or PnumN_equiv PnumN_one PnumN_zero Pnum_unique.


Definition GCD (g x y:nat): Prop := MaxP (fun d=>Divide d x/\Divide d y) g.
Definition Coprime: relation nat := GCD 1.

Theorem GCD_unique: forall x y g g', GCD g x y -> GCD g' x y -> g=g'. Proof. intros. inversion H. inversion H0. subst n n0. destruct H1. destruct H4. apply le_antisym; auto. Qed.
Theorem GCD_sym: forall x y g, GCD g x y -> GCD g y x. Proof. intros. inversion H. destruct H0. apply MaxP_intro; auto. intros. destruct H4. auto. Qed.
Theorem Coprime_sym:forall x y, Coprime x y -> Coprime y x. Proof. intros. apply GCD_sym; auto. Qed.
Theorem GCD_00: forall g, ~GCD g 0 0. Proof. intros. intros C. inversion C. absurd (S g<=g); auto. Qed.
Theorem GCD_0n: forall n, n<>0 -> GCD n 0 n. Proof. intros. apply MaxP_intro; auto. intros. destruct H0. auto. Qed.
Theorem GCD_1n: forall n, GCD 1 1 n. Proof. intros. apply MaxP_intro; auto. intros. destruct H; auto. Qed.
Theorem GCD_refl: forall n, n<>0 -> GCD n n n. Proof. intros. apply MaxP_intro; auto. intros. destruct H0; auto. Qed.
Theorem GCD_le: forall n x y, GCD n x y -> 1<=n. Proof. intros. inversion H. auto. Qed.
Definition gcd_sig: forall x y, {g|GCD g x y}+{x=0/\y=0}. intros. destruct (nat_eq_dec x 0). subst x. destruct (nat_eq_dec y 0); [right|left; exists y]; auto. apply GCD_0n; auto. destruct maxP with (P:=fun g=>Divide g x/\Divide g y) (n:=S x). intros. destruct (Divide_dec x0 x); [|right]. destruct (Divide_dec x0 y); [left|right]; auto. contradict n0; destruct n0; auto. contradict n0; destruct n0; auto. destruct s as [m H]. left; exists m. apply H. intros. intros C. destruct C. contradict H0; auto. absurd (Divide 1 x/\Divide 1 y); auto. Defined.
Definition gcd_sig': forall n (nz:n<>0) m, {g|GCD g n m}. intros. destruct (gcd_sig n m) as [[g H]|H]. exists g; auto. destruct H; contradiction. Defined.
Definition gcd n (nz:n<>0) m: nat:= match gcd_sig' nz m with exist _ g _ => g end.
Definition Coprime_dec: forall n m, {Coprime n m}+{~Coprime n m}. intros. destruct (gcd_sig n m) as [[g Hg]|Hg]. destruct (nat_eq_dec g 1); [subst g; left|right]; auto. contradict n0. eapply GCD_unique; eauto. destruct Hg; subst n m. right. apply GCD_00. Defined.
Hint Unfold Coprime.
Hint Resolve GCD_unique GCD_sym Coprime_sym GCD_00 GCD_0n GCD_1n GCD_refl GCD_le.


Theorem GCD_mod: forall g x y q, GCD g x (q*x+y) -> GCD g x y. Proof. intros. inversion H. destruct H0. apply MaxP_intro. split; auto. apply Divide_minus with (q*x); auto. apply Divide_trans with x; auto. intros. apply H1. destruct H4. split; auto. apply Divide_plus; auto. apply Divide_trans with x; auto. Qed.
Theorem GCD_multN: forall g x y q, GCD g x y -> GCD g x (q*x+y). Proof. intros. inversion H. destruct H0. apply MaxP_intro. split; auto. apply Divide_plus; auto. apply Divide_trans with x; auto. intros. destruct H4. apply H1. split; auto. apply Divide_minus with (q*x); auto. apply Divide_trans with x; auto. Qed.
Theorem GCD_ModEq: forall g x y z, ModEq x y z -> GCD g x y -> GCD g x z. Proof. intros. apply ModEq_multN in H as [[q H1]|[q H1]]. subst z. apply GCD_multN; auto. subst y. apply GCD_mod with q; auto. Qed.
Hint Resolve GCD_mod GCD_multN GCD_ModEq.

Definition bezour': forall p g, fst p<>0->GCD g (fst p) (snd p) ->{x:nat & {y|x*fst p=y*snd p+g}}. intros p. apply (Fix (well_founded_ltof (nat*nat) (fun p=>min (fst p) (snd p)))) with (P:=fun p=>forall g, fst p<>0->GCD g (fst p)(snd p)->{x:nat&{y|x*fst p=y*snd p+g}}). clear p. intros p IH. destruct p as [n m]. simpl. intros. destruct (nat_eq_dec m 0) as [Hm|Hm]. subst m. exists 1.  exists 0. rewrite mult_1_l. simpl. apply GCD_unique with n 0; auto. destruct (le_lt_dec n m) as [H1|H1].
  destruct (divmod n m) as [[q [r [H2 H3] _]]|H2]; [|contradiction]. subst m. destruct (IH (n,r)) with (g:=g) as [x [y H4]]; simpl; auto. unfold ltof. simpl. rewrite Nat.min_r; auto. rewrite Nat.min_l; auto. apply GCD_mod with q; auto. simpl in H4. exists (y*q+x); exists y. rewrite mult_plus_distr_r. rewrite mult_plus_distr_l. repeat rewrite <- plus_assoc. f_equal; auto.
  destruct (divmod m n) as [[q [r [H2 H3] _]]|H2]; [|contradiction]. destruct (nat_eq_dec r 0) as [Hr|Hr]. subst n r. rewrite <- plus_n_O in H0. destruct q. exfalso. inversion H1. exists 1; exists q.  rewrite mult_1_l. rewrite <- plus_n_O. simpl. rewrite plus_comm; f_equal. apply GCD_unique with (S q*m) m; auto. apply MaxP_intro; auto. intros. destruct H2; auto.  subst n. destruct (IH (r,m)) with (g:=g) as [x [y H4]]; simpl; auto. unfold ltof. simpl. rewrite Nat.min_l; auto. rewrite Nat.min_r; auto. apply GCD_sym. apply GCD_mod with q; auto.
  simpl in H4. exists x. exists (x*q+y). rewrite mult_plus_distr_l. rewrite mult_plus_distr_r. repeat rewrite <- plus_assoc; f_equal; auto. Defined.
Definition bezour: forall n m g, n<>0 -> GCD g n m -> {x:nat & {y:nat| x*n=y*m+g}}. intros. destruct (bezour' (n,m)) with (g:=g) as [x [y H1]]; simpl; auto. simpl in H1. exists x; exists y; auto. Defined.

Theorem Bezour_neg: forall n m g, GCD g n m -> forall d, 0<d -> d<g -> forall x y, x*n<>y*m+d. Proof. cut (forall p g, GCD g (fst p) (snd p) -> forall d, 0<d->d<g->forall x y, x*fst p <>y*snd p+d). intros. apply (H (n,m) g); simpl; auto. intros p. apply (Fix (well_founded_ltof (nat*nat) (fun p=>min (fst p) (snd p)))) with (P:=fun p=>forall g, GCD g (fst p) (snd p)->forall d,0<d->d<g->forall x y,x*fst p<>y*snd p+d). clear p. intros p IH. destruct p as [n m]. simpl; intros. destruct (le_lt_dec n m) as [H2|H2]. destruct (divmod n m) as [[q [r [H3 H4] _]]|H3]. subst m. intros C. assert ((x-y*q)*n=y*r+d). apply plus_reg_l with (y*q*n). rewrite plus_assoc. rewrite mult_plus_distr_l in C. rewrite mult_assoc in C. rewrite <- C. rewrite <- mult_plus_distr_r. f_equal. rewrite <- le_plus_minus; auto. apply Nat.mul_le_mono_pos_r with n. destruct n. inversion H4. apply le_n_S; auto. rewrite C. rewrite <- plus_assoc; auto.
  contradict H3. apply (IH (n,r)) with (g:=g); simpl; auto. unfold ltof. simpl. rewrite Nat.min_r; auto. apply le_trans with n; auto. rewrite Nat.min_l; auto. apply GCD_mod with q; auto. subst n. rewrite mult_0_r. intros C. destruct d. inversion H0. rewrite <- plus_n_Sm in C. inversion C.
  destruct (divmod m n) as [[q [r [H3 H4] _]]|H3]. subst n. destruct (le_lt_dec (x*q) y) as [Hy|Hy]. intros C. assert (x*r=(y-x*q)*m+d). apply plus_reg_l with (x*q*m). rewrite <- mult_assoc. rewrite <- mult_plus_distr_l. rewrite C. rewrite plus_assoc. f_equal. rewrite mult_assoc. rewrite <- mult_plus_distr_r. f_equal. rewrite <- le_plus_minus; auto. contradict H3. apply (IH (r,m)) with (g:=g); simpl; auto. unfold ltof. simpl. rewrite Nat.min_l; auto. rewrite Nat.min_r; auto. apply GCD_sym. apply GCD_mod with q; auto.
  intros C. absurd (y*m+d<x*(q*m+r)). rewrite C; auto. rewrite mult_plus_distr_l. rewrite mult_assoc. apply lt_le_trans with (x*q*m); auto. apply lt_le_trans with (S y*m). simpl. rewrite plus_comm. apply plus_lt_compat_r. apply lt_le_trans with g; auto. inversion H. destruct H3. apply Divide_le; auto. contradict H4; subst m; auto. apply mult_le_compat_r. auto.
 subst m. rewrite mult_0_r. simpl. assert (g=n). apply GCD_unique with n 0; auto. apply GCD_sym. apply GCD_0n. contradict H2; subst n; auto. subst g. destruct x. contradict H0; subst d; auto. contradict H1; subst d. simpl; auto. Qed.
Theorem Euclid: forall n a b, Coprime n a -> Divide n (a*b) -> Divide n b. Proof. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. replace a with 1 in H0. rewrite mult_1_l in H0; auto. apply GCD_unique with 0 a; auto. destruct (nat_eq_dec a 0); auto. subst a; contradict H; apply GCD_00; auto. destruct (bezour Hn H) as [x [y H1]]. apply Divide_minus with (y*a*b). rewrite <- mult_assoc. apply Divide_trans with (a*b); auto. replace (y*a*b+b) with (x*n*b); auto. apply Divide_trans with (x*n); auto. generalize (x*n); intros; rewrite mult_comm; auto. rewrite H1. rewrite mult_plus_distr_r; f_equal. rewrite mult_1_l; auto. Qed.
Theorem Coprime_mult_rev: forall n a b, Coprime n (a*b) -> Coprime n a /\ Coprime n b. Proof. intros. destruct (gcd_sig n a) as [[g H1]|H1]. destruct (gcd_sig n b) as [[h H2]|H2]. destruct (le_lt_dec g 1). destruct (le_lt_dec h 1). replace g with 1 in H1. replace h with 1 in H2. auto. apply le_antisym; auto. apply GCD_le with n b; auto. apply le_antisym; auto. apply GCD_le with n a; auto. inversion H. absurd (h<=1); auto. apply H3. split; auto. inversion H2; destruct H5; auto. inversion H2; destruct H5. apply Divide_trans with b; auto. inversion H. inversion H1. destruct H0; destruct H5. absurd (g<=1); auto. apply H3. split; auto. apply Divide_trans with a; auto. rewrite mult_comm; auto.
  destruct H2; subst n b. contradict H. rewrite mult_0_r. apply GCD_00. destruct H1; subst n a. contradict H. apply GCD_00. Qed.
Theorem GCD_Coprime: forall n m g, GCD g (n*g) (m*g) -> Coprime n m. Proof. intros. apply MaxP_intro; auto. intros x Hx. destruct Hx. destruct (le_lt_dec x 1); auto. absurd (x*g<=g). apply lt_not_le. apply lt_le_trans with (2*g). destruct g. repeat rewrite mult_0_r in H; contradict H; auto. simpl. rewrite <- plus_n_Sm; auto. apply mult_le_compat_r; auto. inversion H. apply H3. destruct (Divide_multN H0) as [a ]; subst n. destruct (Divide_multN H1) as [b]; subst m. repeat rewrite <- mult_assoc; auto. Qed.
Theorem Coprime_GCD: forall n m g, Coprime n m -> g<>0 -> GCD g (n*g) (m*g). Proof. intros. apply MaxP_intro; auto. intros d Hd. destruct Hd. destruct (Divide_multN H1) as [a Ha]. destruct (Divide_multN H2) as [b Hb]. destruct (gcd_sig' H0 d) as [h Hh]. inversion Hh. subst n0. destruct H3. apply Divide_multN in H3. destruct H3 as [e H3]. apply Divide_multN in H5. destruct H5 as [f H5]. subst g d. apply mult_le_compat_r. assert (Coprime e f). apply GCD_Coprime with h; auto. assert (e<>0). contradict H0; subst e; auto. assert (h<>0). contradict H0; subst h; auto. repeat rewrite mult_assoc in Ha. apply Nat.mul_cancel_r in Ha; auto. repeat rewrite mult_assoc in Hb. apply Nat.mul_cancel_r in Hb; auto. cut (f<=1). intros. inversion H7. destruct e. contradict H5; auto. auto. inversion H9. subst f. contradict H. replace n with 0; auto. replace m with 0; auto. apply GCD_00. apply Nat.mul_cancel_r with e; auto. rewrite Hb. rewrite mult_0_r; auto. apply Nat.mul_cancel_r with e; auto. rewrite Ha. rewrite mult_0_r; auto.
  inversion H. apply H8. split. apply Euclid with e; auto. rewrite mult_comm. rewrite Ha; auto. apply Euclid with e; auto. rewrite mult_comm. rewrite Hb. auto. Qed.
Hint Resolve Bezour_neg Euclid Coprime_mult_rev GCD_Coprime Coprime_GCD.

Theorem ModEq_Coprime_mult: forall n m x y, Coprime n m -> ModEq n x y -> ModEq m x y -> ModEq (n*m) x y. Proof. cut (forall n m x y, x<=y->Coprime n m->ModEq n x y->ModEq m x y->ModEq (n*m) x y). intros. destruct (le_lt_dec x y); auto. intros. assert (H3:y=x+(y-x)). apply le_plus_minus; auto. assert (H4:x=x+0). apply plus_n_O. rewrite H4. rewrite H3. apply ModEq_plus; auto. rewrite H4 in H1. rewrite H3 in H1. apply ModEq_minus in H1. destruct (Divide_multN H1) as [q H5]. rewrite H4 in H2. rewrite H3 in H2. apply ModEq_minus in H2. rewrite H5 in H2. rewrite mult_comm in H2. apply Euclid in H2; auto. destruct (Divide_multN H2) as [p H6]. rewrite H5. subst q. rewrite <- mult_assoc. rewrite mult_comm. apply multN_Divide. Qed.
Theorem Divide_Coprime_mult: forall n m x, Coprime n m -> Divide n x -> Divide m x -> Divide (n*m) x. Proof. intros. apply ModEq_Coprime_mult; auto. Qed.
Theorem ModEq_Coprime_mult_rev: forall n m x y, Coprime n m -> ModEq (n*m) x y -> ModEq n x y. Proof. intros. destruct (ModEq_multN H0) as [[q H1]|[q H1]]. subst y. replace (q*(n*m)) with (q*m*n); auto. rewrite <- mult_assoc. f_equal; auto. subst x. replace (q*(n*m)) with (q*m*n); auto. rewrite <- mult_assoc. f_equal; auto. Qed.
Definition Chinese: forall n m, Coprime n m -> forall a b, {x|ModEq n a x /\ ModEq m b x & forall y, ModEq n a y -> ModEq m b y -> ModEq (n*m) x y}. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. replace m with 1. exists a. split; auto. intros; auto. inversion H. apply le_antisym. destruct H0. apply Divide_le; auto. contradict H; subst m; unfold Coprime; auto. apply H1; auto. destruct (nat_eq_dec m 0) as [Hm|Hm]. subst m. replace n with 1. exists b; auto. inversion H. destruct H0. apply le_antisym; auto.
  destruct (bezour Hn H) as [c [d H0]]. apply GCD_sym in H. destruct (bezour Hm H) as [e [f H1]]. assert (ModEq n a (a*(e*m)+b*(c*n))). replace a with (a+0) at 1. apply ModEq_plus. rewrite H1. rewrite mult_plus_distr_l. replace a with (0+a) at 1; auto. rewrite mult_1_r. apply ModEq_plus; auto. rewrite mult_assoc. apply multN_Divide. rewrite mult_assoc. apply multN_Divide. rewrite <- plus_n_O; auto. assert (ModEq m b (a*(e*m)+b*(c*n))). replace b with (0+b) at 1; auto. apply ModEq_plus. rewrite mult_assoc. apply multN_Divide. rewrite H0. rewrite mult_plus_distr_l. rewrite mult_1_r. replace b with (0+b) at 1; auto. apply ModEq_plus; auto. rewrite mult_assoc. apply multN_Divide. exists (a*(e*m)+b*(c*n)); auto.
  intros. apply ModEq_Coprime_mult; auto. apply ModEq_trans with a; auto. apply ModEq_trans with b; auto. Qed.
Hint Resolve ModEq_Coprime_mult Divide_Coprime_mult ModEq_Coprime_mult_rev.

(* Prime *)
Definition Prime p : Prop := Pnum (fun x=>Divide x p) 2.
Theorem Prime0: ~Prime 0. Proof. intros C. inversion C. absurd (max 3 m = 2). intros D. absurd (3<=2); auto. destruct (le_lt_dec 3 m). apply le_trans with m; auto. rewrite <-D. apply Nat.le_max_r. rewrite <- D at 2. apply Nat.le_max_l. apply PnumN_unique with (fun x=>Divide x 0) (max 3 m); auto. generalize (max 3 m); intros. induction n; auto. apply H. apply Nat.le_max_r; auto. Qed.
Theorem Prime1: ~Prime 1. Proof. intros C. absurd (1=2); auto. apply Pnum_unique with (fun x=>Divide x 1); auto. apply Pnum_intro with 2. intros. induction H. apply PnumN_P; auto. apply PnumN_NP; auto. intros D. absurd (0=1); auto. apply PnumN_NP; auto. intros D. apply Divide_le in D; auto. contradict H; auto. Qed.
Theorem Prime2: Prime 2. Proof. apply Pnum_intro with 3. intros. induction H. apply PnumN_P; auto. apply PnumN_P; auto. apply PnumN_NP; auto. intros C. absurd (0=2); auto. apply PnumN_NP; auto. intros C. contradict H; auto. Qed.
Theorem Prime_le: forall p, Prime p -> 2<=p. Proof. intros. destruct (le_lt_dec 2 p); auto. inversion l. subst p; contradict H; apply Prime1. inversion H1. subst p; contradict H; apply Prime0. inversion H3. Qed.
Theorem Prime_nz: forall p, Prime p -> p<>0. Proof. intros. contradict H; subst p; apply Prime0. Qed.
Theorem Prime_none: forall p, Prime p -> p<>1. Proof. intros. contradict H; subst p; apply Prime1. Qed.
Theorem Prime_build: forall p, 2<=p -> (forall x, Divide x p -> x=1\/x=p) -> Prime p. Proof. intros. apply Pnum_intro with (S p). intros. induction H1. apply PnumN_P; auto. cut (forall y, 2<=y -> y<=p->PnumN (fun x=>Divide x p) y 1). intros; auto. intros. induction H1. apply PnumN_P; auto. apply PnumN_NP; auto. intros C. absurd (p=0); auto. contradict H; subst p; auto. apply PnumN_NP; auto. intros C. destruct (H0 m C). subst m; contradict H1; auto. subst m; contradict H2; auto. apply PnumN_NP; auto. intros C. apply Divide_le in C. contradict H1; auto. contradict H; subst p; auto. Qed.
Theorem Prime_Divide: forall p, Prime p -> forall x, Divide x p -> x=1\/x=p. Proof. intros. inversion H. assert (H2:x<=p). assert (Hp:p<>0). contradict H; subst p; apply Prime0. auto. apply le_lt_or_eq in H2. destruct H2; auto. destruct (le_lt_dec x 1) as [H3|H3]. inversion H3; auto. inversion H5. subst x. absurd (p=0); auto. contradict H2; subst p; auto. destruct (pnumN (fun x=>Divide x p)) with (n:=x)  as [n H4]. intros. apply (Divide_dec x0 p). assert (H5: PnumN (fun x=>Divide x p) (S x) (S n)). auto. destruct (pnumN (fun x=>Divide x p)) with p as [n' H6]. intros; apply (Divide_dec x0 p); auto. assert (H7: PnumN (fun x=>Divide x p) (S p) (S n')); auto.
  assert (H8:1<=n). apply PnumN_incr with (fun x=>Divide x p) 2 x; auto. apply PnumN_P; auto. apply PnumN_NP; auto. intros C. absurd (p=0); auto. contradict H; subst p; apply Prime0. assert (S n<=n'). apply PnumN_incr with (fun x=>Divide x p) (S x) p; auto. absurd (S n'<=2). apply le_not_lt. apply le_trans with (S n); auto. apply PnumN_incr with (fun x=>Divide x p) (S p) (max m (S p)); auto. apply H1. apply Nat.le_max_l. apply Nat.le_max_r. Qed.
Definition Prime_dec: forall p, {Prime p}+{~Prime p}. Proof. intros. destruct (nat_eq_dec p 0). right; subst p; apply Prime0. destruct (pnumN (fun d=>Divide d p)) with (n:=S p) as [m H]. intros. apply (Divide_dec x p); auto. assert (Pnum (fun d=>Divide d p) m). apply Pnum_intro with (S p). intros. induction H0; auto. apply PnumN_NP; auto. contradict H0; auto. destruct (nat_eq_dec m 2); [subst m; left|right]; auto. contradict n0. apply Pnum_unique with (fun d=>Divide d p); auto. Defined.
Hint Resolve Prime0 Prime1 Prime2 Prime_le Prime_nz Prime_none Prime_build Prime_Divide.

Theorem Prime_Coprime_Divide: forall p n, Prime p -> Coprime p n \/ Divide p n. Proof. intros. assert (Hp:p<>0). contradict H; subst p; auto. destruct (gcd_sig' Hp n) as [g H0]. destruct (nat_eq_dec g 1). subst g; auto. right. inversion H0. destruct H1. apply Prime_Divide in H1; auto. destruct H1. contradiction. subst g; auto. Qed.
Theorem Euclid_Prime: forall p n m, Prime p -> Divide p (n*m) -> Divide p n \/ Divide p m. Proof. intros. destruct (Prime_Coprime_Divide n H); auto. right. apply Euclid with n; auto. Qed.

Definition primeDivide: forall n, {p|Prime p & Divide p n}+{n<=1}. apply (Fix lt_wf). intros n IH. destruct (le_lt_dec n 1); [right|left]; auto. destruct (findP (fun x=>2<=x/\Divide x n)) with (n0:=n). intros. destruct (le_dec 2 x). destruct (Divide_dec x n). left; auto. right; contradict n0; destruct n0; auto. right; contradict n0; destruct n0; auto. destruct s as [m [H1 H2]]. destruct (IH m) as [[p H3 H4]|H3]; auto. exists p; auto. apply Divide_trans with m; auto. contradict H1; auto. exists n; auto. apply Prime_build; auto. intros. assert (x<=n). apply Divide_le; auto. contradict l; subst n; auto. apply le_lt_or_eq in H0. destruct H0; auto. left. destruct (le_lt_dec 2 x).
  absurd (2<=x/\Divide x n); auto. inversion l0. auto. inversion H2. subst x. absurd (n=0); auto. contradict l; subst n; auto. inversion H4. Defined.
Theorem Coprime_mult: forall n a b, Coprime n a -> Coprime n b -> Coprime n (a*b). Proof. intros. destruct (gcd_sig n (a*b)) as [[g Hg]|Hg]. destruct (nat_eq_dec g 1). subst g; auto. destruct (primeDivide g) as [[p H1]|H1]. inversion Hg. destruct H2. assert (Divide p (a*b)). apply Divide_trans with g; auto. apply Euclid_Prime in H6. destruct H6. inversion H. absurd (p<=1); auto. apply H8. split; auto. apply Divide_trans with g; auto. inversion H0. absurd (p<=1); auto. apply H8; split; auto. apply Divide_trans with g; auto. auto. contradict n0. apply le_antisym; auto. apply GCD_le with n (a*b); auto. destruct Hg. subst n. destruct a. contradict H; apply GCD_00. destruct b. contradict H0; apply GCD_00. simpl in H2. inversion H2. Qed.
Theorem Coprime_pow: forall a b k, Coprime a b -> Coprime a (pow b k). Proof. intros. induction k; simpl; auto. apply Coprime_mult; auto. Qed.
Theorem Prime_mult_In: forall p l, Prime p -> Forall Prime l -> Divide p (fold_right mult 1 l) -> In p l. Proof. induction l; simpl; intros. apply Divide_le in H1; auto. contradict H1; auto. apply Euclid_Prime in H1; auto. inversion H0. destruct H1; [left|right]. apply Prime_Divide in H1; auto. destruct H1; auto. subst p; contradict H; auto. apply IHl; auto. Qed.
Theorem Prime_pow_Coprime_Divide: forall p n k, Prime p -> Coprime (pow p k) n \/ Divide p n. Proof. intros. destruct (gcd_sig (pow p k) n) as [[g Hg]|Hg]. destruct (primeDivide g) as [[q Hq]|Hq]. assert (In q (repeat p k)). apply Prime_mult_In; auto. clear -H; induction k; simpl; auto. apply Divide_trans with g; auto. inversion Hg. destruct H0. replace (fold_right mult 1 (repeat p k)) with (pow p k); auto. clear -k. induction k; simpl; auto. replace p with q. right. apply Divide_trans with g; auto. inversion Hg; destruct H1; auto. clear -H0. induction k; simpl in H0; auto. destruct H0. destruct H0; auto. replace g with 1 in Hg; auto. apply le_antisym; auto. eapply GCD_le; eauto. destruct Hg. contradict H0. induction k; simpl; auto. destruct p. contradict H; auto. simpl. destruct (pow (S p) k). contradict IHk; auto. simpl; discriminate. Qed.
Definition powDivide: forall a n, 2<=a -> {x:nat & {y|n=pow a x*y & ~Divide a y}}+{n=0}. intros. apply (Fix lt_wf) with (P:=fun n=>{x:nat &{y|n=pow a x*y&~Divide a y}}+{n=0}). clear n. intros n IH. destruct (nat_eq_dec n 0); [right; auto|left]. destruct (Divide_dec a n). destruct (Divide_multN d). subst n. destruct (IH x). destruct a. inversion H. destruct a. contradict H; auto. rewrite mult_comm. simpl. apply lt_le_trans with (x+x). destruct x. contradict n0; auto. simpl. rewrite <- plus_n_Sm. auto. rewrite plus_assoc; auto. destruct s as [y [z H1 H2]]. subst x. exists (S y). exists z; simpl; auto. rewrite mult_comm; auto. subst x; contradict n0; auto. exists 0. exists n; auto. Defined.
Theorem pow_Prime_Divide: forall p n x, Prime p -> Divide x (pow p n) <-> exists m, x = pow p m /\ m<=n. Proof. induction n; intros. simpl. split; intros. exists 0. assert (x<>0). intros C. subst x. destruct (Divide_multN H0). contradict e. rewrite mult_0_r. auto. apply Divide_le in H0; auto. inversion H0; auto. inversion H3. contradiction. destruct H0 as [m [H1 H2]]. inversion H2. subst m x; simpl; apply Divide_refl. simpl; split; intros. destruct (Prime_Coprime_Divide x H). apply Euclid in H0; auto. apply IHn in H0; auto. destruct H0 as [m [H2 H3]]. exists m; auto. destruct (Divide_multN H1) as [y H2]. subst x. rewrite mult_comm in H0. apply Divide_div in H0. apply IHn in H0; auto. destruct H0 as [m [H2 H3]]. subst y. exists (S m); simpl; auto. contradict H; subst p; auto. destruct H0 as [m [H1 H2]]. inversion H2. subst m x; simpl; auto. apply Divide_trans with (pow p n); auto. apply IHn; auto. exists m; auto. Qed.
Hint Resolve Prime_Coprime_Divide Euclid_Prime Coprime_mult Coprime_pow Prime_mult_In Prime_pow_Coprime_Divide pow_Prime_Divide.

Definition fundamental: forall n, {l|n=fold_right mult 1 l /\ Forall Prime l & forall m, n=fold_right mult 1 m -> Forall Prime m -> Perm l m}+{n=0}. apply (Fix lt_wf). intros n IH. destruct (nat_eq_dec n 0) as [Hn|Hn]; [right|left]; auto. destruct (primeDivide n) as [[p H1 H2]|H1]. destruct (Divide_multN H2) as [x H3]. subst n. destruct (IH x) as [[l [H3 H4] H5]|H3]. destruct p. contradict H1; auto. rewrite <- mult_n_Sm. destruct x. contradict Hn; auto. simpl. rewrite <- plus_n_Sm. apply le_n_S. destruct p. contradict H1; auto. simpl. apply le_n_S. apply le_plus_r. subst x. exists (p::l). split; simpl; auto. intros. destruct (add_inv nat_eq_dec p m) as [[m' H6]|H6]. apply Perm_Add with p l m'; auto. apply H5; auto. apply Nat.mul_cancel_r with p. contradict H1; subst p; auto. rewrite H.
  clear -H6. induction H6; simpl; auto. rewrite <- mult_assoc; f_equal; auto. clear -H6 H0. induction H6; simpl; auto. inversion H0; auto. inversion H0; auto. contradict H6. apply Prime_mult_In; auto. rewrite <- H; auto. subst x; contradict Hn; auto. destruct (nat_eq_dec n 1). subst n. exists nil; auto. intros. destruct m; auto. simpl in H. inversion H0. absurd (1<n); auto. apply le_not_lt. rewrite H. cut (fold_right mult 1 m<>0). intros. destruct (fold_right mult 1 m). contradict H6; auto. rewrite <- mult_n_Sm. apply le_plus_r. clear -H5. induction m; simpl. auto. inversion H5. apply IHm in H2. contradict H2. apply mult_is_O in H2. destruct H2; auto. contradict H1; subst x a; auto. exfalso. inversion H1. contradiction. inversion H0. contradiction. Defined.
Definition fundamental2: forall n, {l|n=fold_right (fun p=>mult (pow (fst p) (snd p))) 1 l /\ Forall Prime (map fst l) /\ NoDup (map fst l) /\ Forall (fun x=>x<>0) (map snd l)}+{n=0}. intros. destruct (fundamental n) as [[l [H1 H2] H3]|H1]; [left|right]; auto. destruct (count_list nat_eq_dec l) as [pl [H4 [H5 H6]]]. exists pl. split. subst n. apply fold_right_Perm with (o:=mult) (a:=1) in H4; auto. rewrite H4. clear -pl. induction pl as [|[p c] pl]; simpl; auto. induction c; simpl; auto. rewrite <- plus_n_O. rewrite IHpl. auto. rewrite <- mult_assoc. f_equal; auto. split; auto.  apply Forall_forall. intros p Hp. apply Forall_forall with (x:=p) in H2; auto. eapply Perm_In. apply Perm_sym; eapply H4. apply in_map_iff in Hp. destruct Hp as [[q c] [H7 H8]]. simpl in H7. subst q. assert (c<>0). apply Forall_forall with (x:=c) in H6; auto. apply in_map_iff. exists (p,c); auto. clear -H8 H0. induction pl. destruct H8. simpl. apply in_or_app. destruct H8; [left|right]; auto. subst a. destruct c; simpl; auto. Defined.
Theorem Prime_inf: forall n, exists p, n<=p /\ Prime p. Proof. induction n. exists 2; auto. destruct IHn as [p [H1 H2]]. apply le_lt_or_eq in H1. destruct H1. exists p; auto. subst n. destruct (primeDivide (1+ (fold_right mult 1 (filter (fun p=>if Prime_dec p then true else false) (seq 1 p))))) as [[q H H1]|H]. destruct (le_lt_dec q p). absurd (Divide q 1). intros C. apply Divide_le in C; auto. contradict C; auto. rewrite plus_comm in H1. apply Divide_minus in H1; auto. assert (In q (filter (fun p=>if Prime_dec p then true else false) (seq 1 p))). apply filter_In. split. apply in_seq. split; auto. destruct (Prime_dec q); auto. revert H0. generalize (filter (fun p=>if Prime_dec p then true else false) (seq 1 p)). induction l0; intros. inversion H0. simpl.  destruct H0. subst a. rewrite mult_comm; auto. apply Divide_trans with (fold_right mult 1 l0); auto.
  exists q; auto. simpl in H. apply le_S_n in H. contradict H. apply lt_not_le. remember (filter (fun p=>if Prime_dec p then true else false) (seq 1 p)) as l. assert (Forall Prime l). apply Forall_forall. intros. subst l. apply filter_In in H. destruct H. destruct (Prime_dec x); auto. inversion H0. clear Heql. induction l; auto. inversion H. simpl. destruct a. contradict H3; auto. simpl. apply lt_le_trans with (fold_right mult 1 l); auto. Qed.
Theorem ModEq_div: forall n a b c, Coprime n c -> ModEq n (c*a) (c*b) -> ModEq n a b. Proof. intros. destruct (ModEq_multN H0) as [[q H1]|[q H1]]. destruct (nat_eq_dec c 0). subst c. replace n with 1; auto. apply GCD_unique with n 0; auto. apply MaxP_intro; auto. intros. destruct H2; auto. apply Divide_le; auto. contradict H; subst n; auto. apply GCD_00. rewrite plus_comm in H1. assert (c*a<=c*b). rewrite H1; auto. apply Nat.mul_le_mono_pos_l in H2; auto. apply plus_minus in H1. rewrite <- mult_minus_distr_l in H1. assert (Divide n (c*(b-a))). rewrite <- H1; auto. apply Euclid in H3; auto. destruct (Divide_multN H3) as [r H4]. apply le_plus_minus in H2. rewrite H4 in H2. subst b. rewrite plus_comm; auto.
  destruct (nat_eq_dec c 0). subst c. replace n with 1; auto. apply GCD_unique with n 0; auto. apply MaxP_intro; auto. intros. destruct H2. apply Divide_le; auto. contradict H; subst n; apply GCD_00. assert (c*b<=c*a). rewrite H1; auto. apply Nat.mul_le_mono_pos_l in H2; auto. rewrite plus_comm in H1. apply plus_minus in H1. rewrite <- mult_minus_distr_l in H1. assert (Divide n (a-b)). apply Euclid with c; auto. rewrite <- H1; auto. destruct (Divide_multN H3) as [r H4]. apply le_plus_minus in H2. rewrite H4 in H2. subst a. rewrite plus_comm; auto. Qed.
Hint Resolve Prime_inf ModEq_div.

(* Totient *)
Inductive Totient: relation nat:= Totient_intro: forall n m, PnumN (Coprime n) n m -> Totient n m.
Theorem Totient0: Totient 0 0. Proof. apply Totient_intro; auto. Qed.
Theorem Totient1: Totient 1 1. Proof. apply Totient_intro; auto. Qed.
Theorem Totient_unique: forall n m m', Totient n m -> Totient n m' -> m=m'. Proof. intros. inversion H. inversion H0. eapply PnumN_unique; eauto. Qed.
Theorem Totient_nz: forall n t, n<>0 -> Totient n t -> t<>0. Proof. intros. destruct n. contradict H; auto. destruct n. replace t with 1; auto. inversion H0. inversion H1. inversion H5; auto. contradict H6; apply MaxP_intro; auto. intros. destruct H6; auto. inversion H0. cut (1<=t). intros. destruct t; auto. inversion H4. subst m. cut (PnumN (Coprime (S (S n))) 2 1). intros. eapply PnumN_incr; eauto. apply PnumN_P; auto. apply PnumN_NP; auto. intros C. inversion C. absurd (S (S n)<=1); auto. Qed.
Definition totient_sig: forall n, {m|Totient n m}. intros. destruct pnumN with (P:=Coprime n) (n:=n) as [m Hm]. intros. apply (Coprime_dec n x); auto. exists m; auto. apply Totient_intro; auto. Defined.
Definition totient n := match totient_sig n with exist _ m _ => m end.
Hint Resolve Totient_intro Totient0 Totient1 Totient_unique Totient_nz.

Definition coprimeList n := filter (dec2b (Coprime_dec n)) (seq 1 n).
Definition coprimeList' n := filter (dec2b (Coprime_dec n)) (seq 0 n).
Theorem PnumN_filter: forall P (P_dec:forall x,{P x}+{~P x}) n, PnumN P n (length (filter (dec2b P_dec) (seq 0 n))). induction n. simpl; auto. rewrite seqS. simpl. rewrite filter_app. rewrite app_length. simpl. remember (dec2b P_dec n) as b. destruct b; simpl. rewrite plus_comm. apply PnumN_P; auto. symmetry in Heqb. apply dec2b_true in Heqb; auto. rewrite plus_comm. apply PnumN_NP; auto. symmetry in Heqb. apply dec2b_false in Heqb; auto. Qed.
Theorem coprimeList_eq: forall n, n<>1 -> coprimeList' n = coprimeList n. Proof. intros. unfold coprimeList'. unfold coprimeList. destruct n. auto. destruct n. contradict H; auto. replace (seq 0 (S (S n))) with (0::seq 1 (S n)). symmetry. rewrite seqS. rewrite filter_app. remember (seq 1 (S n)) as l. simpl. remember (dec2b (Coprime_dec (S (S n))) 0) as b. remember (dec2b (Coprime_dec (S (S n))) (S (S n))) as c. destruct b. symmetry in Heqb. apply dec2b_true in Heqb. inversion Heqb. absurd (S (S n)<=1); auto. destruct c; auto. symmetry in Heqc. apply dec2b_true in Heqc. inversion Heqc. absurd (S (S n)<=1); auto. rewrite app_nil_r; auto. simpl. auto. Qed.
Theorem coprimeList_In: forall n m, In m (coprimeList n) <-> Coprime n m /\ 1<=m<=n. Proof. unfold coprimeList. intros; split; intros. apply filter_In in H. destruct H. apply in_seq in H. destruct H. apply dec2b_true in H0. auto. apply filter_In. destruct H. destruct H0. split. apply in_seq. auto. apply dec2b_true; auto. Qed.
Theorem coprimeList'_Totient: forall n, Totient n (length (coprimeList' n)). Proof. intros. apply Totient_intro. unfold coprimeList'. apply PnumN_filter. Qed.
Theorem coprimeList_Totient: forall n, Totient n (length (coprimeList n)). Proof. intros. destruct (nat_eq_dec n 1). subst n. simpl. auto. replace (coprimeList n) with (coprimeList' n); auto. apply coprimeList'_Totient. rewrite coprimeList_eq; auto. Qed.
Theorem coprimeList'_NoDup: forall n, NoDup (coprimeList' n). Proof. intros. unfold coprimeList'. apply filter_NoDup. apply seq_NoDup. Qed.
Theorem coprimeList'_In: forall n m, In m (coprimeList' n) <-> m<n /\ Coprime n m. Proof. intros. unfold coprimeList'. split; intros. apply filter_In in H. destruct H. apply in_seq in H. destruct H. apply dec2b_true in H0. auto. apply filter_In. destruct H. split. apply in_seq. split; auto. apply dec2b_true; auto. Qed.
Hint Resolve PnumN_filter coprimeList_eq coprimeList_Totient coprimeList_In coprimeList'_Totient coprimeList'_NoDup coprimeList'_In.

Theorem Prime_pow_Totient: forall p n, Prime p -> n<>0 -> Totient (pow p n) ((p-1)*(pow p (n-1))). Proof. intros. apply Totient_intro. replace ((p-1)*pow p (n-1)) with (length (filter (dec2b (Coprime_dec (pow p n))) (seq 0 (pow p n)))). auto. rewrite Perm_length with (m:=filter (dec2b (Coprime_dec (pow p n))) (flat_map (fun x=> map (fun y=>y*p+x) (seq 0 (pow p (n-1)))) (seq 0 p))). replace (seq 0 p) with (0::seq 1 (p-1)). simpl. rewrite filter_app. rewrite app_length. rewrite filter_None. simpl. rewrite filter_Forall. remember (seq 1 (p-1)) as l. replace (p-1) with (length l). clear Heql. induction l; simpl; auto.  rewrite app_length. rewrite map_length.  rewrite seq_length. f_equal; auto. subst l; apply seq_length.
  intros x Hx. apply dec2b_true. destruct (Prime_pow_Coprime_Divide x n H); auto. apply in_flat_map in Hx. destruct Hx as [y [H2 H3]]. apply in_map_iff in H3. destruct H3 as [z [H4 H5]]. subst x. apply in_seq in H2. destruct H2. destruct (Divide_le_or_0) with p y. apply Divide_minus with (z*p); auto. contradict H3. replace (1+(p-1)) with p; auto. destruct p; auto. contradict H; auto. simpl. rewrite <- minus_n_O; auto. subst y; inversion H2.
  intros x Hx. apply dec2b_false. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. rewrite <- plus_n_O. intros C. inversion C. absurd (p<=1); auto. apply H3. split; auto. destruct n; simpl; auto. contradict H0; auto. rewrite mult_comm; auto. destruct p. contradict H; auto. simpl. rewrite <- minus_n_O; auto.
  apply filter_Perm. apply NoDup_incl_Perm. intros x Hx. destruct (divmod p x) as [[q [r [H1 H2] _]]|H1]; [|contradict H; subst p; auto]. subst x. apply in_flat_map. exists r. split. apply in_seq; auto. apply in_map_iff. exists q. split; auto. apply in_seq. destruct (le_lt_dec (pow p (n-1)) q); auto. apply in_seq in Hx. destruct Hx. contradict H3. apply le_not_lt. apply le_trans with (q*p); auto. destruct n; simpl. contradict H0; auto. rewrite mult_comm. apply mult_le_compat_r. simpl in l. rewrite <- minus_n_O in l. auto. apply seq_NoDup. rewrite seq_length. replace (length (flat_map (fun x=>map (fun y=>y*p+x) (seq 0 (pow p (n-1)))) (seq 0 p))) with (pow p n); auto. replace (pow p n) with (p*pow p (n-1)). remember (seq 0 p) as l. replace p with (length l) at 1. clear Heql. induction l; simpl; auto. rewrite app_length. rewrite map_length. rewrite seq_length. f_equal; auto. subst l. apply seq_length. destruct n. contradict H0; auto. simpl. rewrite <- minus_n_O; auto. Qed.
Theorem Prime_Totient: forall p, Prime p -> Totient p (p-1). Proof. intros. replace (p-1) with ((p-1)*(pow p (1-1))). replace p with (pow p 1) at 1. apply Prime_pow_Totient; auto. simpl. rewrite mult_1_r; auto. simpl. rewrite mult_1_r; auto. Qed.
Theorem Euler: forall n a t, Totient n t -> Coprime n a -> ModEq n (pow a t) 1. Proof. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. replace t with 0; auto. eapply Totient_unique; eauto. remember (coprimeList' n) as l. assert (H1: NoDup l). subst l; auto. assert (H2: forall x, In x l->Coprime n x). intros; subst l; apply coprimeList'_In; auto. assert (H3: forall x, In x l->x<n). intros; subst l; apply coprimeList'_In; auto. assert (H4:forall x, Coprime n x->x<n->In x l). intros; subst l; apply coprimeList'_In; auto. assert (Ht:length l=t). subst l. apply Totient_unique with n; auto. clear Heql.
  cut (ModEq n (fold_right mult 1 l*pow a t) (fold_right mult 1 l)). intros. clear -H2 H5. induction l; simpl in H5. rewrite <- plus_n_O in H5; auto. apply IHl; auto. apply ModEq_div with a0; auto. rewrite mult_assoc; auto. replace (fold_right mult 1 l*pow a t) with (fold_right mult 1 (map (mult a) l)). apply ModEq_trans with (fold_right mult 1 (map (modN Hn) (map (mult a) l))). 
  generalize (map (mult a) l) as m. induction m; simpl; auto. rewrite map_map. replace (fold_right mult 1 l) with (fold_right mult 1 (map (fun x=>modN Hn (a*x)) l)); auto. apply fold_right_Perm; auto. apply NoDup_incl_Perm. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H5 H6]]. subst y. apply H4; auto. apply GCD_ModEq with (a*z); auto. fold Coprime; auto. apply NoDup_map; auto. intros. rewrite <- modN_le_eq with n Hn x; auto. rewrite <- modN_le_eq with n Hn y; auto. apply ModEq__modN_eq. apply ModEq_div with a; auto. apply modN_eq__ModEq with Hn; auto. rewrite map_length; auto. subst t. clear -l. induction l; simpl; auto. rewrite IHl. repeat rewrite mult_assoc. f_equal. rewrite <- mult_assoc. rewrite mult_comm; auto. Qed.
Theorem Fermat: forall p a, Prime p -> ~Divide p a -> ModEq p (pow a (p-1)) 1. Proof. intros.  apply Euler. apply Prime_Totient; auto. destruct (Prime_Coprime_Divide) with p a; auto. contradiction. Qed.
Hint Resolve Prime_pow_Totient Prime_Totient Euler Fermat.

Theorem Totient_mult: forall a b ta tb, Coprime a b -> Totient a ta -> Totient b tb -> Totient (a*b) (ta*tb). Proof. intros. destruct (nat_eq_dec a 0)as [Ha|Ha]. subst a. replace ta with 0; auto. apply Totient_unique with 0; auto. destruct (nat_eq_dec b 0) as [Hb|Hb]. subst b. replace tb with 0. repeat rewrite mult_0_r; auto. apply Totient_unique with 0; auto.
  apply Totient_intro. replace (ta*tb) with (length (filter (dec2b (Coprime_dec (a*b))) (seq 0 (a*b)))); auto. rewrite Perm_length with (m:=filter (dec2b (Coprime_dec (a*b))) (flat_map (fun x=> map (fun y=>y*a+x) (seq 0 b)) (seq 0 a))). rewrite Perm_length with (m:=filter (dec2b (Coprime_dec (a*b))) (flat_map (fun x=>map (fun y=>y*a+x) (seq 0 b)) (filter (dec2b (Coprime_dec a)) (seq 0 a)++filter (fun x=>negb (dec2b (Coprime_dec a) x)) (seq 0 a)))). rewrite flat_map_app. rewrite filter_app. rewrite app_length. replace (filter (dec2b (Coprime_dec (a * b))) (flat_map (fun x : nat => map (fun y : nat => y * a + x) (seq 0 b)) (filter (fun x : nat => negb (dec2b (Coprime_dec a) x)) (seq 0 a)))) with (nil (A:=nat)). rewrite <- plus_n_O.
  cut (forall x, In x (coprimeList' a) -> length (filter (dec2b (Coprime_dec (a*b))) (map (fun y=>y*a+x) (seq 0 b)))=tb). unfold coprimeList'. remember (filter (dec2b (Coprime_dec a)) (seq 0 a)) as l. replace ta with (length l). clear Heql. induction l; simpl; intros; auto. rewrite filter_app. rewrite app_length. f_equal; auto. subst l. apply Totient_unique with a; auto.
  intros. rewrite filter_map. rewrite map_length. rewrite filter_equiv with (g:=fun y=>dec2b (Coprime_dec b) (modN Hb (y*a+x))). rewrite <- map_length with (f:=fun y=>modN Hb (y*a+x)). rewrite <- filter_map. rewrite Perm_length with (m:=filter (dec2b (Coprime_dec b)) (seq 0 b)). apply Totient_unique with b; auto. apply filter_Perm. apply NoDup_incl_Perm. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_seq. split; auto. apply NoDup_map. apply seq_NoDup. intros z y Hz Hy Hx. rewrite <- modN_le_eq with b Hb z. rewrite <- modN_le_eq with b Hb y. apply ModEq__modN_eq. apply ModEq_div with a; auto. apply ModEq_minus with x. replace (x+a*z) with (z*a+x). replace (x+a*y) with (y*a+x). apply modN_eq__ModEq with Hb; auto. rewrite plus_comm; f_equal; auto. rewrite plus_comm; f_equal; auto. apply in_seq in Hy; destruct Hy; auto. apply in_seq in Hz; destruct Hz; auto. rewrite map_length; auto.
  intros z Hz. remember (dec2b (Coprime_dec b) (modN Hb (z*a+x))) as c. destruct c; symmetry in Heqc. apply dec2b_true. apply dec2b_true in Heqc. apply Coprime_sym. apply Coprime_mult; apply Coprime_sym. apply GCD_multN. apply coprimeList'_In; auto. apply GCD_ModEq with (modN Hb (z*a+x)); auto. apply dec2b_false. apply dec2b_false in Heqc. contradict Heqc. apply Coprime_sym in Heqc. apply Coprime_mult_rev in Heqc. destruct Heqc. apply GCD_ModEq with (z*a+x); auto.
  symmetry. apply filter_None. intros. apply in_flat_map in H2. destruct H2 as [y [H3 H4]]. apply in_map_iff in H4. destruct H4 as [z [H5 H6]]. subst x. apply filter_In in H3. destruct H3. apply dec2b_false. apply Bool.negb_true_iff in H3. apply dec2b_false in H3. contradict H3. apply GCD_mod with z. apply GCD_sym. apply Coprime_mult_rev with b. replace (b*a) with (a*b); auto.
  apply filter_Perm. apply Perm_flat_map. apply filter_app_Perm. apply filter_Perm. apply NoDup_incl_Perm. intros z Hz. destruct (divmod a z) as [[q [r [H2 H3] _]]|H2]; [|contradiction]. subst z. apply in_flat_map. exists r. split. apply in_seq; auto. apply in_map_iff. exists q; split; auto. apply in_seq. destruct (le_lt_dec b q); auto. apply in_seq in Hz. destruct Hz. contradict H4. apply le_not_lt. simpl. rewrite mult_comm. apply le_trans with (q*a); auto. apply mult_le_compat_r; auto. apply seq_NoDup. rewrite seq_length. clear -a. remember (seq 0 a) as l. replace (a*b) with (length l*b). clear Heql. induction l; simpl; auto. rewrite app_length. rewrite map_length. rewrite seq_length. apply plus_le_compat_l; auto. f_equal. subst l. apply seq_length. Qed.

Definition div_tmp (n m:nat):nat. refine (if nat_eq_dec n 0 then 0 else match divmod n m with |inleft (existT _ q _) => q |inright _ => _ end). contradiction. Defined.
Lemma div_tmp_spec: forall n m, Divide n m -> m=n*div_tmp n m. Proof. intros. unfold div_tmp. destruct (nat_eq_dec n 0). destruct (Divide_multN H) as [q H1]. subst n m. rewrite mult_0_r; auto.  destruct (divmod n m) as [[q [r [H1 H2] H3]]|H1]; [|contradiction]. destruct (Divide_multN H) as [s H4]. subst m. replace (s*n) with (s*n+0) in H4. apply H3 in H4. destruct H4; subst s r. rewrite <- plus_n_O; auto. destruct n; auto. rewrite <- plus_n_O; auto. Qed.
Lemma sum_length: forall {T:Type} ll, fold_right plus 0 (map (length (A:=T)) ll) = length (concat ll). Proof. induction ll; simpl; auto. rewrite app_length. f_equal; auto. Qed.
Theorem Totient_sum: forall n, fold_right plus 0 (map totient (filter (dec2b (fun d=>Divide_dec d n)) (seq 1 n))) = n. Proof. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. simpl; auto. rewrite map_ext_in with (g:=fun m=>length (map (fun y=> mult (div_tmp m n) y) (coprimeList m))). rewrite <- map_map. rewrite sum_length. rewrite <- flat_map_concat_map. replace n with (length (seq 1 n)) at 2. apply Perm_length. assert (Ht:forall x, Divide x n -> div_tmp x n<>0). intros. contradict Hn. rewrite div_tmp_spec with x n; auto. rewrite Hn. rewrite mult_0_r; auto. apply NoDup_incl_each_Perm.
  apply NoDup_flat_map. apply filter_NoDup. apply seq_NoDup. intros. apply NoDup_map. apply filter_NoDup. apply seq_NoDup. intros. apply Nat.mul_cancel_l with (div_tmp x n); auto. apply filter_In in H. destruct H. apply dec2b_true in H3. auto. intros. apply in_map_iff in H1. destruct H1 as [s [H3 H4]]. apply in_map_iff in H2. destruct H2 as [t [H5 H6]]. apply filter_In in H. destruct H. apply dec2b_true in H1. apply filter_In in H0. destruct H0. apply dec2b_true in H2. cut (div_tmp x n=div_tmp y n). intros. apply Nat.mul_cancel_r with (div_tmp x n); auto. rewrite <- div_tmp_spec; auto. rewrite H7. apply div_tmp_spec; auto.
  apply GCD_unique with z n. replace n with (x*div_tmp x n) at 2. rewrite <- H3. rewrite mult_comm. apply Coprime_GCD; auto. apply coprimeList_In in H4. destruct H4; auto. rewrite <- div_tmp_spec; auto. replace n with (y*div_tmp y n) at 2. rewrite <- H5. rewrite mult_comm. apply Coprime_GCD; auto. apply coprimeList_In in H6. destruct H6; auto. rewrite <- div_tmp_spec; auto.
  apply seq_NoDup. intros z Hz. apply in_flat_map in Hz. destruct Hz as [x [H1 H2]]. apply in_map_iff in H2. destruct H2 as [y [H3 H4]]. subst z. apply filter_In in H1. destruct H1. apply dec2b_true in H0. apply in_seq. apply in_seq in H. destruct H. apply coprimeList_In in H4. destruct H4. destruct H3. assert (n=x*div_tmp x n). apply div_tmp_spec; auto. split. assert (div_tmp x n<>0). auto. destruct (div_tmp x n). contradict H6; auto. simpl. apply le_trans with y; auto. apply le_n_S. rewrite H5 at 2. rewrite mult_comm. apply mult_le_compat_r; auto.
  intros x Hx. apply in_flat_map. destruct (gcd_sig' Hn x) as [g Hg]. exists (div_tmp g n). inversion Hg. subst n0. destruct H. destruct (Divide_multN H1) as [a Ha]. subst x. assert (n=g*div_tmp g n). apply div_tmp_spec; auto. split. apply filter_In. split. apply in_seq. split. assert (div_tmp g n<>0). auto. destruct (div_tmp g n); auto. apply le_n_S. rewrite H2 at 2. destruct g. absurd (1<=0); auto. simpl; auto. apply dec2b_true; auto. rewrite H2 at 2; auto. apply in_map_iff. exists a. split. rewrite mult_comm. f_equal. apply Nat.mul_cancel_r with (div_tmp g n); auto. rewrite <- H2. rewrite mult_comm. rewrite <- div_tmp_spec; auto. rewrite H2 at 2; auto. apply filter_In. split. apply in_seq. split. destruct a; auto. apply in_seq in Hx. destruct Hx. contradict H3; auto. apply le_n_S. destruct (le_lt_dec a (div_tmp g n)); auto. apply mult_lt_compat_l with (div_tmp g n) a g in l. contradict l. rewrite <- H2. rewrite mult_comm. apply in_seq in Hx. destruct Hx. auto. destruct g; auto. apply dec2b_true. apply GCD_Coprime with g. rewrite mult_comm. rewrite <- H2; auto.
  rewrite seq_length; auto. intros. rewrite map_length. unfold totient. destruct (totient_sig a) as [m H1]. apply Totient_unique with a; auto. Qed.

Theorem ModInv: forall n a, a<>0 -> Coprime n a -> exists b, ModEq n (a*b) 1 /\ forall b', ModEq n (a*b') 1 -> ModEq n b b'. Proof. intros. destruct (bezour H (Coprime_sym H0)) as [x [y Hx]]; auto. exists x. split. rewrite mult_comm. rewrite Hx; auto. intros. apply ModEq_div with a; auto. rewrite mult_comm. rewrite Hx. apply ModEq_trans with 1; auto. Qed.
Definition invMod: forall n a, {b|ModEq n (a*b) 1}+{~Coprime n a}. intros. destruct (Coprime_dec n a); [left|right]; auto. destruct (nat_eq_dec a 0). subst a. exists 0. replace n with 1; auto. inversion c. apply le_antisym. destruct n; auto. apply H0; auto. apply GCD_sym in c. destruct (bezour n0 c) as [x [y H]]. exists x. rewrite mult_comm. rewrite H. auto. Defined.
Theorem ModEq_m1_sq: forall n, ModEq (S n) (n*n) 1. Proof. intros. apply ModEq_minus with (S(n+n)). replace (S (n+n)+n*n) with (S n*S n). apply ModEq_trans with 0. apply ModEq_sym; apply multN_Divide. replace (S (n+n)+1) with (2*S n); auto. apply multN_Divide. simpl. repeat rewrite <- plus_n_Sm. f_equal. f_equal. rewrite plus_assoc; auto. simpl. f_equal. rewrite <- plus_assoc. f_equal. rewrite mult_comm. simpl. auto. Qed.

Hint Resolve Totient_mult Totient_sum ModInv ModEq_m1_sq.

(* LCM *)
Definition LCM (l x y:nat) := MinP (fun m=>m<>0/\Divide x m /\ Divide y m) l.
Definition lcm_sig: forall x y, {l|LCM l x y}+{x=0\/y=0}. intros. destruct (nat_eq_dec x 0). right; auto. destruct (nat_eq_dec y 0). right; auto. left. destruct minP with (P:=fun m=>m<>0/\Divide x m/\Divide y m) (n:=S (x*y)) as [[m H]|H]. intros. destruct (nat_eq_dec x0 0). right. intros C. destruct C. contradiction. destruct (Divide_dec x x0). destruct (Divide_dec y x0); [left|right]; auto. contradict n2. destruct n2. destruct H1; auto. right. contradict n2. destruct n2. destruct H1; auto. exists m; auto. absurd (x*y<>0/\Divide x (x*y)/\Divide y (x*y)); auto. split; auto. intros C. apply mult_is_O in C. destruct C; contradiction. split; auto. rewrite mult_comm; auto. Defined.


