Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import ModEq.
Require Import combi.

Set Implicit Arguments.

Theorem Willson1: forall p, Prime p -> ModEq p (fact (p-1)) (p-1). Proof. intros. destruct (le_lt_dec p 2) as [H0|H0]. replace p with 2; simpl; auto. apply le_antisym; auto. assert (Hp:p<>0). contradict H; subst p; auto. rewrite fact_fold. remember (p-1) as t. assert (Ht: p=S t). destruct p. contradict Hp; auto. simpl in Heqt. rewrite <- minus_n_O in Heqt; subst t; auto. assert (Ht1:t<p). rewrite Ht; auto. assert (Ht2:Coprime p t). destruct (Prime_Coprime_Divide t H); auto. apply Divide_le in H1. contradict Ht1; auto. contradict H. rewrite Ht. rewrite H. auto. remember (t-2) as u. assert (Hu:t=S(S u)). subst u. destruct t. subst p; contradict H0; auto. simpl. destruct t. contradict H0; subst p; auto. simpl. rewrite <- minus_n_O; auto. rewrite Hu at 1. rewrite seqS. simpl. rewrite <- plus_n_O. rewrite fold_mult_app. simpl. rewrite mult_1_r. rewrite <- Hu. replace t with (1*t) at 2; auto. apply ModEq_mult; auto.
  destruct (Rpair_list) with (l:=seq 2 u) (R:=fun x y=>ModEq p (x*y) 1) as [l [H1 H2]]; simpl; intros; auto. intros C. apply in_seq in H1. destruct H1. absurd (x=1). contradict H1; subst x; auto. rewrite <- modN_le_eq with p Hp x. rewrite <- modN_le_eq with p Hp 1; auto. apply ModEq__modN_eq. apply ModEq_div with (1+x); auto. destruct (Prime_Coprime_Divide (1+x) H); auto. simpl in H3. apply Divide_le in H3; auto. contradict H2. simpl. rewrite <- Hu. apply le_not_lt. apply le_S_n. rewrite <- Ht; auto. rewrite mult_1_r. rewrite mult_plus_distr_r. rewrite mult_1_l. rewrite plus_comm. auto. simpl in H2. rewrite <- Hu in H2. apply lt_le_trans with t; auto.
  apply in_seq in H1. destruct H1. simpl in H2. rewrite <- Hu in H2. assert (Hx:x<p). rewrite Ht; auto. assert (Hxz:x<>0). contradict H1; subst x; auto. assert (Hc:Coprime p x). destruct (Prime_Coprime_Divide x H); auto. apply Divide_le in H3; auto. contradict Hx; auto. destruct ModInv with (n:=p) (a:=x) as [y [H3 H4]]; auto. exists (modN Hp y). split. apply ModEq_trans with (x*y); auto. split. apply in_seq. split. destruct (le_lt_dec 2 (modN Hp y)); auto. inversion l. assert (ModEq p x 1). replace x with (x*modN Hp y). apply ModEq_trans with (x*y); auto. rewrite H6. rewrite mult_1_r; auto. apply ModEq__modN_eq with p Hp x 1 in H5. rewrite modN_le_eq in H5; auto. rewrite modN_le_eq in H5; auto. contradict H1; subst x; auto. inversion H6. assert (ModEq p 0 1). apply ModEq_trans with (x*y); auto. replace 0 with (x*modN Hp y); auto. rewrite H8; auto. absurd (0=1); auto. apply ModEq__modN_eq with p Hp 0 1 in H7. rewrite modN_le_eq with p Hp 1 in H7; auto. rewrite modN_le_eq with p Hp 0 in H7; auto. inversion H8. simpl. rewrite <- Hu. assert (modN Hp y<p). auto. rewrite Ht in H5. apply le_S_n in H5. destruct (le_lt_or_eq (modN Hp y) t H5); auto. contradict H2. replace x with t; auto. cut (ModEq p t x). intros. apply ModEq__modN_eq with p Hp t x in H2. rewrite modN_le_eq in H2; auto. rewrite modN_le_eq in H2; auto.
  destruct (ModInv) with (n:=p) (a:=t) as [z [H7 H8]]; auto. contradict H0. rewrite Ht. rewrite H0. auto. apply ModEq_trans with z. apply ModEq_sym; apply H8. rewrite Ht. apply ModEq_m1_sq. apply H8. rewrite <- H6. apply ModEq_trans with (y*x); auto. rewrite mult_comm; auto. intros. rewrite <- modN_le_eq with p Hp z. apply ModEq__modN_eq; auto. apply in_seq in H5. destruct H5. apply lt_le_trans with (2+u); auto. simpl. rewrite <- Hu; auto. 
 rewrite mult_comm; auto. rewrite fold_right_Perm with (m:=map fst l++map snd l); auto. clear -H2. induction l as [|[a b] l]; simpl; auto. rewrite fold_right_Perm with (m:=b::map fst l++map snd l); auto. simpl. rewrite mult_assoc. inversion H2.  replace 1 with (1*1); auto. Qed.
Theorem Willson2: forall n, 2<=n -> ModEq n (fact (n-1)) (n-1) -> Prime n. Proof. intros. destruct (primeDivide n) as [[p H1 H2]|H1]; [|contradict H; auto]. assert (p<=n). apply Divide_le; auto. contradict H; subst n; auto. destruct (le_lt_or_eq p n H3). absurd (Divide p (fact (n-1)+1)). intros C. apply Divide_minus in C. apply Divide_le in C; auto. contradict C; auto. apply fact_Divide. apply le_S_n. destruct n; simpl; auto. rewrite <- minus_n_O; auto. contradict H1; subst p; auto. apply Divide_trans with n; auto. apply ModEq_trans with n; auto. replace n with (1*n+0) at 2; auto. simpl. repeat rewrite <- plus_n_O. auto. replace n with (n-1+1) at 2; auto. destruct n; simpl; auto. rewrite <- minus_n_O. rewrite plus_comm; auto. subst p; auto. Qed.

Inductive ModOrder (n:nat): relation nat := ModOrder_intro: forall a k, Coprime n a -> MinP (fun x=>x<>0 /\ ModEq n (pow a x) 1) k -> ModOrder n a k.
Hint Constructors ModOrder.

Definition modOrder: forall n a, Coprime n a -> {k|ModOrder n a k}. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. assert (a=1). apply GCD_unique with 0 a; auto. destruct (nat_eq_dec a 0); auto. subst a; contradict H; unfold Coprime; auto. subst a. exists 1. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H0. destruct m; auto.
  destruct (minP) with (P:=fun x=>x<>0/\ModEq n (pow a x) 1) (n:=S(totient n)).  intros. destruct (ModEq_dec n (pow a x) 1); [|right]. destruct (nat_eq_dec x 0); [right|left]; auto. contradict e; destruct e; auto. contradict n0; destruct n0; auto. destruct s as [m H1]. exists m. apply ModOrder_intro; auto. unfold totient in n0. destruct (totient_sig n) as [t Ht]. absurd (t<>0/\ModEq n (pow a t) 1); auto. split. apply Totient_nz with n; auto. apply Euler; auto. Defined.
Theorem ModOrder_nz: forall n a k, ModOrder n a k -> k<>0. Proof. intros. inversion H. inversion H1. destruct H4; auto. Qed.
Theorem ModOrder_unique: forall n a k j, ModOrder n a k -> ModOrder n a j -> k=j. Proof. intros. inversion H. inversion H0. inversion H2. inversion H6. apply le_antisym; auto. Qed.
Theorem ModOrder_Divide: forall n a k d, ModOrder n a k -> Divide k d <-> ModEq n (pow a d) 1. Proof. intros. split; intros. destruct (Divide_multN H0). subst d. rewrite pow_mult. clear H0. inversion H. inversion H1. destruct H4. clear -H7. induction x; simpl; auto. replace 1 with (1*1); auto. inversion H. subst a0 k0. inversion H2. subst n0. destruct H3. destruct (divmod k d) as [[q [r [H6 H7] _]]|];[|contradiction]. subst d. destruct (nat_eq_dec r 0). subst r. rewrite <- plus_n_O. auto. rewrite pow_plus in H0. rewrite pow_mult in H0.
  absurd (k<=r); auto. apply H4. split; auto. clear -H0 H1 H5. induction q. simpl in H0. rewrite <- plus_n_O in H0; auto. apply IHq. simpl in H0. apply ModEq_div with (pow a k). clear -H1. induction k; simpl; auto. rewrite mult_assoc. rewrite mult_1_r. apply ModEq_trans with 1; auto. Qed.
Theorem ModOrder_Totient: forall n a k t, ModOrder n a k -> Totient n t -> Divide k t. Proof. intros. destruct ModOrder_Divide with n a k t; auto. apply H2. apply Euler; auto. inversion H; auto. Qed.
Theorem ModOrder_pow: forall n a k, ModOrder n a k -> forall x y, ModEq n (pow a x) (pow a y) <-> ModEq k x y. Proof. intros n a k H. cut (forall x y, x<=y->ModEq n (pow a x) (pow a y) <-> ModEq k x y). intros. destruct (le_lt_dec x y); auto. split; intros. apply ModEq_sym. apply H0; auto. apply ModEq_sym. apply H0; auto. intros. replace y with (x+(y-x)); [|rewrite <- le_plus_minus]; auto. split; intros. cut (ModEq n (pow a (y-x)) 1). intros. destruct ModOrder_Divide with n a k (y-x); auto. replace x with (x+0) at 1; auto. apply ModEq_plus; auto. apply H4; auto.
  inversion H. revert H1. clear -H2. generalize (y-x). induction x; simpl; intros; auto. apply IHx. apply ModEq_div with a; auto. rewrite pow_plus. replace (pow a x) with (pow a x*1) at 1; [|apply mult_1_r]. apply ModEq_mult; auto. destruct (ModOrder_Divide) with n a k (y-x); auto. apply ModEq_sym. apply H2. apply ModEq_minus with x. rewrite <- plus_n_O; auto. Qed.
Theorem ModOrder_NoDup: forall n a k (Hn:n<>0), ModOrder n a k -> NoDup (map (fun x=>modN Hn (pow a x)) (seq 0 k)). Proof. intros. apply NoDup_map; auto. intros. apply modN_eq__ModEq in H2. destruct ModOrder_pow with n a k x y; auto. apply H3 in H2. destruct (ModEq_multN H2) as [[q H5]|[q H5]]. subst y. destruct q; auto. apply in_seq in H1. destruct H1. contradict H5; auto. simpl. rewrite <- plus_assoc. auto. subst x. destruct q; auto. apply in_seq in H0. destruct H0. contradict H5. simpl. rewrite <- plus_assoc; auto. Qed.
Theorem ModOrder_ModEq: forall n a k b, ModOrder n a k -> ModEq n a b -> ModOrder n b k. Proof. intros. inversion H. subst a0 k0. apply ModOrder_intro. apply GCD_ModEq with a; auto. inversion H2. destruct H3. subst n0. apply MinP_intro; auto. split; auto. apply ModEq_trans with (pow a k); auto. intros. destruct H5. apply H4; split; auto. apply ModEq_trans with (pow b m); auto. Qed.
Theorem ModOrder_PnumN: forall n a k, n<>0->ModOrder n a k-> PnumN (fun x=>exists k, ModEq n (pow a k) x) n k. Proof. intros. assert (Hk:k<>0). eapply ModOrder_nz; eauto. assert (P_dec: forall x, {exists m, ModEq n (pow a m) x}+{~exists m, ModEq n (pow a m) x}).  intros. destruct minP with (n:=k) (P:=fun y=>ModEq n (pow a y) x) as [[m H1]|H1]; [|left|right]. intros. destruct (ModEq_dec n (pow a x0) x); [left|right]; auto. exists m. inversion H1; auto. intros C. destruct C. absurd (ModEq n (pow a  (modN Hk x0)) x ); auto. apply ModEq_trans with (pow a x0); auto. destruct ModOrder_pow with n a k (modN Hk x0) x0; auto. replace k with (length (filter (dec2b P_dec) (seq 0 n))). apply PnumN_filter.
  replace k with (length (map (fun x=>modN H (pow a x)) (seq 0 k))). apply Perm_length. apply NoDup_incl_each_Perm; auto. apply NoDup_map; auto. intros. apply modN_eq__ModEq in H3. apply ModOrder_pow with n a k  x y in H3; auto. replace x with (modN Hk x). replace y with (modN Hk y); auto. apply modN_le_eq. apply in_seq in H2. destruct H2; auto. apply in_seq in H1. destruct H1; auto. intros x Hx. apply filter_In in Hx. destruct Hx. apply dec2b_true in H2.  destruct H2 as [m H3]. apply in_map_iff. exists (modN Hk m). split. replace x with (modN H x). apply ModEq__modN_eq. apply ModEq_trans with (pow a m); auto. destruct ModOrder_pow with n a k (modN Hk m) m; auto. apply modN_le_eq. apply in_seq in H1. destruct H1; auto. apply in_seq. split; auto.
  intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply filter_In. split. apply in_seq. split; auto. apply dec2b_true. exists y; auto. rewrite map_length. apply seq_length; auto. Qed.
Hint Resolve ModOrder_unique ModOrder_Divide ModOrder_Totient ModOrder_pow ModOrder_ModEq ModOrder_PnumN.

Inductive ModRoot: relation nat:= ModRoot_intro: forall n g t, Totient n t -> ModOrder n g t -> ModRoot n g.
Hint Constructors ModRoot.

Theorem ModRoot_ModEq: forall n a b, ModRoot n a -> ModEq n a b -> ModRoot n b. Proof. intros. inversion H. apply ModRoot_intro with t; auto. apply ModOrder_ModEq with a; auto. Qed.
Theorem Prime_ModRoot_map: forall p g (Hp:Prime p), ModRoot p g -> Perm (seq 1 (p-1)) (map (fun x=>modN (Prime_nz Hp) (pow g x)) (seq 1 (p-1))). Proof. intros. apply Perm_sym. apply NoDup_incl_Perm. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H1 H2]]. subst y. apply in_seq. split. cut (modN (Prime_nz Hp) (pow g z)<>0); intros. destruct (modN (Prime_nz Hp) (pow g z)); auto. intros C. replace 0 with (modN (Prime_nz Hp) 0) in C; auto. apply modN_eq__ModEq in C. inversion H. inversion H1. clear -H5 C Hp. induction z. simpl in C. apply ModEq_le_eq in C; auto. inversion C. simpl in C. apply ModEq_sym in C. apply Euclid_Prime in C; auto. destruct C; auto. absurd (p<=1); auto. inversion H5; auto. rewrite <- le_plus_minus; auto. apply NoDup_map; auto. intros. apply modN_eq__ModEq in H2. cut (forall a b, a<b -> In a (seq 1 (p-1)) -> In b (seq 1 (p-1)) -> ~ModEq p (pow g a) (pow g b)); intros. destruct (le_lt_dec x y). destruct (le_lt_or_eq x y l); auto. contradict H2; auto. apply ModEq_sym in H2; contradict H2; auto. intros C. rewrite <- mult_1_r with (n:=pow g a) in C. rewrite le_plus_minus with a b in C; auto. rewrite pow_plus in C.
  apply ModEq_div in C. inversion H. inversion H7. inversion H11. subst n g0 a0 k n0. assert (t<=b-a). apply H15; split; auto. contradict H3. apply Nat.sub_0_le in H3; auto. replace t with (p-1) in H8. apply in_seq in H4. destruct H4. apply in_seq in H5. destruct H5. contradict H8. apply lt_not_le. apply lt_le_trans with b. destruct b. inversion H5. destruct a. inversion H4. simpl. apply le_n_S. apply le_minus. auto. apply Totient_unique  with p; auto. inversion H. inversion H7. clear -Hp H10. induction a; auto. rewrite map_length; auto. Qed.
Theorem Prime_ModRoot_root: forall p g, Prime p -> ModRoot p g -> forall n, {k|ModEq p (pow g k) n & forall k', ModEq p (pow g k') n -> ModEq (p-1) k k'}+{Divide p n}. intros. destruct (Divide_dec p n) as [Hd|Hd]; [right; auto|left]. destruct findN with (P:=fun x=>x<>0/\ModEq p (pow g x) n) (n:=p) as [[y H1]|H1]. intros. simpl. destruct (nat_eq_dec x 0); [right|]; auto. contradict e. destruct e; auto. destruct (ModEq_dec p (pow g x) n); [left|right]; auto. intros C; destruct C; contradiction. destruct H1. exists y; auto. intros. apply ModOrder_pow with (k:=p-1) (x:=y) (y:=k') (n:=p) (a:=g); auto. inversion H0. replace (p-1) with t; auto. eapply Totient_unique with p; auto. apply ModEq_trans with n; auto. absurd (In (modN (Prime_nz H) n) (seq 1 (p-1))). intros C. apply Perm_In with (m:=map (fun x=>modN (Prime_nz H) (pow g x)) (seq 1 (p-1))) in C. apply in_map_iff in C. destruct C as [x [H2 H3]]. apply in_seq in H3. destruct H3. absurd (x<>0/\ModEq p (pow g x) n). apply H1. rewrite <- le_plus_minus in H4; auto. split. destruct x; auto. inversion H3. apply modN_eq__ModEq in H2; auto. apply Prime_ModRoot_map; auto. apply in_seq. split. destruct (le_lt_dec 1 (modN (Prime_nz H) n)); auto. contradict Hd. inversion l. apply modN_eq__ModEq with (Prime_nz H). rewrite modN_le_eq; auto. inversion H3. rewrite <- le_plus_minus; auto. Defined.
Theorem ModOrder_mult: forall p a b o s, Prime p -> ModOrder p a o -> ModOrder p b s -> Coprime o s -> ModOrder p (a*b) (o*s). Proof. intros. inversion H0. inversion H4. inversion H1. inversion H11. destruct H7. destruct H14. subst a0 k n a1 k0 n0. clear H0 H1 H4 H11. apply ModOrder_intro; auto. apply MinP_intro. split. intros C. apply mult_is_O in C. destruct C; contradiction. replace 1 with (1*1); auto. rewrite pow_mult2. apply ModEq_mult. rewrite mult_comm. rewrite pow_mult. clear -H17. induction s; simpl; auto. replace 1 with (1*1); auto. rewrite pow_mult. clear -H18. induction o; simpl; auto. replace 1 with (1*1); auto. intros. destruct H0.
  cut (Divide o m); intros. cut (Divide s m); intros. destruct (Divide_multN H4) as [q H6]. subst m. rewrite mult_comm in H5. apply Euclid in H5; auto. destruct (Divide_multN H5) as [r H6]. subst q. rewrite mult_comm. rewrite <- mult_assoc. destruct r; simpl; auto. apply Euclid with o; auto. apply ModOrder_Divide with (n:=p) (a:=b) (k:=s) (d:=o*m); auto. apply ModEq_div with (pow a (o*m)); auto. rewrite <- pow_mult2. rewrite mult_1_r. replace (o*m) with (m*o) at 2; auto. repeat rewrite pow_mult. apply ModEq_trans with 1. clear -H1. induction o; simpl; auto. replace 1 with (1*1); auto. clear -H17. induction m; simpl; auto. replace 1 with (1*1); auto. apply Euclid with s; auto. apply ModOrder_Divide with (n:=p) (a:=a) (k:=o) (d:=s*m); auto. apply ModEq_div with (pow b (s*m)); auto. rewrite <- pow_mult2. rewrite mult_1_r. rewrite mult_comm. replace (s*m) with (m*s) at 2; auto. repeat rewrite pow_mult. apply ModEq_trans with 1. clear -H1. induction s; simpl; auto. replace 1 with (1*1); auto. clear -H18. induction m; simpl; auto. replace 1 with (1*1); auto. Qed.
Theorem ModOrder_fold: forall p l, Prime p -> (forall q, In q l->ModOrder p (fst q) (snd q)) -> Forall (Coprime p) (map fst l) -> ForallR Coprime (map snd l) -> ModOrder p (fold_right mult 1 (map fst l)) (fold_right mult 1 (map snd l)). Proof. induction l as [|[a o] l]; simpl; intros; auto. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H3. destruct m; auto. inversion H1. inversion H2. subst x x0 l0 l1. apply ModOrder_mult; auto. apply (H0 (a,o)); auto. clear -H10. revert H10. generalize (map snd l) as m. induction m; simpl; intros; auto. Qed.
Theorem ModOrder_mult2: forall n m a o s l, Coprime n m -> ModOrder n a o -> ModOrder m a s -> LCM l o s -> ModOrder (n*m) a l. Proof. intros. apply ModOrder_intro. apply Coprime_sym; apply Coprime_mult. inversion H0; auto. inversion H1; auto. apply MinP_intro. split. inversion H2. destruct H3; auto. apply ModEq_Coprime_mult; auto. apply ModOrder_Divide with (d:=l) in H0. apply H0. inversion H2. destruct H3; destruct H6; auto. apply ModOrder_Divide with (d:=l) in H1.  apply H1. inversion H2; destruct H3; destruct H6; auto. intros x Hx. destruct Hx. inversion H2. apply H6. split; auto. split.  rewrite mult_comm in H4. apply ModEq_mult_rev in H4; auto. apply ModOrder_Divide with (d:=x) in H0. apply H0; auto. apply ModOrder_Divide with (d:=x) in H1. apply H1. apply ModEq_mult_rev with n; auto. Qed.
Theorem pow_m1_factorize: forall x n, x<>0 -> pow x n - 1 = (x-1)*(fold_right (fun k b=>pow x k+b) 0 (seq 0 n)). Proof. intros. assert (1<=x). destruct x; auto. induction n. simpl; auto. rewrite seqS. simpl. rewrite fold_right_app. simpl. rewrite <- plus_n_O. replace (fold_right (fun k b=>pow x k+b) (pow x n) (seq 0 n)) with (pow x n+fold_right (fun k b=>pow x k+b) 0 (seq 0 n)). rewrite mult_plus_distr_l. rewrite <- IHn. replace x with (x-1+1) at 1. rewrite mult_plus_distr_r. rewrite mult_1_l. rewrite Nat.add_sub_assoc; auto. rewrite plus_comm. rewrite <- le_plus_minus; auto. generalize (seq 0 n). generalize (pow x n). induction l; simpl; auto. rewrite plus_comm. rewrite <- plus_assoc. f_equal. rewrite plus_comm; auto. Qed.

Inductive PolyCoeff : list nat -> nat -> nat -> Prop:= PolyCoeff_intro: forall l o t, length l=o -> PolyCoeff (t::l) o t.
Hint Constructors PolyCoeff.
Fixpoint polyEval (l:list nat) (n:nat) := match l with nil => 0 |c::l' => c*pow n (length l')+polyEval l' n end.
Definition mod_minus: forall n (nz:n<>0) x, {y|Divide n (x+y) & y<n}. intros. destruct (nat_eq_dec (modN nz x) 0). exists 0; auto. apply Divide_plus; auto. apply modN_eq__ModEq with nz; auto. rewrite e. rewrite modN_le_eq; auto. exists (n-modN nz x). apply ModEq_trans with (modN nz x+(n- modN nz x)); auto. rewrite <- le_plus_minus; auto. replace n with (1*n) at 2; auto. apply multN_Divide. destruct n. absurd (0=0); auto. destruct (modN nz x). absurd (0=0); auto. simpl. apply le_n_S. apply le_minus. Defined.
Definition polyDiv: forall n (nz:n<>0) f o t a b, PolyCoeff f (S o) t -> Divide n (a+b) -> {g|PolyCoeff g o t & forall x, ModEq n (polyEval f x) ((x+a)*polyEval g x+polyEval f b)}. intros n Hn f o. revert f. induction o; intros. exists (t::nil); auto. intros. simpl. rewrite mult_1_r. rewrite <- plus_n_O. inversion H. subst f o t0. destruct l as [|c l]. inversion H1. destruct l. simpl. repeat rewrite mult_1_r. repeat rewrite <- plus_n_O. rewrite plus_assoc. apply ModEq_plus; auto. replace ((x+a)*t) with (t*(x+a)); auto. rewrite <- mult_plus_distr_l. apply ModEq_mult; auto. replace x with (x+0) at 1; auto. rewrite <- plus_assoc; auto. inversion H1.
  destruct f. exfalso; inversion H. destruct f as [|c f]. exfalso; inversion H; inversion H5. assert (n0=t). inversion H; auto. subst n0. destruct (mod_minus Hn (a*t)) as [d H1 H2]; auto. destruct (IHo (c+d::f) (c+d) a b) as [g H3 H4]; auto. inversion H; auto. exists (t::g). inversion H3. apply PolyCoeff_intro; simpl; auto. intros. assert (length f=S o). inversion H. inversion H9; auto. assert (length g=S o). inversion H3. rewrite <- H6; auto. assert (forall x, polyEval (t::c::f) x = t*pow x (o+2)+c*pow x (o+1)+polyEval f x). intros y. simpl. repeat rewrite plus_assoc. f_equal. f_equal. f_equal. rewrite H5; auto. rewrite plus_comm; auto. f_equal. f_equal. rewrite H5; rewrite plus_comm; auto. assert (forall x, polyEval (t::g) x = t*pow x (o+1)+polyEval g x). intros y. simpl. f_equal. f_equal. f_equal. rewrite plus_comm; auto. rewrite H8. rewrite mult_plus_distr_l. rewrite mult_plus_distr_r. rewrite H7. repeat rewrite <- plus_assoc. apply ModEq_plus. apply ModEq_sym. rewrite mult_comm. rewrite <- mult_assoc. apply ModEq_mult; auto. replace (o+2) with (S(o+1)). simpl. rewrite mult_comm; auto. rewrite plus_n_Sm; auto.
  apply ModEq_minus with (d*pow x (o+1)). rewrite plus_assoc. rewrite <- mult_plus_distr_r. rewrite plus_assoc. rewrite mult_assoc. rewrite <- mult_plus_distr_r. replace ((d+c)*pow x (o+1)+polyEval f x) with (0+polyEval (c+d::f) x). apply ModEq_plus. rewrite mult_comm. apply Divide_trans with (d+a*t); auto. rewrite plus_comm; auto. apply ModEq_trans with ((x+a)*polyEval g x+polyEval (c+d::f) b); auto. apply ModEq_plus; auto. simpl. repeat rewrite plus_assoc. apply ModEq_plus; auto. rewrite plus_comm. rewrite mult_plus_distr_r. apply ModEq_plus; auto. rewrite mult_assoc. apply ModEq_mult; auto. rewrite mult_comm. apply ModEq_minus with (a*t). apply ModEq_trans with 0; auto. rewrite <- mult_plus_distr_r. rewrite mult_comm. apply Divide_trans with (a+b); auto. simpl. f_equal. f_equal; auto. f_equal. rewrite plus_comm; auto. Qed.
Theorem polySolutionNum: forall p f o t c, Prime p -> PolyCoeff f o t -> ~Divide p t -> PnumN (fun x=>Divide p (polyEval f x)) p c -> c<=o. Proof. intros p f o t c Hp. revert f t c. assert (Hn:p<>0). contradict Hp; subst p; auto. induction o; intros. inversion H. destruct l. subst o t0 f. simpl in H1. replace c with 0; auto. eapply PnumN_unique; [|eapply H1]. rewrite mult_1_r. rewrite <- plus_n_O. auto. inversion H2. destruct (nat_eq_dec c 0) as [Hc|Hc]. subst c; auto. destruct (PnumN_ex H1). destruct (H2 Hc) as [d [H4 H5]]. destruct (mod_minus Hn d) as [e H6 H7]. destruct (polyDiv Hn e d H) as [g H8 H9]; auto. rewrite plus_comm; auto. apply PnumN_equiv with (Q:=fun x=>Divide p (x+e) \/ Divide p (polyEval g x)) in H1. assert (PnumN (fun x=>Divide p (x+e)) p 1). apply PnumN_one with d; auto. intros. rewrite <- modN_le_eq with p Hn y; auto. rewrite <- modN_le_eq with p Hn d; auto. apply ModEq__modN_eq. apply ModEq_minus with e; auto. rewrite plus_comm. apply ModEq_trans with 0; auto. rewrite plus_comm; auto. destruct (pnumN) with (P:=fun x=>Divide p (polyEval g x)) (n:=p) as [c' H11]. intros; apply Divide_dec. assert (c<=1+c'). eapply PnumN_or. eapply H10. eapply H11. auto. apply le_trans with (1+c'); auto. simpl. apply le_n_S. apply IHo with g t; auto. intros. split; intros. apply Euclid_Prime; auto. apply Divide_minus with (polyEval f d); auto. rewrite plus_comm. apply ModEq_trans with (polyEval f x); auto. apply ModEq_trans with ((x+e)*polyEval g x+polyEval f d); auto. apply Divide_plus; auto. destruct H11. rewrite mult_comm; apply Divide_trans with (x+e); auto. apply Divide_trans with (polyEval g x); auto. Qed.
Lemma repeat0_head: forall f x n, polyEval (repeat 0 n++f) x = polyEval f x. Proof. induction n; simpl; auto. Qed.
Lemma fold_app_length: forall {X:Type} l ll, length (fold_right (app (A:=X)) l ll) = fold_right plus (length l) (map (length (A:=X)) ll). Proof. induction ll; simpl; auto. rewrite app_length; f_equal; auto. Qed.
Theorem polyRootNum: forall p d, Prime p -> Divide d (p-1) -> PnumN (fun x=>ModEq p (pow x d) 1) p d. Proof. intros. assert (Hp:p-1<>0). contradict H. destruct p; auto. destruct p; auto. inversion H. destruct (Divide_multN H0) as [e H1]. assert (Hd:d<>0). contradict Hp. subst d. rewrite H1; auto. assert (He:e<>0). contradict Hp. subst e. rewrite H1; auto. assert (PnumN (fun x=>ModEq p (pow x (e*d)) 1) p (e*d)). rewrite <- H1. cut (forall x, 1<=x->x<=p->PnumN (fun x=>ModEq p (pow x (p-1)) 1) x (x-1)). intros. apply H2; auto. intros x Hx. induction Hx; intros. simpl. apply PnumN_NP; auto. rewrite pow0n; auto. intros C. apply Divide_le in C; auto. contradict C; auto. rewrite <- minus_Sn_m; auto. apply PnumN_P; auto. apply Fermat; auto. contradict H2. apply Divide_le in H2; auto. contradict Hx; subst m; auto. destruct (pnumN) with (P:=fun x=>ModEq p (pow x d) 1) (n:=p) as [c H3]. intros. apply ModEq_dec. replace d with c at 1; auto. apply le_antisym.
  assert (H4:PolyCoeff (1::repeat 0 (d-1)++p-1::nil) d 1). apply PolyCoeff_intro. rewrite app_length. rewrite repeat_length. simpl. rewrite plus_comm. rewrite <- le_plus_minus; auto. apply (polySolutionNum H H4). intros C. apply Divide_le in C; auto. contradict C; auto. eapply PnumN_equiv; [|eapply H3]. simpl; intros. rewrite app_length. rewrite repeat_length. rewrite <- plus_assoc. simpl. replace (d-1+1) with d. rewrite repeat0_head. simpl. rewrite mult_1_r. rewrite <- plus_n_O. split; intros. apply ModEq_trans with (1+(p-1)); auto. rewrite <- le_plus_minus; auto. apply Divide_refl. apply ModEq_minus with (p-1). rewrite plus_comm. apply ModEq_trans with 0; auto. rewrite plus_comm. rewrite <- le_plus_minus; auto. apply Divide_refl. rewrite plus_comm. apply le_plus_minus; auto.
  rewrite <- mult_1_l at 1. apply plus_le_reg_l with ((e-1)*d). rewrite <- mult_plus_distr_r. rewrite plus_comm. rewrite <- le_plus_minus; auto. destruct pnumN with (P:=fun x=>Divide p (polyEval (fold_right (app (A:=nat)) (1::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x)) (n:=p) as [f H4]. intros. apply Divide_dec. assert (f<=(e-1)*d). assert (PolyCoeff (fold_right (app (A:=nat)) (1::nil) (repeat (1::repeat 0 (d-1)) (e-1))) ((e-1)*d) 1). generalize (e-1). induction n; simpl; auto. apply PolyCoeff_intro; auto. rewrite app_length. rewrite repeat_length. inversion IHn. rewrite <- H6. simpl. rewrite <- plus_n_Sm. rewrite <- plus_Sn_m. f_equal. destruct d. contradict Hd; auto. simpl. rewrite <- minus_n_O; auto. apply (polySolutionNum H H5); auto. intros C. apply Divide_le in C; auto. contradict C; auto. apply le_trans with (f+c); [|apply plus_le_compat_r]; auto. eapply PnumN_or. eapply H4. eapply H3. simpl. eapply PnumN_equiv; [|eapply H2]. intros; simpl. clear H2 H3 H4 H5 c f. assert (polyEval (fold_right (app (A:=nat)) (1::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x = polyEval (fold_right (app (A:=nat)) (0::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x+1). generalize (e-1). induction n; simpl; auto. repeat rewrite <- plus_assoc. f_equal. f_equal. repeat rewrite app_length. f_equal. repeat rewrite fold_app_length; auto. simpl. repeat rewrite repeat0_head; auto. assert (polyEval (fold_right (app (A:=nat)) (1::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x * pow x d = polyEval (fold_right (app (A:=nat)) (0::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x + pow x (e*d)). replace (e*d) with (S(e-1)*d).
  generalize (e-1). induction n; simpl; repeat rewrite <- plus_n_O; auto. rewrite mult_plus_distr_r. repeat rewrite repeat0_head; repeat rewrite app_length; repeat rewrite repeat_length; repeat rewrite fold_app_length. rewrite <- pow_plus. rewrite plus_comm. f_equal. rewrite IHn. rewrite plus_comm. f_equal. f_equal. simpl. rewrite map_repeat. simpl. rewrite repeat_length. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O. clear -Hd. induction n; simpl; auto. rewrite <- plus_n_O. rewrite plus_comm. apply le_plus_minus; auto. rewrite IHn. repeat rewrite plus_assoc. f_equal; auto. f_equal. rewrite map_repeat. simpl. rewrite repeat_length. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O. rewrite plus_comm. f_equal. clear -Hd. induction n; simpl. rewrite plus_comm. rewrite <- le_plus_minus; auto. rewrite <- IHn. repeat rewrite plus_assoc. f_equal; auto. f_equal. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O; auto. split; intros. destruct (Prime_Coprime_Divide (polyEval (fold_right (app (A:=nat)) (1::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x)  H); auto; right. eapply ModEq_div. eapply H5. rewrite H3. rewrite mult_1_r. rewrite H2; auto. apply ModEq_minus with (polyEval (fold_right (app (A:=nat)) (0::nil) (repeat (1::repeat 0 (d-1)) (e-1))) x). rewrite <- H3. rewrite <- H2. destruct H4. apply ModEq_trans with 0; auto. rewrite mult_comm. apply ModEq_sym. eapply Divide_trans. eapply H4. auto. rewrite <- mult_1_r. auto. Qed.

Theorem Prime_ModRoot: forall p, Prime p -> exists a, ModRoot p a. Proof. intros. assert (2<=p). auto. assert (Hp:p-1<>0). contradict H0. apply le_not_lt. destruct p; auto. destruct p; auto. inversion H0. apply le_lt_or_eq in H0. destruct H0; [|subst p; exists 1]. destruct (fundamental2 (p-1)) as [[pl [H1 [H2 [H3 H4]]]]|H1]; [|contradiction]. cut (exists l, map snd l = map (fun p=>pow (fst p) (snd p)) pl /\forall q, In q l->ModOrder p (fst q) (snd q)). intros. destruct H5 as [l [H5 H6]]. exists (fold_right mult 1 (map fst l)). apply ModRoot_intro with (p-1); auto. replace (p-1) with (fold_right mult 1 (map snd l)). apply ModOrder_fold; auto. apply Forall_forall. intros q Hq. apply in_map_iff in Hq. destruct Hq as [[r s] [H7 H8]]. simpl in H7. subst r. apply H6 in H8. simpl in H8. inversion H8; auto. rewrite H5. clear -H2 H3 H4. induction pl as [|[p c] pl]; simpl; auto. inversion H2. inversion H3. inversion H4. subst x x0 x1 l l0 l1. apply ForallR_cons; auto. intros y Hy.  apply in_map_iff in Hy. destruct Hy as [[q d] [H10 H11]]. subst y. simpl. destruct (Prime_pow_Coprime_Divide (pow q d) c H1); auto. absurd (In p (map fst pl)); auto. replace p with q. apply in_map_iff. exists (q,d); auto. symmetry. apply repeat_spec with d. apply Prime_mult_In; auto. cut (Prime q). intros. clear -H0. induction d; simpl; auto. apply Forall_forall with (P:=Prime) (l:=map fst pl); auto. apply in_map_iff. exists (q,d); auto. replace (fold_right mult 1 (repeat q d)) with (pow q d); auto. clear -d. induction d; simpl; auto. rewrite H1. rewrite H5. clear -pl. induction pl; simpl; auto.
  cut (forall q, In q pl -> exists a, ModOrder p a (pow (fst q) (snd q))). intros. clear -H5. induction pl. exists nil; simpl; auto. split; auto. intros. destruct H. destruct (H5 a) as [o H6]; auto. destruct IHpl as [l [H7 H8]]. intros. apply H5; auto. exists ((o, pow (fst a) (snd a))::l). simpl. split. f_equal; auto. intros. destruct H; auto. subst q. simpl. auto. 
  intros. destruct q as [q c]. simpl. assert (c<>0). apply Forall_forall with (l:=map snd pl) (P:=fun x=>x<>0); auto. apply in_map_iff. exists (q,c); auto. assert (Prime q). apply Forall_forall with (l:=map fst pl) (P:=Prime); auto. apply in_map_iff. exists (q,c); auto. assert (Divide (pow q c) (p-1)). rewrite H1. clear -H5. induction pl. destruct H5. destruct H5. simpl. subst a. simpl; rewrite mult_comm; auto. simpl. eapply Divide_trans. eapply IHpl; auto. auto. assert (Divide (pow q (c-1)) (p-1)). apply Divide_trans with (pow q c); auto. apply pow_Prime_Divide; auto. exists (c-1); split; auto. apply le_minus. assert (PnumN (fun x=>ModEq p (pow x (pow q c)) 1) p (pow q c)). apply polyRootNum; auto. assert (PnumN (fun x=>ModEq p (pow x (pow q (c-1))) 1) p (pow q (c-1))). apply polyRootNum; auto. destruct (PnumN_lt) with (P:=fun x=>ModEq p (pow x (pow q (c-1))) 1) (Q:=fun x=>ModEq p (pow x (pow q c)) 1) (n:=p) (a:=pow q (c-1)) (b:=pow q c) as [x [Ha [Hb Hc]]]; auto. destruct c. contradict H6; auto. simpl. rewrite <- minus_n_O. remember (pow q c) as a. destruct a. symmetry in Heqa. contradict Heqa. apply pow_nz. contradict H7; subst q; auto. destruct q. contradict H7; auto. destruct q. contradict H7; auto. simpl. rewrite <- plus_n_Sm. auto.
  exists x. assert (Coprime p x). destruct (Prime_Coprime_Divide  x H); auto. contradict Ha. apply Divide_le in H12; auto. intros C; subst x. replace (pow 0 (pow q c)) with 0 in Hc. absurd (0=1); auto. apply ModEq_le_eq with p; auto. rewrite pow0n; auto. destruct (modOrder H12) as [k H13]. destruct (ModOrder_Divide (pow q c) H13). destruct (ModOrder_Divide (pow q (c-1)) H13). apply H15 in Hc. apply pow_Prime_Divide in Hc; auto. destruct Hc as [m [H18 H19]]. subst k. apply le_lt_or_eq in H19. destruct H19; [|subst m]; auto. contradict Hb. apply H16. apply pow_Prime_Divide; auto. exists m; split; auto. destruct c. contradict H6; auto. simpl. rewrite <- minus_n_O; auto. apply ModRoot_intro with (2-1); auto. simpl. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct m; auto. destruct H0. contradict H0; auto. Qed.
Definition modRoot: forall p, Prime p -> {a|ModRoot p a}. intros. destruct minP with (P:=fun x=>Coprime p x/\ModOrder p x (p-1)) (n:=p) as [[a H1]|H1]. intros. destruct (Coprime_dec p x); [|right]. destruct (modOrder c) as [k H1]. destruct (nat_eq_dec k (p-1)); [subst k;left|right]; auto. contradict n. destruct n. apply ModOrder_unique with p x; auto. contradict n; destruct n; auto. exists a. inversion H1. destruct H0. apply ModRoot_intro with (p-1); auto. exfalso. destruct (Prime_ModRoot H) as [a Ha]. assert (Hp:p<>0). contradict H; subst p; auto. absurd (Coprime p (modN Hp a)/\ModOrder p (modN Hp a) (p-1)); auto. apply ModRoot_ModEq with (b:=modN Hp a) in Ha; auto. inversion Ha. inversion H2. split; auto. replace (p-1) with t; auto. apply Totient_unique with p; auto. Defined.

Theorem Prime_pow_ModRoot: forall p e, Prime p -> 3<=p -> exists a, ModRoot (pow p e) a. Proof. intros. assert (Hp:p-1<>0). destruct p. contradict H; auto. destruct p. contradict H; auto. discriminate. destruct (nat_eq_dec e 0) as [He|He]. subst e. exists 1; simpl. apply ModRoot_intro with 1; auto. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H1. destruct m; auto. assert (exists a, ModRoot p a /\ exists k, ModEq (p*p) (pow a (p-1)) (k*p+1) /\ 0<k<p). destruct (Prime_ModRoot H) as [a H1]. inversion H1. inversion H3. inversion H7. destruct H10. subst n g a0 k n0. assert (t=p-1). apply Totient_unique with p; auto. subst t. destruct (ModEq_multN_lt H13) as [q H12]; auto. destruct (divmod p q) as [[s [r [H14 H15] _]]|H14]; [|subst p; contradict H]; auto. destruct (nat_eq_dec r 0) as [Hr|Hr]. subst r. exists (a+p). split. apply ModRoot_intro with (p-1); auto. apply ModOrder_intro; auto. apply GCD_ModEq with a; auto. replace (a+p) with (1*p+a); auto. rewrite mult_1_l; auto. apply MinP_intro. split; auto. apply ModEq_trans with (pow a (p-1)); auto. apply ModEq_pow. replace (a+p) with (1*p+a); auto. rewrite mult_1_l; auto. intros. destruct H4. apply H11. split; auto. apply ModEq_trans with (pow (a+p) m); auto. apply ModEq_pow. replace a with (a+0) at 1; auto. apply ModEq_plus; auto. apply Divide_refl. rewrite <- plus_n_O in H14. subst q. rewrite <- mult_assoc in H12. destruct (divmod p ((p-1)*pow a (p-2))) as [[q [r [H14 H16] _]]|H14]; [|contradict H; subst p; auto]. assert (r<>0). intros C; subst r. absurd (Divide p ((p-1)*pow a (p-1))). rewrite H12. intros C. rewrite mult_plus_distr_l in C. apply Divide_minus in C. apply Divide_le in C; auto. contradict C. rewrite mult_1_r. apply lt_not_le. destruct p. contradict H; auto. simpl. rewrite <- minus_n_O; auto. rewrite mult_1_r. destruct p. contradict H; auto. destruct p. contradict H; auto. discriminate. repeat rewrite mult_assoc; auto. replace ((p-1)*pow a (p-1)) with (a*((p-1)*pow a (p-2))). rewrite H14. rewrite <- plus_n_O. rewrite mult_assoc; auto. rewrite mult_comm. rewrite <- mult_assoc. f_equal. replace (p-1) with (S(p-2)); auto. rewrite powS; auto. rewrite minus_Sn_m; auto.
  exists r; split; auto. rewrite poly_combi. replace (seq 0 (S(p-1))) with ((0::1::nil)++seq 2 (p-2)). rewrite map_app. rewrite fold_plus_app. simpl. rewrite combi'_0. repeat rewrite mult_1_r. repeat rewrite mult_1_l. rewrite <- minus_n_O. rewrite <- plus_n_O. rewrite <- plus_assoc. rewrite plus_comm. apply ModEq_plus. replace (r*p) with (r*p+0). apply ModEq_plus. replace (p-1-1) with (p-2). replace (combi' (p-1) 1) with (p-1). rewrite H14. rewrite mult_plus_distr_r. rewrite <- mult_assoc; auto. rewrite combi'_1; auto. destruct p. contradict H; auto. destruct p; auto. remember (seq 2 (p-2)) as l. assert (forall x, In x l->2<=x). subst l. generalize (p-2). generalize 2. intros n n0. revert n. induction n0; intros. inversion H5. inversion H5. subst x; auto. apply IHn0 in H8. apply lt_le_weak; auto. clear -H5. induction l; simpl; auto. replace 0 with (0+0); auto. apply ModEq_plus; auto. simpl. assert (2<=a0); auto. apply ModEq_sym; apply Divide_trans with (pow p a0); auto. clear H5. induction H. rewrite powS. rewrite pow1; auto. rewrite powS. apply Divide_trans with (pow p m); auto. rewrite plus_comm; auto. rewrite H12; auto. replace (p-1) with (S(p-2)); auto. destruct p. contradict H; auto. destruct p; simpl. contradict H; auto. rewrite <- minus_n_O; auto. exists a. split; auto. exists r. split; auto. subst q. rewrite H12. rewrite mult_plus_distr_r. rewrite <- mult_assoc. rewrite <- plus_assoc; auto.
  destruct H1 as [a [H1 [k [Hk Hk']]]]. exists a. inversion H1. subst n g. replace t with (p-1) in H3; [|apply Totient_unique with p]; auto. clear H1 H2. assert (Coprime p a). inversion H3; auto. apply ModRoot_intro with ((p-1)*pow p(e-1)); auto. assert (Coprime (pow p e) a). destruct (Prime_pow_Coprime_Divide a e H); auto. destruct (modOrder H2) as [o H4]. replace ((p-1)*pow p (e-1)) with o; auto. assert (Divide o ((p-1)*pow p (e-1))). eapply ModOrder_Divide in H4. eapply H4. apply Euler; auto. destruct (powDivide o (Prime_le H)) as [[b [c H6 H7]]|H6]. rewrite mult_comm in H6. subst o. assert (Divide c (p-1)). apply Euclid with (pow p (e-1)). destruct (Prime_pow_Coprime_Divide c (e-1) H); auto; contradiction. apply Divide_trans with (c*pow p b). rewrite mult_comm; auto. replace (pow p (e-1)*(p-1)) with ((p-1)*pow p (e-1)); auto. assert (ModEq p (pow a (c*pow p b)) 1). apply ModEq_mult_rev with (pow p (e-1)). rewrite mult_comm. rewrite <- powS. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O. inversion H4; inversion H9; destruct H12; auto. assert (Divide (p-1) c). apply Euclid with (pow p b). destruct (Prime_pow_Coprime_Divide (p-1) b H); auto. apply Divide_le in H9; auto. contradict H9. apply lt_not_le. destruct p. contradict H; auto. simpl. rewrite <- minus_n_O; auto. rewrite mult_comm. apply ModOrder_Divide with (d:=c*pow p b) in H3. apply H3; auto. assert (c=p-1). apply Divide_antisym; auto. subst c.
  f_equal. f_equal. apply Divide_div in H5; auto. apply pow_Prime_Divide in H5; auto.  destruct H5 as [c [H5 H10]]; auto. apply pow_cancel_r in H5; auto. subst c. apply le_lt_or_eq in H10. destruct H10; auto. destruct (le_lt_dec e 1) as [H10|H10]. inversion H10. subst e. rewrite pow1 in H4. assert ((p-1)*pow p b=(p-1)*1). apply ModOrder_unique with p a; auto. rewrite mult_1_r; auto. apply Nat.mul_cancel_l in H11. replace 1 with (pow p 0) in H11; auto. apply pow_cancel_r in H11. subst b; auto. auto. auto. inversion H12; contradiction. absurd (ModEq (pow p e) (pow a ((p-1)*pow p (e-2))) 1).
  cut (exists k, ModEq (pow p e) (pow a ((p-1)* pow p (e-2))) (k*pow p (e-1)+1) /\ 0<k<p); intros. intros C. destruct H11 as [k' [H11 [H12 H13]]]. assert (ModEq (pow p e) (k'*pow p (e-1)+1) 1). eapply ModEq_trans; [| eapply C]; auto. destruct (ModEq_multN_lt H14) as [q H15]. apply le_trans with p; auto. rewrite plus_comm in H15. symmetry in H15. rewrite plus_comm in H15. inversion H15. replace e with (S(e-1)) in H17 at 1. rewrite powS in H17. rewrite mult_assoc in H17. apply Nat.mul_cancel_r in H17. subst k'. destruct q. contradict H12; auto. simpl in H13. contradict H13; auto. auto. destruct e. contradict He; auto. simpl; rewrite <- minus_n_O; auto. clear He H2 H4 H5. induction H10. simpl. repeat rewrite mult_1_r. exists k; auto.
  destruct IHle as [k' [H11 [H12 H13]]]. repeat rewrite <- minus_Sn_m; auto. repeat rewrite powS. destruct (ModEq_multN_lt H11) as [q H14]. replace m with (S(m-1)) at 2. rewrite powS. replace p with (S(p-1)) at 2. simpl. rewrite plus_comm. apply plus_lt_le_compat. apply le_trans with p; auto. apply pow_le; auto. destruct m. inversion H10. destruct m. contradict H10; auto. simpl; auto. apply mult_le_compat_r. apply le_S_n. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O; auto. rewrite le_plus_minus with (n:=1); auto. rewrite le_plus_minus with (n:=1); auto. exists k'. split; auto. replace ((p-1)*(p*pow p (m-2))) with (p*((p-1)*pow p (m-2))). rewrite pow_mult. rewrite H14.
  apply le_lt_or_eq in H10. destruct H10 as [H10|H10]. rewrite plus_assoc. rewrite plus_comm. rewrite poly_combi. replace (seq 0 (S p)) with ((0::1::nil)++seq 2 (p-1)); auto. rewrite map_app. rewrite fold_plus_app. simpl. rewrite combi'_0. repeat rewrite pow_1n. rewrite combi'_1. repeat rewrite mult_1_l. repeat rewrite mult_1_r. rewrite <- plus_n_O. replace (k' * (p * pow p (m - 1)) + 1) with (1+(k' * (p * pow p (m - 1))) + 0); auto. apply ModEq_plus. apply ModEq_plus; auto. rewrite mult_plus_distr_l. replace (p*(q*pow p m)) with (q*(p*pow p m)). replace (p*(k'*pow p (m-1))) with (k'*(p*pow p (m-1))); auto. repeat rewrite mult_assoc. f_equal; auto. repeat rewrite mult_assoc. f_equal; auto. remember (seq 2 (p-1)) as l. assert (forall x, In x l->2<=x<=p). subst l. intros. apply in_seq in H2. destruct H2. split; auto. simpl in H4. rewrite minus_Sn_m in H4; simpl in H4; auto. rewrite <- minus_n_O in H4; auto. clear -H10 H2. induction l; simpl; auto. apply ModEq_sym. replace 0 with (0+0) at 1; auto. apply ModEq_plus; auto. assert (2<=a<=p); auto. destruct H. rewrite pow_1n. rewrite mult_1_r. rewrite <- powS. apply Divide_trans with (pow (q*pow p m+k'*pow p (m-1)) a); auto. rewrite plus_comm. rewrite poly_combi. replace (seq 0 (S a)) with ((0::nil)++seq 1 a); auto. rewrite map_app. simpl. apply Divide_plus. rewrite combi'_0. rewrite mult_1_l. rewrite mult_1_r. rewrite <- minus_n_O. rewrite pow_mult2. rewrite <- pow_mult. apply Divide_trans with (pow p (a*(m-1))); auto. rewrite <- powS. rewrite le_plus_minus with (n:=S m) (m:=a*(m-1)); auto. rewrite pow_plus; rewrite mult_comm; auto. destruct a. inversion H. destruct a. contradict H; auto. simpl. destruct m. inversion H10. destruct m. contradict H10; auto. destruct m. contradict H10; auto. simpl. repeat rewrite <- plus_n_Sm. repeat apply le_n_S. auto. clear H2 IHl l. remember (seq 1 a) as l. assert (forall x, In x l->1<=x). intros. subst l. apply in_seq in H1. destruct H1; auto. clear -H10 H H1. induction l; simpl; auto. apply Divide_plus; auto. assert (1<=a0); auto. repeat rewrite pow_mult2. repeat rewrite <- pow_mult. destruct a0. inversion H0. destruct a0. rewrite mult_1_l. apply Divide_trans with (pow p ((a-1)*(m-1))*pow p m). rewrite <- pow_plus.
  rewrite <- powS. rewrite le_plus_minus with (m:=(a-1)*(m-1)+m) (n:=S m); auto. rewrite pow_plus; rewrite mult_comm; auto. remember ((a-1)*(m-1)) as c. destruct c. symmetry in Heqc. apply mult_is_O in Heqc. destruct Heqc. destruct a. inversion H. destruct a. contradict H; auto. inversion H2. destruct m. inversion H10. destruct m. contradict H10; auto. inversion H2. simpl. auto. replace (combi' a 1 * (pow k' (a - 1) * pow p ((a - 1) * (m - 1))) *(pow q 1 * pow p m)) with (combi' a 1 * pow k' (a-1)*pow q 1*(pow p ((a-1)*(m-1))*pow p m)); auto. repeat rewrite mult_assoc. f_equal. repeat rewrite <- mult_assoc. f_equal. f_equal. auto. apply Divide_trans with (pow p (S (S a0)*m)). rewrite <- powS. rewrite le_plus_minus with (m:=S (S a0)*m) (n:=S m). rewrite pow_plus; rewrite mult_comm; auto. simpl. destruct m. inversion H10. simpl. rewrite <- plus_n_Sm. repeat apply le_n_S; auto. repeat rewrite mult_assoc; auto. rewrite <- plus_n_O; auto. replace (S p) with (S (S (p-1))); auto. f_equal. destruct p. contradict H; auto. simpl. rewrite <- minus_n_O; auto.
  subst m. repeat rewrite pow1. rewrite <- powS. rewrite plus_assoc. rewrite plus_comm. rewrite (poly_combi). replace (seq 0 (S p)) with ((0::1::nil)++seq 2 (p-1)). rewrite map_app. rewrite fold_plus_app. simpl. rewrite combi'_0. rewrite combi'_1. repeat rewrite pow_1n. repeat rewrite mult_1_r. rewrite <- plus_n_O. replace (k'*(p*p)+1) with (1+k'*(p*p)+0). apply ModEq_plus. apply ModEq_plus; auto. rewrite mult_plus_distr_l. replace (k'*(p*p)) with (0+k'*(p*p)); auto. apply ModEq_plus. apply ModEq_sym. apply Divide_mult; auto. repeat rewrite mult_assoc. apply ModEq_mult; auto. replace (p*k') with (k'*p); auto. remember (seq 2 (p-1)) as l. assert (forall x, In x l->2<=x<=p). intros. subst l. apply in_seq in H2. destruct H2. split; auto. simpl in H4. rewrite minus_Sn_m in H4; auto. simpl in H4. rewrite <- minus_n_O in H4; auto. clear -H H0 H2 H12 H13. induction l; simpl; auto. replace 0 with (0+0); auto. apply ModEq_plus; auto. simpl. rewrite pow_1n. rewrite mult_1_r. apply ModEq_sym. assert (2<=a<=p); auto. clear H2 IHl. destruct H1. replace (q*(p*p)) with (q*p*p); auto. rewrite <- mult_plus_distr_r. rewrite pow_mult2. apply le_lt_or_eq in H1. destruct H1. apply Divide_trans with (pow p a). rewrite le_plus_minus with (m:=a) (n:=3); auto. simpl. repeat apply Divide_mult. rewrite mult_comm; auto. rewrite mult_assoc; auto. subst a. replace (combi' p 2*(pow (q*p+k') 2*pow p 2)) with (pow p 2*combi' p 2*pow (q*p+k') 2). rewrite powS. rewrite pow1. repeat rewrite <- mult_assoc. apply Divide_mult. apply Divide_mult. apply Divide_trans with (combi' p 2); auto. apply combi'_odd_2. intros C. apply Prime_Divide in C; auto. destruct C. inversion H1. contradict H0; subst p; auto. rewrite mult_comm; auto. rewrite <- mult_assoc. rewrite mult_comm. rewrite mult_assoc; auto. rewrite <- plus_n_O; auto. replace (S p) with (S(S(p-1))); auto. f_equal. destruct p. contradict H; auto. simpl. rewrite <- minus_n_O; auto. repeat rewrite mult_assoc. f_equal; auto.
  apply ModOrder_Divide with (d:=(p-1)*pow p (e-2)) in H4. apply H4. apply Divide_mult. apply pow_Prime_Divide; auto. exists b; split; auto. apply le_S_n. rewrite minus_Sn_m; auto. subst o. inversion H4. inversion H7. destruct H10. contradict H10; auto. Qed.

(* Carmichael function *)
Definition carm_func (p e:nat) := (if le_lt_dec p 2 then if le_lt_dec e 2 then (pow 2 (e-1)) else (pow 2 (e-2)) else ((p-1)*pow p (e-1))).
Inductive Carmichael : relation nat :=
|Carm_0: Carmichael 0 1
|Carm_1: Carmichael 1 1
|Carm_p: forall p e, Prime p -> e<>0 -> Carmichael (pow p e) (carm_func p e)
|Carm_m: forall n m a b l, Coprime n m -> Carmichael n a -> Carmichael m b -> LCM l a b -> Carmichael (n*m) l
.
Hint Constructors Carmichael.
Lemma carm_func_nz: forall p e, Prime p -> e<>0 -> carm_func p e <>0. Proof. intros. unfold carm_func. destruct (le_lt_dec p 2). destruct (le_lt_dec e 2); auto. intros C. apply mult_is_O in C. destruct C. destruct p. inversion l. destruct p. contradict l; auto. inversion H1. contradict H1; auto. Qed.
Theorem Carmichael_nz: forall n c, Carmichael n c -> c<>0. Proof. intros. induction H; auto. apply carm_func_nz; auto. apply LCM_nz with a b; auto. Qed.

Lemma Carmichael_1: forall x, Carmichael 1 x -> x=1. Proof. remember 1 as n. intros. revert Heqn. induction H; intros; auto. replace 1 with (pow p 0) in Heqn; auto. apply pow_cancel_r in Heqn; auto. contradiction. apply mult_is_one in Heqn. destruct Heqn. subst n m. assert (a=1); auto. assert (b=1); auto. subst a b. simpl. apply LCM_unique with 1 1; auto. Qed.
Lemma Carmichael_0: forall x, Carmichael 0 x -> x=1. Proof. intros. remember 0 as y in H. revert Heqy. induction H; intros; auto. contradict Heqy; auto. apply mult_is_O in Heqy. destruct Heqy. subst n. assert (m=1). apply GCD_unique with 0 m; auto. apply GCD_0n. contradict H. subst m; apply GCD_00; auto. subst m. apply Carmichael_1 in H1. assert (a=1); auto. subst a b. apply LCM_unique with 1 1; auto.   subst m. assert (b=1); auto. replace n with 1 in H0. apply Carmichael_1 in H0. subst a b. apply LCM_unique with 1 1; auto. apply GCD_unique with n 0; auto. apply GCD_sym; apply GCD_0n. contradict H; subst n; apply GCD_00. Qed.
Theorem Carmichael_PrimePow: forall p e, Prime p->e<>0->Carmichael (pow p e) (carm_func p e) /\ forall x, Carmichael (pow p e) x -> x=carm_func p e. Proof. intros. split; auto. intros. remember (pow p e) as y. revert Heqy. induction H1; intros. symmetry in Heqy. contradict Heqy; auto. replace 1 with (pow p 0) in Heqy; auto. apply pow_cancel_r in Heqy; auto. subst e. contradict H0; auto. assert (p0=p). apply repeat_spec with e. apply Prime_mult_In; auto. clear -H. induction e; simpl; auto. replace (fold_right mult 1 (repeat p e)) with (pow p e). rewrite <- Heqy. destruct e0. contradict H2; auto. rewrite powS. rewrite mult_comm; auto. clear -e. induction e; auto. rewrite powS. rewrite IHe. auto. subst p0. apply pow_cancel_r in Heqy; auto.
  destruct (Coprime_mult_pow_Prime ((p,e)::nil) H1) as [la [lb [H3 H4] H5]]; simpl; auto. rewrite mult_1_r; auto. apply Perm_one in H5. destruct la; destruct lb; inversion H5. subst p0 lb. simpl in H3. simpl in H4. rewrite mult_1_r in H4. apply IHCarmichael2 in H4. subst n. apply Carmichael_1 in H1_. subst a b. eapply LCM_unique. eapply H2. apply LCM_sym; apply LCM_1. apply carm_func_nz; auto. destruct la; [|inversion H8]. subst p0. simpl in H3. simpl in H4. rewrite mult_1_r in H3. subst n m. rewrite IHCarmichael1 in H2; auto. apply Carmichael_1 in H1_0. subst b. eapply LCM_unique. eapply H2. apply LCM_1. apply carm_func_nz; auto. destruct la; inversion H8. Defined.
Theorem Carmichael_pow_mult_fold: forall l c, Forall Prime (map fst l) -> NoDup (map fst l) -> Forall (fun n=>n<>0) (map snd l) -> LCMs c (map (fun p=>carm_func (fst p) (snd p)) l) -> Carmichael (pow_mult_fold l) c. Proof. induction l as [|[p e] l]; simpl; intros. replace c with 1; auto. apply LCMs_unique with nil; auto. apply MinP_intro; auto. intros. destruct H3. destruct m; auto. destruct (lcms_sig (map (fun p=>carm_func (fst p) (snd p)) l)) as [[b H3]|H3]. apply LCMs_cons_rev with (a:=b) in H2; auto. inversion H. inversion H0. inversion H1. subst x x0 x1 l0 l1 l2. apply Carm_m with (carm_func p e) b; auto. destruct (Prime_pow_Coprime_Divide (pow_mult_fold l) e H6); auto. contradict H10. clear -H4 H7 H6 H15. induction l as [|[q f] l]; simpl in H4. absurd (p<=1); auto. apply Euclid_Prime in H4; auto. simpl. destruct H4; [left|right]. symmetry. apply repeat_spec with f. apply Prime_mult_In; auto. inversion H7. clear -H2; induction f; simpl; auto. replace (fold_right mult 1 (repeat q f)) with (pow q f); auto. clear -f; induction f; simpl; auto. apply IHl; auto. inversion H7; auto. inversion H15; auto. apply in_map_iff in H3. destruct H3 as [x [Hx Hy]]. contradict Hx. apply carm_func_nz; auto. apply Forall_forall with (x:=fst x) in H; auto. right; apply in_map; auto. apply Forall_forall with (x:=snd x) in H1; auto. right; apply in_map; auto. Qed.
Theorem Carmichael_pow_mult_fold_unique: forall l x c, Carmichael (pow_mult_fold l) x -> Forall Prime (map fst l) -> NoDup (map fst l) -> Forall (fun n=>n<>0) (map snd l) -> LCMs c (map (fun p=>carm_func (fst p) (snd p)) l) -> x=c. Proof. intros l. apply (Fix (well_founded_ltof (list (nat*nat)) (length (A:=nat*nat)))) with (P:=fun l=>forall x c, Carmichael (pow_mult_fold l) x -> Forall Prime (map fst l) -> NoDup (map fst l) -> Forall (fun n=>n<>0) (map snd l) -> LCMs c (map (fun p=>carm_func (fst p) (snd p)) l) -> x=c). clear l. intros l IH x c H. remember (pow_mult_fold l) as n in H. revert Heqn. revert c. induction H; intros. symmetry in Heqn. contradict Heqn; auto. apply pow_mult_fold_nz'; auto. destruct l as [|[p e] l]. simpl in H2. apply LCMs_unique with nil; auto. apply MinP_intro; auto. intros. destruct H3. destruct m; auto. simpl in Heqn. symmetry in Heqn. apply mult_is_one in Heqn. destruct Heqn. destruct e. inversion H1. contradict H7; auto. simpl in H3. apply mult_is_one in H3. destruct H3. inversion H. subst p; contradict H8; auto.
  destruct l as [|[q f] l]. simpl in Heqn. replace 1 with (pow p 0) in Heqn; auto. apply pow_cancel_r in Heqn; auto. contradiction. destruct l as [|[q' f'] l]. simpl in Heqn. rewrite mult_1_r in Heqn. assert (p=q). apply repeat_spec with f. apply Prime_mult_In; auto. inversion H1. clear -H7; induction f; simpl; auto. replace (fold_right mult 1 (repeat q f)) with (pow q f). rewrite <- Heqn. destruct e. contradict H0; auto. simpl; rewrite mult_comm; auto. clear -f; induction f; simpl; auto. subst q. apply pow_cancel_r in Heqn; auto. subst f. simpl in H4. apply LCMs_unique with (carm_func p e ::nil); auto. apply LCMs_one. apply carm_func_nz; auto. inversion H2. assert (q<>q'). contradict H7; subst x q; auto. inversion H1. inversion H13. inversion H3. inversion H21. contradict H9. clear -H H0 Heqn H12 H16 H20 H24. simpl in Heqn. assert (q=p). apply repeat_spec with e. apply Prime_mult_In; auto. clear -H. induction e; simpl; auto. replace (fold_right mult 1 (repeat p e)) with (pow p e). rewrite Heqn. apply Divide_trans with (pow q f); auto. destruct f; simpl; auto. contradict H20; auto. rewrite mult_comm; auto. rewrite mult_comm; auto. clear -e; induction e; simpl; auto. subst q. symmetry. apply repeat_spec with e. apply Prime_mult_In; auto. clear -H12; induction e; simpl; auto.  replace (fold_right mult 1 (repeat p e)) with (pow p e). rewrite Heqn. rewrite mult_comm. rewrite <- mult_assoc. rewrite mult_comm. apply Divide_trans with (pow q' f'); auto. destruct f'. contradict H24; auto. simpl. rewrite mult_comm; auto. clear -e. induction e; simpl; auto.
  destruct (Coprime_mult_pow_Prime l H) as [l1 [l2 [H7 H8] H9]]; auto. subst n m. apply LCMs_Perm with (m:=map (fun p=>carm_func (fst p) (snd p)) (l1++l2)) in H6; auto. rewrite map_app in H6. eapply LCMs_unique; [|eapply H6]. assert (length l=length (l1++l2)). apply Perm_length; auto. rewrite app_length in H7. apply LCMs_app with a b; auto. destruct l2. rewrite app_nil_r in H6. rewrite app_nil_r in H9. replace a with c; auto. symmetry. apply IHCarmichael1; auto. apply LCMs_Perm with (map (fun p=>carm_func (fst p) (snd p)) l1); auto. destruct (lcms_sig (map (fun p=>carm_func (fst p) (snd p)) l1)) as [[c1 H8]|H8]. replace a with c1; auto. symmetry. apply IH with l1; auto. unfold ltof. rewrite H7. simpl. rewrite <- plus_n_Sm; auto. apply Forall_forall. intros x Hx. apply Forall_forall with (x:=x) in H3; auto. apply Perm_In with (map fst (l1++p::l2)); auto. rewrite map_app; apply in_or_app; auto. apply NoDup_app_rev with (map fst (p::l2)). apply NoDup_Perm with (map fst l); auto. rewrite <-map_app. apply Perm_map. apply Perm_trans with (l1++p::l2); auto. apply Forall_forall. intros. apply Forall_forall with (x:=x) in H5; auto. apply Perm_In with (map snd (l1++p::l2)); auto. rewrite map_app; apply in_or_app; auto. apply in_map_iff in H8. destruct H8 as [x [Hx Hy]]. contradict Hx. apply carm_func_nz. apply Forall_forall with (x:=fst x) in H3; auto. apply in_map_iff. exists x; split; auto. apply Perm_In with (l1++p::l2); auto. apply in_or_app; auto. apply Forall_forall with (x:=snd x) in H5; auto. apply in_map_iff. exists x; split; auto. apply Perm_In with (l1++p::l2); auto. apply in_or_app; auto.
  destruct l1. simpl in H7. simpl in H9. simpl in Heqn. rewrite <- plus_n_O in Heqn. simpl in H6. replace b with c; auto. symmetry. apply IHCarmichael2; auto. apply LCMs_Perm with (map (fun p=>carm_func (fst p) (snd p)) l2); auto. destruct (lcms_sig (map (fun p=>carm_func (fst p) (snd p)) l2)) as [[c2 Hc]|Hc]. replace b with c2; auto. symmetry. apply IH with l2; auto. unfold ltof. rewrite H7. simpl. apply le_n_S; auto. apply Forall_forall. intros. apply Forall_forall with (x:=x) in H3; auto. apply Perm_In with (map fst ((p::l1)++l2)); auto. rewrite map_app. apply in_or_app; auto. apply NoDup_app_rev with (map fst (p::l1)). rewrite <- map_app. apply NoDup_Perm with (map fst l); auto. apply Forall_forall. intros. apply Forall_forall with (x:=x) in H5; auto. apply Perm_In with (map snd ((p::l1)++l2)); auto. rewrite map_app. apply in_or_app; auto. apply in_map_iff in Hc. destruct Hc as [x [Hx Hy]]. contradict Hx. apply carm_func_nz; auto. apply Forall_forall with (x:=fst x) in H3; auto. apply in_map. apply Perm_In with ((p::l1)++l2); auto. apply in_or_app; auto. apply Forall_forall with (x:=snd x) in H5; auto. apply in_map. apply Perm_In with ((p::l1)++l2); auto. apply in_or_app; auto. Qed.

Definition carmichael_sig: forall n, {c|Carmichael n c & forall x, Carmichael n x->x=c}. intros. destruct (fundamental2 n) as [[l [H [H0 [H1 H2]]]]|H]. subst n. destruct (lcms_sig (map (fun p=>carm_func (fst p) (snd p)) l)) as [[c H3]|H3]. exists c. apply Carmichael_pow_mult_fold; auto. intros. apply Carmichael_pow_mult_fold_unique with l; auto. apply in_map_iff in H3. exfalso. destruct H3 as [x [H4 H5]]. contradict H4. apply carm_func_nz. apply Forall_forall with (x:=fst x) in H0; auto. apply in_map; auto. apply Forall_forall with (x:=snd x) in H2; auto. apply in_map; auto. subst n. exists 1; auto. intros. apply Carmichael_0; auto. Defined. 
Theorem Carmichael_unique: forall n c d, Carmichael n c -> Carmichael n d -> c=d. Proof. intros. destruct (carmichael_sig n) as [e He Hf]. rewrite Hf; auto. Qed.
Theorem Carmichael_Prime: forall p, Prime p -> Carmichael p (p-1). Proof. intros. replace (p-1) with (carm_func p 1). replace p with (pow p 1) at 1; auto. unfold carm_func. destruct (le_lt_dec p 2). simpl. replace p with 2; auto. apply le_antisym; auto. simpl. rewrite mult_1_r; auto. Qed.

Theorem Carmichael_Divide: forall n m cn cm, m<>0 -> Divide n m -> Carmichael n cn -> Carmichael m cm -> Divide cn cm. Proof. intros n. destruct (fundamental2 n) as [[l [H [H0 [H1 H2]]]]|H0]. subst n. revert H0 H1 H2. induction l as [|[p e] l]; simpl; intros. apply Carmichael_1 in H4. subst cn; auto. inversion H0. inversion H1. inversion H2. subst x x0 x1 l0 l1 l2. clear H0 H1 H2. destruct (fundamental2 m) as [[l' [H1 [H2 [H6 H7]]]]|H1]; [subst m|contradiction]. destruct (pow_mult_fold_In' l' H2 H6 H8 H16) as [e' H1 H10]; auto. apply Divide_trans with (pow p e*pow_mult_fold l); auto. rewrite mult_comm; auto. destruct (Add_inv (p,e') l' H10) as [m H11]. assert (Perm ((p,e')::m) l'). apply Perm_Add with (p,e') m m; auto. assert (pow_mult_fold l'=pow p e' * pow_mult_fold m). rewrite pow_mult_fold_Perm with (m:=(p,e')::m); auto. rewrite H14 in H3. rewrite H14 in H5. assert (Forall Prime (map fst ((p,e')::m))). apply Forall_forall. intros x Hx. apply Forall_forall with (x:=x) in H2; auto. apply Perm_In with (map fst ((p,e')::m)); auto. assert (NoDup (map fst ((p,e')::m))). apply NoDup_Perm with (map fst l'); auto. assert (Forall (fun x=>x<>0) (map snd ((p,e')::m))). apply Forall_forall. intros x Hx. apply Forall_forall with (x:=x) in H7; auto. apply Perm_In with (map snd ((p,e')::m)); auto. inversion H15. inversion H18. inversion H19. subst x x0 x1 l0 l1 l2. clear H14 H15 H18 H19 H22 H2 H6 H7 H10 H11 H0. destruct (carmichael_sig (pow_mult_fold l)) as [cn' H15 _]. destruct (carmichael_sig (pow_mult_fold m)) as [cm' H18 _]. apply LCM_Divides with (carm_func p e) cn' (carm_func p e') cm'.
  clear -H8 H16 H1. unfold carm_func. destruct (le_lt_dec p 2). destruct (le_lt_dec e 2). destruct (le_lt_dec e' 2). replace (e'-1) with ((e-1)+((e'-1)-(e-1))). rewrite pow_plus; rewrite mult_comm; auto. symmetry. apply le_plus_minus. destruct e. contradict H16; auto. destruct e'. inversion H1. simpl. repeat rewrite <- minus_n_O. apply le_S_n; auto. replace (e'-2) with ((e-1)+(e'-2-(e-1))). rewrite pow_plus; rewrite mult_comm; auto. symmetry. apply le_plus_minus. apply le_trans with 1. apply le_S_n. destruct e. contradict H16; auto. simpl. rewrite <- minus_n_O; auto. destruct e'. inversion l1. destruct e'. contradict l1; auto. simpl. rewrite <- minus_n_O. apply le_S_n. apply le_S_n; auto. destruct (le_lt_dec e' 2). contradict l0. apply le_not_lt. apply le_trans with e'; auto. replace (e'-2) with (e-2+(e'-2-(e-2))). rewrite pow_plus; rewrite mult_comm; auto. symmetry. apply le_plus_minus. apply le_S_n. apply le_S_n. repeat rewrite minus_Sn_m; auto. simpl. repeat rewrite <- minus_n_O; auto. replace (e'-1) with (e-1+(e'-1-(e-1))). rewrite pow_plus. rewrite mult_assoc. replace ((p - 1) * pow p (e - 1) * pow p (e' - 1 - (e - 1))) with (pow p (e' - 1 - (e - 1))*((p - 1) * pow p (e - 1))); auto. symmetry. apply le_plus_minus. apply le_S_n. repeat rewrite minus_Sn_m; auto. simpl. repeat rewrite <- minus_n_O; auto. apply le_trans with e; auto.
  apply IHl with (m:=pow_mult_fold m); auto. apply pow_mult_fold_nz; auto. apply Forall_forall. intros x Hx. apply Forall_forall with (x:=x) in H23; auto. replace e' with (e+(e'-e)) in H3. rewrite pow_plus in H3. rewrite <- mult_assoc in H3. apply Divide_div in H3. apply Euclid in H3; auto. destruct (Prime_pow_Coprime_Divide (pow_mult_fold l) (e'-e) H8); auto. contradict H12. destruct (pow_mult_fold_In l H9 H8); auto. apply in_map_iff. exists (p,x); auto. apply pow_nz; auto. symmetry. apply le_plus_minus; auto.
  destruct (lcm_sig (carm_func p e) cn') as [[cn'' H0]|H0]. replace cn with cn''; auto. eapply Carmichael_unique; [|eapply H4]. apply Carm_m with (carm_func p e) cn'; auto. destruct (Prime_pow_Coprime_Divide (pow_mult_fold l) e H8); auto. contradict H12. destruct (pow_mult_fold_In l) with (p:=p); auto. apply in_map_iff. exists (p,x); auto. destruct H0. contradict H0. apply Carmichael_nz with (pow p e); auto. contradict H0; eapply Carmichael_nz; eauto.
  destruct (lcm_sig (carm_func p e') cm') as [[cm'' H0]|H0]. replace cm with cm''; auto. eapply Carmichael_unique; [|eapply H5]. apply Carm_m with (carm_func p e') cm'; auto. destruct (Prime_pow_Coprime_Divide (pow_mult_fold m) e' H8); auto. contradict H26. destruct (pow_mult_fold_In m) with (p:=p); auto. apply in_map_iff. exists (p,x); auto. destruct H0. contradict H0. apply Carmichael_nz with (pow p e'); auto. contradict H0; eapply Carmichael_nz; eauto. subst n. intros. apply Carmichael_0 in H1. subst cn. auto. Qed.
(* Theorem Carmichael_LCM: forall n m l cn cm cl, Carmichael n cn -> Carmichael m cm -> LCM l n m -> LCM cl cn cm -> Carmichael l cl. *)

Theorem Carmichael_pow_Mod: forall n c a, Carmichael n c -> Coprime n a -> ModEq n (pow a c) 1. Proof. intros n. destruct (fundamental2 n) as [[l [H [H0 [H1 H2]]]]|H]. subst n. revert H2 H1 H0. induction l as [|[p e] l]; simpl; intros; auto. inversion H2. inversion H1. inversion H0. subst x x0 x1 l0 l1 l2. clear H0 H1 H2. assert (Coprime (pow p e) (pow_mult_fold l)). destruct (Prime_pow_Coprime_Divide (pow_mult_fold l) e H14); auto. contradict H10. destruct (pow_mult_fold_In l) with (p:=p); auto. apply in_map_iff.  exists (p,x); auto. destruct (carmichael_sig (pow_mult_fold l)) as [c' H1 _]. destruct (lcm_sig (carm_func p e) c') as [[c'' H2]|[H2|H2]]. replace c'' with c in H2. inversion H2. destruct H4. destruct H9. apply ModEq_Coprime_mult; auto. destruct (Divide_multN H9). subst n c. cut (ModEq (pow p e) (pow a (carm_func p e)) 1); intros. rewrite pow_mult. clear -H8; induction x; simpl; auto. replace 1 with (1*1); auto. apply Coprime_sym in H3; apply Coprime_mult_rev in H3; destruct H3. clear -H3 H14 H6. unfold carm_func. destruct (le_lt_dec p 2). assert (p=2). apply le_antisym; auto. subst p. clear l H14. destruct (le_lt_dec e 2). inversion l. subst e; simpl; simpl in H3. rewrite mult_1_r. destruct (divmod 4 a) as [[q [r [H1 H2] _]]|H1]. apply ModEq_trans with (r*r). assert (ModEq 4 a r). subst a. replace r with (q*0+r) at 2; auto. apply ModEq_plus; auto. apply ModEq_mult; auto. apply ModEq_sym; apply Divide_refl. apply ModEq_mult; auto. inversion H2. auto. inversion H0. subst r m a. absurd (2<=1); auto. inversion H3. apply H1; split; auto. apply Divide_plus; auto. apply Divide_trans with (2*2); auto. replace 4 with (2*2); auto. inversion H5; auto. inversion H8. subst r a. absurd (4<=1); auto. inversion H3. apply H9; split; auto. inversion H10. inversion H1.
  inversion H0. subst e m; simpl; simpl in H3. rewrite mult_1_r. destruct (divmod 2 a) as [[q [r [H1 H2] _]]|H1]. subst a. replace 1 with (q*0+1) at 3; auto; apply ModEq_plus; auto. apply ModEq_mult; auto. inversion H2; auto. inversion H1. subst m r. absurd (2<=1); auto. inversion H3. apply H4; auto. inversion H5. inversion H1. inversion H2; contradiction. clear H6. induction l. simpl. rewrite mult_1_r. assert (~Divide 2 a). intros C. absurd (2<=1); auto. inversion H3. apply H0; simpl; split; auto. replace 8 with (4*2); auto. assert (8<>0); auto. remember (modN H0 a) as b. assert (b<8). subst b; auto. apply ModEq_trans with (b*b). subst b; auto. assert (~Divide 2 b). contradict H. subst b. unfold modN in H. destruct (divmod 8 a) as [[q [r [H2 H4] _]]|H2]. subst a. apply Divide_plus; auto. replace 8 with (4*2); auto. rewrite mult_assoc; auto. contradiction. clear Heqb H3 H. replace 1 with (0+1) at 2; auto. inversion H1. replace 49 with (6*8+1); auto. inversion H3. subst b; contradict H2; replace 6 with (3*2); auto. inversion H5. replace (5*5) with (3*8+1); auto. inversion H7. contradict H2; subst b; replace 4 with (2*2); auto. inversion H9. subst b; replace (3*3) with (8+1); auto. inversion H11. subst b; contradict H2; auto. inversion H13. auto. inversion H15. contradict H2; subst b; auto. inversion H17. rewrite powS in H3.  apply Coprime_mult_rev in H3. destruct H3. apply IHl in H0. rewrite <- minus_Sn_m; auto. rewrite powS. rewrite powS. rewrite pow_mult. assert (a<>0). intros C; subst a. absurd (2<=1); inversion H; auto. destruct (ModEq_multN H0) as [[q H2]|[q H2]]. destruct q. simpl in H2. rewrite <- H2; auto. simpl in H2. absurd (2<=1); auto. rewrite H2 at 2. destruct m. simpl. apply le_n_S. repeat rewrite mult_1_r. destruct a. contradict H1; auto. rewrite <- plus_n_Sm. apply le_n_S; auto. rewrite powS. apply le_trans with (2*pow 2 m). remember (pow 2 m) as b. destruct b; auto. symmetry in Heqb; contradict Heqb; auto. rewrite mult_comm; simpl; auto. rewrite <- plus_assoc; auto.
  destruct (divmod 2 q) as [[s [r [H3 H4] _]]|H3]. inversion H4. subst q r. assert (ModEq (2*pow 2 m) (pow a (pow 2 (m-2))) (pow 2 m+1)). rewrite H2. rewrite mult_plus_distr_r. replace (pow 2 m+1) with (0+(pow 2 m+1)); auto. rewrite mult_1_l. rewrite <- plus_assoc. apply ModEq_plus; auto. rewrite <- mult_assoc; auto. apply ModEq_sym; apply multN_Divide. apply ModEq_trans with (pow (pow 2 m+1) 2). remember (pow a (pow 2 (m-2))) as b. remember (pow 2 m+1) as c. remember (2*pow 2 m) as d. repeat rewrite powS; simpl; repeat rewrite mult_1_r; auto. rewrite powS. rewrite powS. rewrite pow0. rewrite mult_1_r. rewrite mult_plus_distr_l. rewrite mult_1_r. rewrite mult_plus_distr_r. rewrite mult_1_l. rewrite plus_assoc. replace 1 with (0+1) at 8; auto. apply ModEq_plus; auto. apply ModEq_sym. rewrite <- plus_assoc. apply Divide_plus. replace m with (S(m-1)) at 2. rewrite powS. replace (2*pow 2 (m-1)*pow 2 m) with (pow 2 (m-1)*(2*pow 2 m)); auto. rewrite mult_comm. repeat rewrite <- mult_assoc; auto. destruct m; simpl; auto. inversion l. rewrite <- minus_n_O; auto. simpl. rewrite <- plus_n_O; auto. inversion H6. subst r. rewrite <- plus_n_O in H3. subst q. remember (pow a (pow 2 (m-2))) as b. assert (ModEq (2*pow 2 m) b 1). replace 1 with (0+1) at 3; auto. rewrite H2. apply ModEq_plus; auto. apply ModEq_sym. rewrite <- mult_assoc; apply multN_Divide; auto. rewrite powS. rewrite powS. rewrite pow0. rewrite mult_1_r. replace 1 with (1*1) at 3; auto. inversion H8. inversion H3.
  apply Euler; auto. destruct (Divide_multN H12). subst c n. rewrite pow_mult. cut (ModEq (pow_mult_fold l) (pow a c') 1); intros. clear -H8; induction x; simpl; auto. replace 1 with (1*1); auto. apply IHl; auto. apply Coprime_sym in H3; apply Coprime_mult_rev in H3; destruct H3; auto. eapply Carmichael_unique. eapply H. apply Carm_m with (carm_func p e) c'; auto. contradict H2. apply Carmichael_nz with (pow p e); auto. contradict H2. eapply Carmichael_nz; eauto.
  subst n; intros. replace a with 1. replace (pow 1 c) with 1; auto. apply GCD_unique with 0 a; auto. apply GCD_0n. contradict H0; subst a; apply GCD_00; auto. Qed.

Theorem Carmichael_ModOrder': forall p e, Prime p -> e<>0 -> exists a, ModOrder (pow p e) a (carm_func p e). Proof. intros. unfold carm_func. destruct (le_lt_dec p 2) as [Hp|Hp]. assert (p=2). apply le_antisym; auto. subst p. destruct (le_lt_dec e 2). inversion l. simpl. exists 3. apply ModOrder_intro. clear H0 H1 Hp. apply MaxP_intro; auto. intros. destruct H0. apply Prime_Divide in H1. destruct H1; subst m; auto. replace 4 with (3+1) in H0; auto. apply Divide_minus in H0; auto. apply Prime_build; auto. intros. assert (x<=3); auto. inversion H3; auto. inversion H5. subst x. replace 3 with (2+1) in H2; auto. apply Divide_minus in H2; auto. inversion H7; auto. inversion H9. subst x. apply ModEq0_eq in H2. inversion H2. apply MinP_intro. split; simpl; auto. replace 9 with (2*4+1); auto. intros. destruct H2. destruct m. contradict H2; auto. destruct m. simpl in H3. apply ModEq_le_eq in H3; auto. inversion H3. auto. inversion H2. simpl. exists 1. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H4. destruct m0; auto. inversion H4. contradiction.
  exists 3. clear H0 Hp. assert (Coprime (pow 2 e) 3). destruct (Prime_pow_Coprime_Divide 3 e H); auto. replace 3 with (2+1) in H0; auto. apply Divide_minus in H0; auto. apply Divide_le in H0; auto. contradict H0; auto. destruct (modOrder H0) as [o H1]. assert (ModEq (pow 2 e) (pow 3 (pow 2 (e-2))) 1).
  clear H0 H1. induction l. simpl. replace 9 with (8+1); auto. rewrite <- minus_Sn_m; auto. repeat rewrite powS. apply ModEq_multN in IHl. destruct IHl as [[q H0]|[q H0]]. destruct q. simpl in H0. replace 1 with (pow 3 0) in H0 at 1; auto. apply pow_cancel_r in H0; auto. symmetry in H0. contradict H0; auto. simpl in H0. absurd (2<=1); auto. rewrite H0 at 2. remember (pow 2 m) as a. symmetry in Heqa. destruct a. contradict Heqa; auto. simpl. apply le_n_S. remember (pow 3 (pow 2 (m-2))) as b. symmetry in Heqb. destruct b. contradict Heqb; auto. rewrite plus_comm. simpl; auto. rewrite pow_mult. rewrite H0. clear H0. destruct (divmod 2 q) as [[s [r [H0 H1] _]]|H0]; [|contradict H0]; auto. inversion H1. subst r. subst q. rewrite mult_plus_distr_r. rewrite mult_1_l. apply ModEq_trans with (pow (pow 2 m+1) 2). apply ModEq_pow. rewrite <- plus_assoc. rewrite <- mult_assoc; auto. repeat rewrite powS. rewrite pow0. rewrite mult_1_r. rewrite mult_plus_distr_l. rewrite mult_1_r. rewrite mult_plus_distr_r. rewrite mult_1_l. replace (pow 2 m*pow 2 m+pow 2 m+(pow 2 m+1)) with ((pow 2 (m-1)+1)*(2*pow 2 m)+1); auto. rewrite plus_assoc. f_equal. rewrite <- plus_assoc. replace (pow 2 m+pow 2 m) with (2*pow 2 m). rewrite <- mult_plus_distr_r. rewrite mult_assoc. f_equal. rewrite mult_plus_distr_r. f_equal; auto. rewrite mult_comm. rewrite <- powS. f_equal. rewrite minus_Sn_m; auto. simpl. rewrite <- minus_n_O; auto. simpl. rewrite <- plus_n_O; auto. inversion H3. subst r. rewrite <- plus_n_O in H0. subst q. apply ModEq_trans with (pow 1 2); auto. apply ModEq_pow. rewrite <- mult_assoc; auto. inversion H5.
  assert (Divide o (pow 2 (e-2))). apply ModOrder_Divide with (d:=pow 2 (e-2)) in H1. apply H1; auto. apply pow_Prime_Divide in H3; auto. destruct H3 as [x [H4 H5]]. subst o. apply le_lt_or_eq in H5. destruct H5; [|subst x]; auto. assert (~ModEq (pow 2 e) (pow 3 (pow 2 (e-3))) 1). apply le_lt_or_eq in l. destruct l as [Hl|Hl]. cut (ModEq (pow 2 e) (pow 3 (pow 2 (e-3))) (pow 2 (e-1)+1)). intros H4 H5. absurd (pow 2 (e-1)+1=1). intros C. rewrite plus_comm in C. simpl in C; inversion C. contradict H7; auto. apply ModEq_le_eq with (pow 2 e). eapply ModEq_trans; [|eapply H5]; auto. destruct e. inversion Hl. rewrite powS. simpl. rewrite <- minus_n_O.  apply plus_lt_compat_l. rewrite <- plus_n_O. apply pow_le; auto. contradict Hl; subst e; auto. apply pow_le. contradict Hl; subst e; auto. clear -H Hl. induction Hl. simpl; auto. rewrite <- minus_Sn_m; auto. rewrite <- minus_Sn_m; [|apply le_trans with 3]; auto. repeat rewrite powS. rewrite pow_mult. remember (pow 3 (pow 2 (m-3))) as a. assert (3<=a). subst a. apply pow_le; auto. rewrite powS. rewrite pow1. destruct (ModEq_multN_lt IHHl) as [q H1]. replace m with (S(m-1)) at 2. rewrite powS. simpl. rewrite <- plus_n_O. apply plus_lt_compat_l. apply pow_le; auto. destruct m. inversion Hl. destruct m. contradict Hl; auto. simpl; discriminate. destruct m. inversion Hl. simpl. rewrite <- minus_n_O; auto. replace (a*a) with ((q*q*pow 2 (m-1)+q*pow 2 (m-1)+q+pow 2 (m-3))*(2*pow 2 m)+(2*pow 2 (m-1)+1)); auto. rewrite H1. repeat rewrite mult_plus_distr_r. repeat rewrite mult_plus_distr_l. repeat rewrite <- plus_assoc. f_equal. repeat rewrite mult_assoc. f_equal. repeat rewrite <- mult_assoc. f_equal. rewrite mult_comm. f_equal. rewrite mult_comm. rewrite <- powS. f_equal. destruct m. inversion Hl. simpl; rewrite <- minus_n_O; auto. repeat rewrite mult_1_r. repeat rewrite mult_1_l. repeat rewrite plus_assoc. f_equal.
  assert (forall x, 2*x=x+x). intros; simpl; auto. replace (2*pow 2 (m-1)) with (pow 2 (m-1)+pow 2 (m-1)); auto. rewrite plus_assoc. f_equal. rewrite H2 at 1. rewrite mult_plus_distr_l. repeat rewrite <- plus_assoc. f_equal. repeat rewrite <- mult_assoc; f_equal ; auto. symmetry. rewrite plus_comm. repeat rewrite <- plus_assoc. f_equal. rewrite mult_assoc; f_equal; auto. rewrite plus_comm. symmetry. rewrite plus_assoc. rewrite plus_comm. repeat rewrite <- plus_assoc. f_equal. repeat rewrite plus_assoc. rewrite <- H2. f_equal. repeat rewrite mult_assoc; f_equal; auto. rewrite <- powS. repeat rewrite <- pow_plus. f_equal. destruct m. inversion Hl. simpl. repeat rewrite <- minus_n_O. destruct m. contradict Hl; auto. destruct m. contradict Hl; auto. simpl. rewrite <- minus_n_O. repeat rewrite <- plus_n_Sm; auto.  subst e. simpl. intros C. apply ModEq_le_eq in C; auto. inversion C. repeat apply le_n_S; auto. contradict H4. apply ModOrder_Divide with (d:=pow 2 (e-3)) in H1. apply H1. apply pow_Prime_Divide; auto. exists x; split; auto. replace (e-2) with (S(e-3)) in H3; auto. rewrite minus_Sn_m; simpl; auto.
  destruct (Prime_pow_ModRoot e H Hp) as [a H2]. exists a. inversion H2. subst n g. replace ((p-1)*pow p (e-1)) with t; auto. apply Totient_unique with (pow p e); auto. Qed.
Theorem Carmichael_ModOrder: forall n c, Carmichael n c-> exists a, ModOrder n a c. Proof. intros n. destruct (fundamental2 n) as [[l [H [H0 [H1 H2]]]]|H]; subst n. revert H2 H1 H0. induction l as [|[p e] l]; simpl; intros. apply Carmichael_1 in H. subst c. exists 1. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H. destruct m; auto. inversion H2. inversion H1. inversion H0. subst x x0 x1 l1 l2 l0. clear H0 H1 H2. assert (Hc:Coprime (pow p e) (pow_mult_fold l)). destruct (Prime_pow_Coprime_Divide (pow_mult_fold l) e H13); auto. destruct (pow_mult_fold_In l) with (p:=p); auto. contradict H9; apply in_map_iff; exists (p,x); auto. destruct (carmichael_sig (pow_mult_fold l)) as [c' H0 _]. destruct (lcm_sig (carm_func p e) c') as [[c'' H1]|[H1|H1]]. replace c'' with c in H1. destruct IHl with (c:=c') as [a2 H2]; auto. destruct (Carmichael_ModOrder' H13 H5) as [a1 H3]. destruct (Chinese Hc a1 a2) as [a [H4 H7] H8]. exists a. apply ModOrder_intro. apply Coprime_sym; apply Coprime_mult. apply GCD_sym; apply GCD_ModEq  with a1; auto. inversion H3; auto. apply GCD_sym; apply GCD_ModEq with a2; auto. inversion H2; auto. apply MinP_intro. split. eapply LCM_nz; eauto. apply ModEq_Coprime_mult; auto. apply ModEq_trans with (pow a1 c). apply ModEq_pow; auto. apply ModOrder_Divide with (carm_func p e); auto. inversion H1; destruct H11; destruct H16; auto. apply ModEq_trans with (pow a2 c). apply ModEq_pow; auto. apply ModOrder_Divide with c'; auto. inversion H1; destruct H11; destruct H16; auto. intros. destruct H11. assert (ModEq (pow_mult_fold l) (pow a m) 1). apply ModEq_mult_rev in H12; auto. rewrite mult_comm in H12. apply ModEq_mult_rev in H12; auto. inversion H1. apply H17. split; auto. split. apply ModOrder_Divide with (d:=m) in H3. apply H3. apply ModEq_trans with (pow a m); auto. apply ModOrder_Divide with (d:=m) in H2. apply H2. apply ModEq_trans with (pow a m); auto.
  eapply Carmichael_unique. eapply H. apply Carm_m with (carm_func p e) c'; auto. contradict H1; apply Carmichael_nz with (pow p e); auto. contradict H1; apply Carmichael_nz with (pow_mult_fold l); auto. intros. apply Carmichael_0 in H. subst c. exists 1. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H. destruct m; auto.  Qed.
Theorem Carmichael_optimum: forall n c x, Carmichael n c -> x<>0 -> (forall a, Coprime n a-> ModEq n (pow a x) 1) -> c<=x. Proof. intros. destruct (Carmichael_ModOrder H) as [a H2]. inversion H2. inversion H4. apply H8; auto. Qed.

(* RSA *)
Record RSAKey : Set := mkRSAKey {
  prime1:nat; prime2:nat; modkey:nat; seckey:nat; pubkey:nat;
  isPrime1: Prime prime1;
  isPrime2: Prime prime2;
  prime_neq: prime1 <> prime2;
  modkey_mult: modkey = prime1 * prime2;
  modkey_nz: modkey <> 0;
  pubkey_coprime: Coprime (totient modkey) pubkey;
  pubkey_le: pubkey <= totient modkey;
  keyinv: ModEq (totient modkey) (seckey*pubkey) 1;
}.

Definition generateRSAKey (p q e:nat) : Prime p -> Prime q -> p<>q -> e<=(p-1)*(q-1) -> Coprime ((p-1)*(q-1)) e -> RSAKey. intros. assert (totient (p*q) = (p-1)*(q-1)). unfold totient. destruct (totient_sig (p*q)). apply Totient_unique with (p*q); auto. apply Totient_mult; auto. destruct (Prime_Coprime_Divide q H); auto. apply Prime_Divide in H4; auto. destruct H4. contradict H; subst p; auto. contradiction. destruct (invMod ((p-1)*(q-1)) e) as [[d H5]|H5]. rewrite <- H4 in H3. rewrite <- H4 in H2. rewrite <-H4 in H5. refine (mkRSAKey d  H H0 H1 _ _ H3 H2 _); auto. intros C. apply mult_is_O in C. destruct C. subst p; contradict H; auto. subst q; contradict H0; auto. replace (d*e) with (e*d); auto. contradiction. Defined.

Definition RSAencrypt (k:RSAKey) (m:nat) : nat := modN (modkey_nz k) (pow m (pubkey k)).
Definition RSAdecrypt (k:RSAKey) (m:nat) : nat := modN (modkey_nz k) (pow m (seckey k)).
Theorem RSA_spec: forall k m, Coprime (modkey k) m -> RSAdecrypt k (RSAencrypt k m) = modN (modkey_nz k) m. Proof. intros k m Hc. unfold RSAdecrypt. unfold RSAencrypt. apply ModEq__modN_eq. apply ModEq_trans with (pow (pow m (pubkey k)) (seckey k)). apply ModEq_pow; auto. rewrite <- pow_mult. destruct k; simpl. simpl in Hc. destruct (ModEq_multN keyinv0) as [[q H]|[q H]]. destruct q. simpl in H. rewrite <- H. simpl. rewrite mult_1_r; auto. simpl in H.  absurd (totient modkey0<=1). apply lt_not_le. subst modkey0. replace (totient (prime3*prime4)) with ((prime3-1)*(prime4-1)). assert (2<=prime3); auto. apply le_lt_or_eq in H0. destruct H0. apply le_trans with (prime3-1); auto. destruct prime3. contradict isPrime3; auto. simpl. rewrite <- minus_n_O. auto. destruct prime4. contradict isPrime4; auto. destruct prime4. contradict isPrime4; auto. simpl. rewrite <- mult_n_Sm; auto. subst prime3. simpl. rewrite <- plus_n_O. assert (2<=prime4); auto. apply le_lt_or_eq in H0. destruct H0. destruct prime4. inversion H0. simpl. rewrite <- minus_n_O; auto. contradiction. apply Totient_unique with (prime3*prime4); auto. apply Totient_mult; auto. destruct (Prime_Coprime_Divide prime4 isPrime3); auto. destruct (Prime_Divide isPrime4 H0). contradict isPrime3; subst prime3; auto. contradiction. unfold totient. destruct (totient_sig (prime3*prime4)); auto.
  rewrite H. rewrite <- plus_assoc; auto. rewrite H. rewrite plus_comm. simpl. replace m with (m*1) at 3; auto. apply ModEq_mult; auto. rewrite pow_mult. replace 1 with (pow 1 q); auto. apply ModEq_pow. apply Euler; auto. unfold totient. destruct (totient_sig modkey0); auto. rewrite mult_1_r; auto. Qed.

