Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import ModEq.

Set Implicit Arguments.

Theorem Willson1: forall p, Prime p -> ModEq p (fact (p-1)) (p-1). Proof. intros. destruct (le_lt_dec p 2) as [H0|H0]. replace p with 2; simpl; auto. apply le_antisym; auto. assert (Hp:p<>0). contradict H; subst p; auto. rewrite fact_fold. remember (p-1) as t. assert (Ht: p=S t). destruct p. contradict Hp; auto. simpl in Heqt. rewrite <- minus_n_O in Heqt; subst t; auto. assert (Ht1:t<p). rewrite Ht; auto. assert (Ht2:Coprime p t). destruct (Prime_Coprime_Divide t H); auto. apply Divide_le in H1. contradict Ht1; auto. contradict H. rewrite Ht. rewrite H. auto. remember (t-2) as u. assert (Hu:t=S(S u)). subst u. destruct t. subst p; contradict H0; auto. simpl. destruct t. contradict H0; subst p; auto. simpl. rewrite <- minus_n_O; auto. rewrite Hu at 1. rewrite seqS. simpl. rewrite <- plus_n_O. rewrite fold_mult_app. simpl. rewrite mult_1_r. rewrite <- Hu. replace t with (1*t) at 2; auto. apply ModEq_mult; auto.
  cut (exists l, Perm (seq 2 u) (map fst l++map snd l) /\ forall q, In q l-> ModEq p (fst q*snd q) 1). intros. destruct H1 as [l [H3 H4]]. rewrite fold_right_Perm with (m:=map fst l++map snd l); auto. clear -H4. revert H4. induction l as [|[a b] l]; intros; simpl; auto. rewrite fold_mult_app. simpl. replace (a*(fold_right mult 1 (map fst l)*(b*fold_right mult 1 (map snd l)))) with (a*b*(fold_right mult 1 (map fst l)*fold_right mult 1 (map snd l))). replace 1 with (1*1) at 3; auto. apply ModEq_mult; auto. apply H4 with (q:=(a,b)); auto. rewrite <- fold_mult_app. apply IHl. intros; auto. rewrite <- mult_assoc. f_equal. rewrite mult_comm. rewrite <- mult_assoc. f_equal; auto.
  cut (forall m, (forall x, In x m->exists y, In y m/\ModEq p (x*y) 1/\x<>y/\forall z, In z m->ModEq p (x*z) 1->z=y) -> NoDup m -> exists l, Perm m (map fst l++map snd l) /\ (forall q, In q l->ModEq p (fst q*snd q) 1)). intros. apply H1; auto. intros. apply in_seq in H2. destruct H2. simpl in H3. rewrite <- Hu in H3. clear H1. assert (Hc:Coprime p x). destruct (Prime_Coprime_Divide x H); auto. apply Divide_le in H1. contradict H3. rewrite Ht in H1; auto. contradict H2; subst x; auto. destruct (invMod p x) as [[y H4]|H4]; [|contradiction]. remember(modN Hp y) as z. assert (z<p). subst z; auto. assert (ModEq p (x*z) 1). subst z. apply ModEq_trans with (x*y); auto. clear Heqz H4. exists z. split. apply in_seq. simpl. rewrite <- Hu. split. destruct z. rewrite mult_0_r in H5. apply Divide_le in H5; auto. contradict H0; auto. destruct z; auto. rewrite mult_1_r in H5. contradict H2. replace x with 1; auto. replace 1 with (modN Hp 1). replace x with (modN Hp x); auto. apply modN_le_eq. rewrite Ht; auto. apply modN_le_eq; auto.
  rewrite Ht in H1. apply le_S_n in H1. apply le_lt_or_eq in H1. destruct H1; auto. subst z. replace t with x at 1; auto. rewrite <- modN_le_eq with p Hp x; [|apply lt_trans with t; auto]. rewrite <- modN_le_eq with p Hp t; auto. apply ModEq__modN_eq. apply ModEq_div with t; auto. rewrite mult_comm. apply ModEq_trans with 1; auto. rewrite Ht. apply ModEq_minus with t. apply ModEq_trans with 0. replace (t+1) with (1*S t); auto. apply ModEq_sym; apply multN_Divide. rewrite mult_1_l. rewrite plus_comm. auto. rewrite plus_comm. rewrite mult_n_Sm. apply multN_Divide. split; auto. split.
  intros C. subst z. replace 1 with (1+0) in H5; auto. replace (x*x) with (1+(x+1)*(x-1)) in H5. apply ModEq_minus in H5; auto. apply ModEq_sym in H5. apply Euclid_Prime in H5; auto. destruct H5. destruct (Divide_multN H4) as [q]. destruct q. rewrite <- plus_n_Sm in e. inversion e. contradict H3. rewrite plus_comm in e. simpl in e. unfold lt. rewrite e. apply lt_not_le. rewrite Ht. simpl. auto. destruct (Divide_multN H4) as [q]. destruct q. simpl in e. destruct x. inversion H2. simpl in e. rewrite <- minus_n_O in e. subst x. contradict H2; auto. contradict H3. destruct x. inversion H2. simpl in e. rewrite <- minus_n_O in e. subst x. apply le_not_lt. apply le_trans with p; auto. destruct x. inversion H2. simpl. rewrite <- minus_n_O. f_equal. f_equal. rewrite mult_comm. f_equal. rewrite plus_comm; auto.
  intros w. intros. rewrite <- modN_le_eq with p Hp z; auto. rewrite <- modN_le_eq with p Hp w. apply ModEq__modN_eq. apply ModEq_div with x; auto. apply ModEq_trans with 1; auto. apply in_seq in H4. destruct H4. apply lt_trans with t; auto. rewrite Hu. simpl in H7; auto.
  intros m. clear -m. apply (Fix (well_founded_ltof (list nat) (length (A:=nat)))) with (P:=fun m=>(forall x,In x m->exists y,In y m/\ModEq p (x * y) 1/\x <> y/\(forall z,In z m->ModEq p (x * z) 1->z = y))->NoDup m->exists l, Perm m (map fst l ++ map snd l) /\ (forall q,In q l->ModEq p (fst q*snd q) 1)). clear m. intros m IH. intros. destruct m as [|a m]. exists nil; split; auto. intros. inversion H1. destruct (H a) as [b [H4 [H5 [H6 H7]]]]; auto. destruct H4. contradiction. destruct Add_inv with (a:=b) (l:=m) as [m' H8]; auto. assert (Hi:forall x, In x m<-> In x (b::m')). apply Add_in; auto. destruct (IH m') as [l H9]; auto. unfold ltof. simpl. rewrite Add_length with nat b m' m; auto. intros. destruct (H x) as [y [Ha [Hb [Hc Hd]]]]. right; auto. apply Hi; auto.
  exists y. destruct Ha. subst y. absurd (In b m'). destruct (NoDup_Add H8). destruct H3; auto. inversion H0; auto. replace b with x; auto. apply H7. right. apply Hi; auto. rewrite mult_comm; auto. apply Hi in H3. destruct H3. subst y. absurd (In a m'). inversion H0. contradict H9. apply Hi. right; auto. replace a with x; auto. destruct (H b) as [y [He [Hf [Hg Hh]]]]. right; auto. rewrite Hh; auto. apply Hh; auto. right. apply Hi; auto. rewrite mult_comm; auto. rewrite mult_comm; auto. split; auto. split; auto. split; auto. intros. apply Hd; auto. right. apply Hi; auto. inversion H0. destruct (NoDup_Add H8). destruct H10; auto. destruct H9. 
  exists ((a,b)::l). split. simpl. apply Perm_Add with a m (map fst l++b::map snd l); auto. apply Perm_Add with b m' (map fst l++map snd l); auto. intros. destruct H4; auto. subst q; simpl; auto. Qed.
Theorem Willson2: forall n, 2<=n -> ModEq n (fact (n-1)) (n-1) -> Prime n. Proof. intros. destruct (primeDivide n) as [[p H1 H2]|H1]; [|contradict H; auto]. assert (p<=n). apply Divide_le; auto. contradict H; subst n; auto. destruct (le_lt_or_eq p n H3). absurd (Divide p (fact (n-1)+1)). intros C. apply Divide_minus in C. apply Divide_le in C; auto. contradict C; auto. apply fact_Divide. apply le_S_n. destruct n; simpl; auto. rewrite <- minus_n_O; auto. contradict H1; subst p; auto. apply Divide_trans with n; auto. apply ModEq_trans with n; auto. replace n with (1*n+0) at 2; auto. simpl. repeat rewrite <- plus_n_O. auto. replace n with (n-1+1) at 2; auto. destruct n; simpl; auto. rewrite <- minus_n_O. rewrite plus_comm; auto. subst p; auto. Qed.

Inductive Combi: nat -> relation (nat):= Combi_intro: forall n k a, k<=n -> fact n=fact k*fact (n-k)*a -> Combi n k a.
Hint Constructors Combi.
Theorem Combi_add: forall n k b c, Combi n (S k) b -> Combi n k c -> Combi (S n) (S k) (b+c). Proof. intros. inversion H. inversion H0.  clear -H1 H2 H7. apply Combi_intro; auto. replace (S n-S k) with (n-k); auto. rewrite mult_plus_distr_l. assert (forall k, fact (S k)=(S k)*fact k). simpl; auto. assert (fact (n-k)=(n-k)*fact (n-S k)). replace (n-k) with (S(n-S k)). simpl; auto. rewrite minus_Sn_m; auto. symmetry. rewrite H at 2. rewrite H0 at 1. replace (fact (S k)*((n-k)*fact (n-S k))*b) with ((n-k)*(fact (S k)*fact(n-S k)*b)). rewrite <- H2. rewrite <-  mult_assoc. rewrite <- mult_assoc. rewrite <- mult_assoc in H7. rewrite <- H7. rewrite <- mult_plus_distr_r. rewrite H. f_equal. rewrite <- plus_n_Sm. f_equal. rewrite plus_comm. rewrite <- le_plus_minus; auto. rewrite mult_comm. rewrite <- mult_assoc. rewrite <- mult_assoc. rewrite <- mult_assoc. f_equal. rewrite mult_comm. rewrite <- mult_assoc. apply mult_comm. Qed.
Theorem Combi_0: forall n, Combi n 0 1. Proof. intros. apply Combi_intro; auto. simpl. rewrite <- minus_n_O. rewrite mult_1_r. rewrite plus_comm; auto. Qed.
Theorem Combi_n: forall n, Combi n n 1. Proof. intros. apply Combi_intro; auto. rewrite mult_1_r. rewrite <- minus_n_n. simpl. rewrite mult_1_r; auto. Qed.
Theorem Combi_unique: forall n k a b, Combi n k a -> Combi n k b -> a=b. Proof. intros. inversion H. inversion H0. apply Nat.mul_cancel_l with (fact (n-k)). apply fact_nz. apply Nat.mul_cancel_l with (fact k). apply fact_nz. repeat rewrite mult_assoc. rewrite <- H2. auto. Qed.
Definition combi_sig: forall n k, {a|Combi n k a}+{n<k}. induction n; intros. destruct (nat_eq_dec k 0); [left|right]. subst k.  exists 1. apply Combi_0. destruct k; auto. destruct k. left; exists 1. apply Combi_0. destruct (le_lt_dec k n); [left|right]; auto. apply le_lt_or_eq in l. destruct (nat_eq_dec k n). exists 1. subst k; apply Combi_n. destruct (IHn (S k)) as [[a H]|H]. destruct (IHn k) as [[b H1]|H1]. exists (a+b). apply Combi_add; auto. contradict H1. destruct l; auto. contradict H. destruct l; auto. Defined.
Definition combi n k (H:k<=n): nat. refine (match combi_sig n k with inleft (exist _ a _) => a |inright _ => _ end). contradict l; auto. Defined.

Inductive ModOrder (n:nat): relation nat := ModOrder_intro: forall a k, Coprime n a -> MinP (fun x=>x<>0 /\ ModEq n (pow a x) 1) k -> ModOrder n a k.
Hint Constructors ModOrder.

Definition modOrder: forall n a, Coprime n a -> {k|ModOrder n a k}. intros. destruct (nat_eq_dec n 0) as [Hn|Hn]. subst n. assert (a=1). apply GCD_unique with 0 a; auto. destruct (nat_eq_dec a 0); auto. subst a; contradict H; unfold Coprime; auto. subst a. exists 1. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H0. destruct m; auto.
  destruct (minP) with (P:=fun x=>x<>0/\ModEq n (pow a x) 1) (n:=S(totient n)).  intros. destruct (ModEq_dec n (pow a x) 1); [|right]. destruct (nat_eq_dec x 0); [right|left]; auto. contradict e; destruct e; auto. contradict n0; destruct n0; auto. destruct s as [m H1]. exists m. apply ModOrder_intro; auto. unfold totient in n0. destruct (totient_sig n) as [t Ht]. absurd (t<>0/\ModEq n (pow a t) 1); auto. split. apply Totient_nz with n; auto. apply Euler; auto. Defined.
Theorem ModOrder_unique: forall n a k j, ModOrder n a k -> ModOrder n a j -> k=j. Proof. intros. inversion H. inversion H0. inversion H2. inversion H6. apply le_antisym; auto. Qed.
Theorem ModOrder_Divide: forall n a k d, ModOrder n a k -> Divide k d <-> ModEq n (pow a d) 1. Proof. intros. split; intros. destruct (Divide_multN H0). subst d. rewrite pow_mult. clear H0. inversion H. inversion H1. destruct H4. clear -H7. induction x; simpl; auto. replace 1 with (1*1); auto. inversion H. subst a0 k0. inversion H2. subst n0. destruct H3. destruct (divmod k d) as [[q [r [H6 H7] _]]|];[|contradiction]. subst d. destruct (nat_eq_dec r 0). subst r. rewrite <- plus_n_O. auto. rewrite pow_plus in H0. rewrite pow_mult in H0.
  absurd (k<=r); auto. apply H4. split; auto. clear -H0 H1 H5. induction q. simpl in H0. rewrite <- plus_n_O in H0; auto. apply IHq. simpl in H0. apply ModEq_div with (pow a k). clear -H1. induction k; simpl; auto. rewrite mult_assoc. rewrite mult_1_r. apply ModEq_trans with 1; auto. Qed.
Theorem ModOrder_Totient: forall n a k t, ModOrder n a k -> Totient n t -> Divide k t. Proof. intros. destruct ModOrder_Divide with n a k t; auto. apply H2. apply Euler; auto. inversion H; auto. Qed.
Theorem ModOrder_pow: forall n a k, ModOrder n a k -> forall x y, ModEq n (pow a x) (pow a y) <-> ModEq k x y. Proof. intros n a k H. cut (forall x y, x<=y->ModEq n (pow a x) (pow a y) <-> ModEq k x y). intros. destruct (le_lt_dec x y); auto. split; intros. apply ModEq_sym. apply H0; auto. apply ModEq_sym. apply H0; auto. intros. replace y with (x+(y-x)); [|rewrite <- le_plus_minus]; auto. split; intros. cut (ModEq n (pow a (y-x)) 1). intros. destruct ModOrder_Divide with n a k (y-x); auto. replace x with (x+0) at 1; auto. apply ModEq_plus; auto. apply H4; auto.
  inversion H. revert H1. clear -H2. generalize (y-x). induction x; simpl; intros; auto. apply IHx. apply ModEq_div with a; auto. rewrite pow_plus. replace (pow a x) with (pow a x*1) at 1; [|apply mult_1_r]. apply ModEq_mult; auto. destruct (ModOrder_Divide) with n a k (y-x); auto. apply ModEq_sym. apply H2. apply ModEq_minus with x. rewrite <- plus_n_O; auto. Qed.
Theorem ModOrder_NoDup: forall n a k (Hn:n<>0), ModOrder n a k -> NoDup (map (fun x=>modN Hn (pow a x)) (seq 0 k)). Proof. intros. apply NoDup_map; auto. intros. apply modN_eq__ModEq in H2. destruct ModOrder_pow with n a k x y; auto. apply H3 in H2. destruct (ModEq_multN H2) as [[q H5]|[q H5]]. subst y. destruct q; auto. apply in_seq in H1. destruct H1. contradict H5; auto. simpl. rewrite <- plus_assoc. auto. subst x. destruct q; auto. apply in_seq in H0. destruct H0. contradict H5. simpl. rewrite <- plus_assoc; auto. Qed.
Hint Resolve ModOrder_unique ModOrder_Divide ModOrder_Totient ModOrder_pow.

Inductive ModRoot: relation nat:= ModRoot_intro: forall n g t, Totient n t -> ModOrder n g t -> ModRoot n g.
Hint Constructors ModRoot.

Theorem Prime_ModRoot_root: forall p g, Prime p -> ModRoot p g -> forall n, {k|ModEq p (pow g k) n & forall k', ModEq p (pow g k') n -> ModEq (p-1) k k'}+{Divide p n}. intros. destruct (Divide_dec p n) as [Hd|Hd]; [right; auto|left]. destruct minP with (P:=fun k=>ModEq p (pow g k) n) (n:=p-1) as [[m H1]|H1]. intros. apply (ModEq_dec p (pow g x) n). exists m; inversion H1; auto. inversion H0. inversion H6. inversion H10. subst n0 n1 g0 a k n2. destruct H13. intros. replace (p-1) with t. cut (forall a b, ModEq p (pow g (a+b)) n -> ModEq p (pow g b) n -> ModEq t (a+b) b). intros. destruct (le_lt_dec m k'). rewrite le_plus_minus with m k'; auto. apply ModEq_sym. rewrite plus_comm. apply H11; auto. rewrite plus_comm. rewrite <- le_plus_minus; auto. rewrite le_plus_minus with k' m; auto. rewrite plus_comm. apply H11; auto. rewrite plus_comm. rewrite <- le_plus_minus; auto.
  intros. rewrite pow_plus in H11. cut (ModEq p (pow g a) 1). intros. destruct (divmod t a) as [[q [r [H15 H16] _]]|H15]; [|contradiction]. subst a. rewrite pow_plus in H13. cut (ModEq p (pow g r) 1). intros. destruct (nat_eq_dec r 0). subst r. rewrite plus_0_r; auto. absurd (t<=r); auto. apply ModEq_div with (pow g (q*t)); auto. apply ModEq_trans with 1; auto. rewrite mult_1_r. rewrite pow_mult. generalize q. intros x; induction x; simpl; auto. replace 1 with (1*1); auto. apply ModEq_div with (pow g b); auto. rewrite mult_comm. rewrite mult_1_r. apply ModEq_trans with n; auto. apply Totient_unique with p; auto.
  exfalso. assert (Hp:p<>0). intros. contradict H; subst p; auto. inversion H0. inversion H3. inversion H7. subst n0 g0 a k n1. destruct H10. clear H0 H3 H7.  cut (Perm (seq 1 (p-1)) (map (fun x=>modN Hp (pow g x)) (seq 0 (p-1)))). intros. assert (In (modN Hp n) (seq 1 (p-1))). apply in_seq. split; simpl; auto. destruct (nat_eq_dec (modN Hp n) 0). replace 0 with (modN Hp 0) in e. apply (modN_eq__ModEq) in e. contradict Hd; apply ModEq_sym; auto. apply modN_le_eq. destruct p; auto; contradict Hp; auto. destruct (modN Hp n); auto. destruct p. auto. simpl. rewrite <- minus_n_O. auto. apply Perm_In with (m:=map (fun x=>modN Hp (pow g x))(seq 0 (p-1))) in H3; auto. apply in_map_iff in H3. destruct H3 as [x [H7 H8]]. apply in_seq in H8. destruct H8. absurd (ModEq p (pow g x) n); auto. apply modN_eq__ModEq with Hp; auto. apply Perm_sym. apply NoDup_incl_Perm. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H8 H7]]. subst y. apply in_seq. split. remember (modN Hp (pow g z)) as m. destruct m; auto.
  assert (Coprime p (pow g z)). apply Coprime_pow; auto. assert (Divide p (pow g z)). apply modN_eq__ModEq with Hp; auto. rewrite <- Heqm. apply modN_le_eq; auto. absurd (p<=1); auto. inversion H0; auto. rewrite <- le_plus_minus; auto. apply NoDup_map; auto. cut (forall x y, x<=y ->In x (seq 0 (p-1))->In y (seq 0 (p-1))->ModEq p (pow g x) (pow g y)->x=y); intros. apply modN_eq__ModEq in H8. destruct (le_lt_dec x y); auto. symmetry; auto. intros. rewrite le_plus_minus with x y in H8; auto. rewrite pow_plus in H8. cut (ModEq p 1 (pow g (y-x))). intros. destruct (nat_eq_dec (y-x) 0). rewrite le_plus_minus with x y; auto. rewrite e; auto. apply in_seq in H7. destruct H7. absurd (p-1<=y); auto. apply le_trans with (y-x); auto. replace (p-1) with t; auto. apply Totient_unique with p; auto. apply le_minus. clear -H8 H6. revert H8. generalize (y-x). induction x; simpl; intros; auto. rewrite <- plus_n_O in H8; auto. apply IHx. apply ModEq_div with g; auto. rewrite mult_assoc; auto. rewrite map_length. rewrite seq_length. rewrite seq_length; auto. Defined.

Theorem ModOrder_mult: forall p a b o s, Prime p -> Coprime a b -> ModOrder p a o -> ModOrder p b s -> Coprime o s -> ModOrder p (a*b) (o*s). Proof. intros. inversion H1. inversion H5. inversion H2. inversion H12. destruct H8. destruct H15. subst a0 k n a1 k0 n0. clear H1 H2 H5 H12. apply ModOrder_intro; auto. apply MinP_intro. split. intros C. apply mult_is_O in C. destruct C; contradiction. replace 1 with (1*1); auto. rewrite pow_mult2. apply ModEq_mult. rewrite mult_comm. rewrite pow_mult. clear -H18. induction s; simpl; auto. replace 1 with (1*1); auto. rewrite pow_mult. clear -H19. induction o; simpl; auto. replace 1 with (1*1); auto. intros. destruct H1.
  cut (Divide o m); intros. cut (Divide s m); intros. destruct (Divide_multN H5) as [q H7]. subst m. rewrite mult_comm in H6. apply Euclid in H6; auto. destruct (Divide_multN H6) as [r H7]. subst q. rewrite mult_comm. rewrite <- mult_assoc. destruct r; simpl; auto. apply Euclid with o; auto. apply ModOrder_Divide with (n:=p) (a:=b) (k:=s) (d:=o*m); auto. apply ModEq_div with (pow a (o*m)); auto. rewrite <- pow_mult2. rewrite mult_1_r. replace (o*m) with (m*o) at 2; auto. repeat rewrite pow_mult. apply ModEq_trans with 1. clear -H2. induction o; simpl; auto. replace 1 with (1*1); auto. clear -H18. induction m; simpl; auto. replace 1 with (1*1); auto. apply Euclid with s; auto. apply ModOrder_Divide with (n:=p) (a:=a) (k:=o) (d:=s*m); auto. apply ModEq_div with (pow b (s*m)); auto. rewrite <- pow_mult2. rewrite mult_1_r. rewrite mult_comm. replace (s*m) with (m*s) at 2; auto. repeat rewrite pow_mult. apply ModEq_trans with 1. clear -H2. induction s; simpl; auto. replace 1 with (1*1); auto. clear -H19. induction m; simpl; auto. replace 1 with (1*1); auto. Qed.

Theorem ModRoot_fold: forall p l, Prime p -> (forall q, In q l->ModOrder p (fst q) (snd q)) -> ForallR Coprime (map fst l) -> ForallR Coprime (map snd l) -> ModOrder p (fold_right mult 1 (map fst l)) (fold_right mult 1 (map snd l)). Proof. induction l as [|[a o] l]; simpl; intros; auto. apply ModOrder_intro; auto. apply MinP_intro; auto. intros. destruct H3. destruct m; auto. inversion H1. inversion H2. subst x x0 l0 l1. apply ModOrder_mult; auto. clear -H6. revert H6. generalize (map fst l). intros m; induction m; simpl; intros; auto. apply (H0 (a,o)); auto. clear -H10. revert H10. generalize (map snd l) as m. induction m; simpl; intros; auto. Qed.

Theorem Prime_ModRoot: forall p, Prime p -> exists a, ModRoot p a. Admitted.


