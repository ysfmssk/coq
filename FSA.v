Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l le_n_S le_S_n.

Section CharType.

Variable C: Set.
Variable C_eq_dec: forall x y:C, {x=y}+{x<>y}.

(* Deterministic Finite Automata *)
Record DFA: Set := mkDFA {
  DFAstates: list nat; DFAtrans: nat->C->nat;
  DFAinit: nat; DFAaccept: list nat;
  DFAtrans_const: forall c s, In s DFAstates -> In (DFAtrans s c) DFAstates;
  DFAinit_const: In DFAinit DFAstates;
  DFAacc_const: incl DFAaccept DFAstates}.
Definition DFAacc (d:DFA) (w:list C) : Prop := In (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d).
Definition DFAacc_dec: forall d w, {DFAacc d w}+{~DFAacc d w}. intros. destruct (in_dec nat_eq_dec (fold_left (DFAtrans d) w (DFAinit d)) (DFAaccept d)); [left|right]; auto. Defined.

(* Non-deterministic Finite Automata *)
Record NFA: Type := mkNFA {
  NFAstates: list nat;
  NFAtrans: nat -> C -> list nat;
  NFAinit: list nat; (* take a list for future extension *)
  NFAaccept: list nat;
  NFAtrans_const: forall c s, In s NFAstates -> incl (NFAtrans s c) NFAstates;
  NFAinit_const: incl NFAinit NFAstates;
  NFAacc_const: incl NFAaccept NFAstates;
}.
Inductive NFAsteps (n:NFA) : list C -> list nat -> Prop:=
| NFAsteps_nil: forall s, NFAsteps n nil (s::nil)
| NFAsteps_cons: forall s t l w c, NFAsteps n w (t::l) -> In t (NFAtrans n s c) -> NFAsteps n (c::w) (s::t::l)
.
Inductive NFAacc (n:NFA) (w:list C) : Prop := NFAacc_intro: forall is es l, In es (NFAaccept n) ->In is (NFAinit n) -> NFAsteps n w l -> Head is l -> Tail es l -> NFAacc n w.
Hint Constructors NFAsteps NFAacc.

Theorem NFAsteps_const: forall n w s l, NFAsteps n w (s::l) -> In s (NFAstates n) -> incl l (NFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. intros x Hx. destruct Hx. inversion H. subst w s0 a l0. intros x Hx. destruct Hx. subst x. apply NFAtrans_const in H6; auto. apply IHl with w0 t in H1; auto. apply NFAtrans_const in H6; auto. Qed.
Definition NFAsteps_states': forall n w s, {sl| forall l, In l sl <-> Head s l /\ NFAsteps n w l}. induction w; intros. exists ((s::nil)::nil); intros; split; intros. destruct H. subst l; auto. destruct H. destruct H. inversion H0. subst l. inversion H. subst a s0 l. left; auto.
  exists (flat_map (fun t=>let (sl,_):= IHw t in map (cons s) sl) (NFAtrans n s a)). intros; split; intros. apply in_flat_map in H. destruct H as [t [H1 H2]]. destruct (IHw t) as [sl H3]. apply in_map_iff in H2. destruct H2 as [m [H4 H5]]. subst l. split; auto. apply H3 in H5. destruct H5. inversion H. subst a0 m. auto. destruct H. apply in_flat_map. inversion H0. subst a w0 l. inversion H. subst a s0 l. exists t. split; auto. destruct (IHw t) as [sl H6]. apply in_map_iff. exists (t::l0); auto. split; auto. apply H6. auto. Defined.
Definition NFAsteps_states: forall n w sl, {tl| forall t, In t tl <-> exists s, In s sl /\ exists l, NFAsteps n w l /\ Head s l /\ Tail t l & incl sl (NFAstates n) -> incl tl (NFAstates n)}. intros. exists (map (fun l=>match tail l with inleft (existT _  a _) => a |inright _ => 0 end) (flat_map (fun s=>let (l,_):=NFAsteps_states' n w s in l) sl)). intros; split; intros. apply in_map_iff in H. destruct H as [x [H H0]]. apply in_flat_map in H0. destruct H0 as [y [H0 H1]]. destruct (NFAsteps_states' n w y) as [l H2]. apply H2 in H1. destruct H1. destruct (tail x) as [[a [m H4]]|H4]. subst x a. exists y. split; auto. exists (m++t::nil); auto. subst x t. inversion H1.
  destruct H as [s [H1 [l [H2 [H3 H4]]]]]. apply in_map_iff. exists l. split. destruct (tail l) as [[a [m H5]]|H5]. subst l. apply Tail_app_rev in H4. inversion H4; auto. inversion H5. discriminate. subst l. inversion H3. apply in_flat_map. exists s. split; auto. destruct (NFAsteps_states' n w s). apply i. auto. intros. intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. destruct (NFAsteps_states' n w z) as [tl H5]. apply H5 in H4. destruct H4. destruct (tail y) as [[a [m H4]]|H4]. subst a y. inversion H0. subst a. destruct m. inversion H6. subst x l. apply H; auto. inversion H6. subst n0 l. simpl in H2. apply NFAsteps_const in H2. apply H2. apply in_or_app. right; auto. apply H; auto. subst y. inversion H0.  Defined.

Definition NFAacc_dec: forall n w, {NFAacc n w}+{~NFAacc n w}. intros. destruct (NFAsteps_states n w (NFAinit n)) as [tl H _]. destruct findP with (l:=tl) (P:=fun s=>In s (NFAaccept n)) as [[s H0]|H0]. intros. apply in_dec. apply nat_eq_dec. left. apply H in H0.  destruct H0 as [is [H1 [l [H2 [H3 H4]]]]]. apply NFAacc_intro with is s l; auto. right. intros D. inversion D. contradict H1. apply H0. apply H. exists is. split; auto. exists l; auto. Defined.

Theorem NFAsteps_app: forall n w1 l1, NFAsteps n w1 l1 -> forall w2 l2 s, NFAsteps n w2 (s::l2) -> Tail s l1 -> NFAsteps n (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply NFAsteps_cons; auto. apply IHNFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem NFAsteps_app_s_rev: forall n l1 l2 w s, NFAsteps n w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists (c::w0); auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n0 l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists (c::w1). exists w2. split; simpl; f_equal; auto. Qed.
Theorem NFAsteps_app_w_rev: forall n w1 w2 l, NFAsteps n (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ NFAsteps n w1 l1 /\ NFAsteps n w2 (s::l2) /\ Tail s l1. Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|t l]. inversion H. exists t. exists (t::nil). exists l; auto. inversion H. subst c0 w l. apply IHw1 in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. exists u. destruct l1. inversion Hb. inversion Ha. subst n0 l0. exists (s::t::l1). exists l2. split; auto. Qed.
Theorem NFAsteps_parteq: forall n1 n2 w l st, incl l st -> (forall s c, In s st -> NFAtrans n1 s c = NFAtrans n2 s c) -> NFAsteps n1 w l -> NFAsteps n2 w l. Proof. intros. induction H1; auto. apply NFAsteps_cons; auto. apply IHNFAsteps. intros x Hx; auto. rewrite <- H0; auto. Qed.
Theorem NFAsteps_length: forall n w l, NFAsteps n w l -> length l = S(length w). Proof. intros. induction H; simpl; auto. Qed.

(* Non-deterministic Finite Automata with Empty *)
Record EFA: Set := mkEFA {
  EFAstates: list nat; EFAtrans: nat->C->list nat; EFAempty: nat->list nat;
  EFAinit: list nat; (* take a list for future extension *)
  EFAaccept: list nat;
  EFAtrans_const: forall c s, In s EFAstates -> incl (EFAtrans s c) EFAstates;
  EFAempty_const: forall s, In s EFAstates -> incl (EFAempty s) EFAstates;
  EFAinit_const: incl EFAinit EFAstates;
  EFAacc_const: incl EFAaccept EFAstates;
}.
Inductive EFAsteps (n:EFA) : list C -> list nat -> Prop:=
| EFAsteps_nil: forall s, EFAsteps n nil (s::nil)
| EFAsteps_empty: forall s t l w, EFAsteps n w (t::l) -> In t (EFAempty n s) -> EFAsteps n w (s::t::l)
| EFAsteps_cons: forall s t l w c, EFAsteps n w (t::l) -> In t (EFAtrans n s c) -> EFAsteps n (c::w) (s::t::l)
.
Inductive EFAacc (n:EFA) (w:list C) : Prop := EFAacc_intro: forall is es l, In es (EFAaccept n) -> In is (EFAinit n) -> EFAsteps n w l -> Head is l -> Tail es l -> EFAacc n w.
Hint Constructors EFAsteps EFAacc clos_refl_trans.

Theorem EFAsteps_const: forall n w s l, In s (EFAstates n) -> EFAsteps n w l -> Head s l -> incl l (EFAstates n). Proof. intros n w s l. revert s. revert w. induction l; intros. inversion H1. intros x Hx. destruct Hx. subst x. inversion H1. subst a a0 l0. auto. inversion H1. subst a0 a l0. clear H1. inversion H0. subst l. destruct H2. subst w0 s0 l. apply IHl with w t in H2; auto. apply EFAempty_const in H6; auto. subst w s0 l. apply IHl with w0 t in H2; auto. apply EFAtrans_const in H6; auto. Qed.
Theorem EFAsteps_app: forall e w1 l1, EFAsteps e w1 l1 -> forall w2 l2 s, EFAsteps e w2 (s::l2) -> Tail s l1 -> EFAsteps e (w1++w2) (l1++l2). Proof. intros e w1 l1 H. induction H; simpl; intros. inversion H0. subst a s0; auto. inversion H3. apply EFAsteps_empty; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2. inversion H5; auto. apply EFAsteps_cons; auto. replace (t::l++l2) with ((t::l)++l2); auto. apply IHEFAsteps with s0; auto. inversion H2; auto. Qed.
Theorem EFAsteps_app_s_rev: forall e l1 l2 w s, EFAsteps e w (l1++l2) -> Tail s l1 -> exists w1 w2, w=w1++w2 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction l1 as [|t l1]; simpl; intros. inversion H0. inversion H. subst w s0. exists nil. exists nil. split; auto. split. destruct l1; auto. inversion H4. destruct l2; auto. destruct l1; inversion H4. subst w0 s0. rewrite H2 in H4. inversion H0. subst a t l1. simpl in H2. subst l2. exists nil. exists w; auto. subst a b l0. destruct l1. inversion H6. inversion H2. subst n l. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H9 [H7 H8]]]]. exists w1. exists w2. split; auto.
  subst s0. inversion H0. subst a t l1. exists nil. exists (c::w0). simpl in H2. subst l2. auto. subst a b l0. destruct l1. inversion H7. inversion H2. subst n l. replace (t0::l1++l2) with ((t0::l1)++l2) in H4; auto. apply IHl1 with (s:=s) in H4; auto. destruct H4 as [w1 [w2 [H6 [H8 H9]]]]. exists (c::w1). exists w2. split; auto. subst w0. auto. Qed.
Theorem EFAsteps_cons_rev: forall n w c l, EFAsteps n (c::w) l -> exists s t l1 l2, l=l1++t::l2 /\ Tail s l1 /\ EFAsteps n nil l1 /\ EFAsteps n w (t::l2) /\ In t (EFAtrans n s c). Proof. intros n w c l H. remember (c::w) as w' in H. revert Heqw'. revert c w. induction H; intros. inversion Heqw'. apply IHEFAsteps in Heqw'. destruct Heqw' as [s' [t' [l1' [l2' [H1 [H2 [H3 [H4 H5]]]]]]]].  exists s'. exists t'. exists (s::l1'). exists l2'. split. simpl; f_equal; auto. split ; auto. split; auto. destruct l1'. inversion H3. inversion H1. subst n0 l. apply EFAsteps_empty; auto.
  inversion Heqw'. subst c0 w0. exists s. exists t. exists (s::nil). exists l; auto. Qed.
Theorem EFAsteps_app_w_rev: forall e w1 w2 l, EFAsteps e (w1++w2) l -> exists s l1 l2, l=l1++l2 /\ Tail s l1 /\ EFAsteps e w1 l1 /\ EFAsteps e w2 (s::l2). Proof. induction w1 as [|c w1]; simpl; intros. destruct l as [|s l]. inversion H. exists s. exists (s::nil). exists l; auto. destruct (EFAsteps_cons_rev H) as [s [t [l1 [l2 [H1 [H2 [H3 [H4 H5]]]]]]]]. subst l. destruct (IHw1 w2 (t::l2) H4) as [u [m1 [m2 [H6 [H7 [H8 H9]]]]]]. destruct m1. inversion H8. inversion H6. subst n l2. exists u. exists (l1++t::m1). exists m2. split; auto. rewrite <- app_assoc; auto. split. clear -H7. induction l1; simpl; auto. split; auto. replace (c::w1) with (nil++c::w1); auto. apply EFAsteps_app with s; auto. Qed.
Definition EFA_empty_states': forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}. intros n sl. apply (Fix (well_founded_ltof (list nat) (fun l=>length (removeAll nat_eq_dec l (EFAstates n))))) with (P:=fun sl=>incl sl (EFAstates n)->{tl|forall t,In t tl<->exists s,In s sl/\clos_refl_trans nat (fun x y=>In y (EFAempty n x)) s t}). clear sl. intros sl IH H.
  destruct (incl_dec nat_eq_dec (flat_map (EFAempty n) sl) sl) as [[x H0 H1]|H0]. destruct (IH (flat_map (EFAempty n) sl++sl)) as [tl H2]. unfold ltof. rewrite removeAll_app. apply removeAll_length2 with x; auto. apply removeAll_In. split; auto. apply in_flat_map in H0. destruct H0 as [y [H2 H3]]. apply (EFAempty_const n) in H3; auto.
  intros y Hy. apply in_app_or in Hy. destruct Hy; auto. apply in_flat_map in H2. destruct H2 as [z [H3 H4]]. apply (EFAempty_const n) in H4; auto. exists tl. intros t; split; intros. apply H2 in H3. destruct H3 as [s [H4 H5]]. apply in_app_or in H4. destruct H4. apply in_flat_map in H3. destruct H3 as [u [H6 H7]]. exists u. split; auto. apply rt_trans with s; auto. exists s; auto. apply H2. destruct H3 as [s [H4 H5]]. exists s. split; auto. apply in_or_app; auto.
  exists sl. intros; split; intros. exists t; auto. destruct H1 as [s [H2 H3]]. clear -H0 H2 H3. induction H3; auto. apply H0. apply in_flat_map. exists x; auto. Defined.
Theorem EFAsteps_incl: forall e1 e2 w l st, incl l st -> (forall s t, In s st-> In t (EFAempty e1 s) -> In t st -> In t (EFAempty e2 s)) -> (forall s c t, In s st -> In t (EFAtrans e1 s c) -> In t st -> In t (EFAtrans e2 s c)) -> EFAsteps e1 w l -> EFAsteps e2 w l. Proof. intros. induction H2; auto. apply EFAsteps_empty; auto. apply IHEFAsteps. intros x Hx; auto. apply EFAsteps_cons; auto. apply IHEFAsteps. intros x Hx; auto. Qed.

Definition EFA_empty_states: forall n sl, incl sl (EFAstates n) -> {tl|forall t, In t tl<->exists s, In s sl /\ exists l, EFAsteps n nil l /\ Head s l /\ Tail t l}. intros. destruct (EFA_empty_states' n H) as [tl H0]. exists tl. intros; split; intros. apply H0 in H1. destruct H1 as [s [H2 H3]]. exists s. split; auto. clear -H3. induction H3. exists (x::y::nil); auto. exists (x::nil); auto. destruct IHclos_refl_trans1 as [l [H1 [H2 H3]]]. destruct IHclos_refl_trans2 as [m [H4 [H5 H6]]]. inversion H5. subst a m. exists (l++l0). split. assert (EFAsteps n (nil++nil) (l++l0)). apply EFAsteps_app with y; auto. simpl in H; auto. split. inversion H2; simpl; auto. inversion H6. rewrite app_nil_r; auto. clear -H7. induction l; simpl; auto.
  apply H0. destruct H1 as [s [H2 [l [H3 [H4 H5]]]]]. exists s. split; auto. clear H2. revert dependent s. revert dependent t. clear -H3. induction l; intros. inversion H3. inversion H4. subst a0 a l0. inversion H3. subst s0 l. inversion H5. apply rt_refl. inversion H1. subst w s0 l. inversion H5. subst a b l. apply rt_trans with t0. apply rt_step; auto. apply IHl; auto. Defined.

Definition EFAsteps_states: forall n w sl, incl sl (EFAstates n) -> {tl|forall t, In t tl <-> exists s, In s sl /\ exists l, EFAsteps n w l /\ Head s l /\ Tail t l}. induction w as [|c w]; intros. destruct (EFA_empty_states n H) as [tl H0]. exists tl. auto.
  destruct (EFA_empty_states n H) as [tl H0]. assert (H1: incl (flat_map (fun s=>EFAtrans n s c) tl) (EFAstates n)). intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H1 H2]]. apply EFAtrans_const in H2; auto. destruct (H0 y). destruct (H3 H1) as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hc. subst a l. apply EFAsteps_const with (s:=s) in Hb; auto. destruct (IHw (flat_map (fun s=>EFAtrans n s c) tl) H1) as [ul H2]. clear IHw. exists ul. intros; split; intros. apply H2 in H3. destruct H3 as [s [Ha [l [Hb [Hc Hd]]]]]. clear H2. apply in_flat_map in Ha. destruct Ha as [x [H3 H2]]. apply H0 in H3. destruct H3 as [y [H4 [m [H5 [H6 H7]]]]]. exists y. split; auto. exists (m++l). split. replace (c::w) with (nil++c::w); auto. apply EFAsteps_app with x; auto. inversion Hc. subst a l. apply EFAsteps_cons; auto. split. inversion H6; simpl; auto. clear -Hd. induction m; simpl; auto.
  apply H2. clear H2. destruct H3 as [s [H4 [l [H5 [H6 H7]]]]]. destruct (EFAsteps_cons_rev H5) as [u [v [l1 [l2 [Ha [Hb [Hc [Hd He]]]]]]]]. subst l. exists v. split. apply in_flat_map. exists u. split; auto. apply H0. exists s. split; auto. exists l1; auto. split; auto. split; auto. destruct l1. inversion Hc. inversion H6; auto. exists (v::l2). split; auto. split; auto. clear -H7. induction l1; simpl; auto. inversion H7; auto. destruct l1; inversion H2. Defined. 
Definition EFAacc_dec: forall n w, {EFAacc n w}+{~EFAacc n w}. intros. destruct (EFAsteps_states n w) with  (sl:=EFAinit n) as [tl H]. intros x H. apply (EFAinit_const n) in H; auto. destruct findP with (P:=fun s=>In s tl) (l:=EFAaccept n). intros. apply in_dec. apply nat_eq_dec. destruct s as [s H1 H2]. left. apply H in H2. destruct H2 as [is [H4 [l [H5 [H6 H7]]]]]. apply EFAacc_intro with is s l; auto. right. intros D. inversion D. apply n0 in H0. contradict H0. apply H. exists is. split; auto. exists l; auto. Defined.

Definition EFA2NFA: forall e, {n| forall w, EFAacc e w <-> NFAacc n w}. intros. destruct (EFA_empty_states e (EFAinit_const e)) as [is H]. assert (Hi: incl is (EFAstates e)). intros x Hx. apply H in Hx. destruct Hx as [s [H1 [l [H2 [H3 H4]]]]]. apply (EFAinit_const e) in H1. inversion H3. subst a l. apply EFAsteps_const with (s:=s) in H2; auto. remember (fun s c=>match in_dec nat_eq_dec s (EFAstates e) with |left H => match EFA_empty_states e (EFAtrans_const e c s H) with exist _ sl _ => sl end |right _ => nil end) as tr. assert (Ht: forall c s, In s (EFAstates e) -> incl (tr s c) (EFAstates e)). intros. subst tr. destruct (in_dec nat_eq_dec s (EFAstates e)); [|contradiction]. destruct (EFA_empty_states e (EFAtrans_const e c s i)) as [tl H1]. intros x Hx. apply H1 in Hx.  destruct Hx as [t [H2 [l [H3 [H4 H5]]]]]. inversion H4. subst a l. assert (In t (EFAstates e)). apply (EFAtrans_const e c s); auto. apply EFAsteps_const with (s:=t) in H3; auto.
  exists (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)). cut (forall w t, (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail t l) <-> exists s, In s is /\ exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\ Tail t l). intros; split; intros. inversion H1. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w l /\ Head s l /\ Tail es l). exists is0. split; auto. exists l; auto. apply (H0 w es) in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply NFAacc_intro with s es m; auto. inversion H1. assert (exists s, In s is/\ exists l, NFAsteps (mkNFA tr Ht Hi (EFAacc_const e)) w l /\ Head s l /\Tail es l). exists is0; split; auto. exists l; auto. apply H0 in H7. destruct H7 as [s [Ha [m [Hb [Hc Hd]]]]]. apply EFAacc_intro with s es m; auto.
  intros w. apply (Fix (well_founded_ltof (list C) (length (A:=C)))) with (P:=fun w=>forall t, (exists s, In s (EFAinit e)/\(exists l, EFAsteps e w l/\Head s l/\Tail t l))<->(exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w l/\Head s l/\Tail t l)). clear w. intros w IH t. destruct (tail w) as [[c [w' H1]]|H1]. subst w. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. apply EFAsteps_app_w_rev in H2. destruct H2 as [u [l1 [l2 [Ha [Hb [Hc Hd]]]]]]. subst l. apply EFAsteps_cons_rev in Hd. destruct Hd as [v [w [m1 [m2 [H5 [H6 [H7 [H8 H9]]]]]]]]. assert (exists s, In s (EFAinit e) /\ exists l, EFAsteps e w' l/\Head s l/\Tail v l). exists s. split; auto. destruct m1. inversion H7. inversion H5. subst n l2. exists (l1++m1); auto. split; auto. replace w' with (w'++nil). apply EFAsteps_app with u; auto. rewrite app_nil_r; auto. split. destruct l1. inversion Hc. inversion H3; simpl; auto. inversion H6. subst v m1 a. rewrite app_nil_r; auto. clear -H10. induction l1; simpl; auto. apply IH in H0. clear IH. destruct H0 as [x [Hd [l [He [Hf Hg]]]]]. exists x. split; auto. exists (l++t::nil). split. apply NFAsteps_app with v; auto. apply NFAsteps_cons; auto.
  simpl. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0. exists w. split; auto. exists (w::m2). split; auto. split; auto. destruct l2. destruct m1. inversion H7. inversion H5. destruct m1; inversion H10. clear -H5 H4. assert (Tail t (n::l2)). induction l1; auto. apply IHl1. inversion H4; auto. destruct l1; inversion H2. destruct m1. inversion H5. subst u m2. auto. inversion H5. rewrite H2 in H. clear -H. induction m1; auto. apply IHm1. inversion H; auto. destruct m1; inversion H3. contradict n. apply Hi in Hd. inversion Hf. subst a l. apply NFAsteps_const in He. simpl in He. inversion Hg; auto.  simpl; auto. split. inversion Hf; simpl; auto. clear -l. induction l; simpl; auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  destruct H0 as [u [H1 [l [H2 [H3 H4]]]]]. apply NFAsteps_app_w_rev in H2. destruct H2 as [v [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. assert (exists s, In s is/\exists l, NFAsteps (mkNFA (NFAstates:=EFAstates e) tr Ht Hi (EFAacc_const e)) w' l/\Head s l/\Tail v l). exists u. split; auto. exists m1; split; auto. split; auto. destruct m1. inversion Hb. inversion H3; auto. apply IH in H0. clear IH. destruct H0 as [x [H5 [l [H6 [H7 H8]]]]]. exists x; split; auto. inversion Hc. subst c0 w s m2. clear Hc. simpl in H12. inversion H10. subst t0 l0. clear H10.  assert (s=t). clear -H4. induction m1; simpl; auto. inversion H4; auto. inversion H1. apply IHm1. inversion H4; auto. destruct m1; inversion H2. subst s. clear H4. subst tr. destruct (in_dec nat_eq_dec v (EFAstates e)). destruct (EFA_empty_states e (EFAtrans_const e c v i)). apply i0 in H12. destruct H12 as [s [H13 [m [H14 [H15 H16]]]]]. exists (l++m). split. apply EFAsteps_app with v; auto. inversion H15. subst a m. apply EFAsteps_cons; auto. split. inversion H7; simpl; auto. clear -H16. induction l; simpl; auto. contradict n. inversion H7. subst a l.  clear -H8 H5 H6. apply EFAinit_const in H5. inversion H8. auto. subst a b l0. apply EFAsteps_const with (s:=x) in H6; auto. clear -c. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. split; intros. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. exists t. split. apply H. exists s. split; auto. exists l; auto. exists (t::nil); auto. destruct H0 as [s [H1 [l [H2 [H3 H4]]]]]. inversion H2. subst l. inversion H3. subst a s0 l. inversion H4. subst a t. apply H in H1. destruct H1 as [t [Ha [l [Hb [Hc Hd]]]]]. exists t. split; auto. exists l; auto. inversion H6. Qed.
 
Definition NFA2EFA: forall n, {e|forall w, EFAacc e w <-> NFAacc n w}. intros. assert (H: forall s, In s (NFAstates n) -> incl ((fun _=>nil) s) (NFAstates n)). intros. intros x Hx; inversion Hx. exists (mkEFA (NFAtrans n) (fun _ => nil) (NFAtrans_const n) H (NFAinit_const n) (NFAacc_const n)). intros; split; intros. inversion H0. clear H0. simpl in H1. simpl in H2. apply NFAacc_intro with is es l; auto. clear -H3. induction H3; auto. simpl in H0. inversion H0. inversion H0. apply EFAacc_intro with is es l; auto. clear -H3. induction H3; auto. Defined.

Definition DFA2NFA: forall d, {n|forall w, DFAacc d w <-> NFAacc n w}. intros. assert (Ht: forall c s, In s (DFAstates d)->incl (DFAtrans d s c::nil) (DFAstates d)). intros. intros x Hx. destruct Hx. subst x. apply DFAtrans_const; auto. destruct H0. assert (Hi: incl (DFAinit d::nil) (DFAstates d)). intros x Hx. destruct Hx. subst x. apply DFAinit_const; auto. destruct H. exists (mkNFA (fun s c=>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)). unfold DFAacc. cut (forall w s t, t=fold_left (DFAtrans d) w s <-> exists l, NFAsteps (mkNFA (fun s c =>DFAtrans d s c::nil) Ht Hi (DFAacc_const d)) w l /\ Head s l /\Tail t l). intros. split; intros. destruct (H w (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d))). destruct H1 as [l [H3 [H4 H5]]]; auto. apply NFAacc_intro with (DFAinit d) (fold_left (DFAtrans d) w (DFAinit d)) l; auto. simpl. auto. inversion H0. clear H0. simpl in H1. simpl in H2. destruct H2; [|destruct H0]. subst is. assert (es=fold_left (DFAtrans d) w (DFAinit d)). apply H. exists l; auto. rewrite <- H0; auto.
  induction w; intros; split; intros. simpl in H. subst t. exists (s::nil); auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. subst l. inversion H2. subst a s0 l. inversion H3. subst t; auto. inversion H4. simpl in H. subst t. destruct (IHw (DFAtrans d s a) (fold_left (DFAtrans d) w (DFAtrans d s a))). clear IHw H0. destruct H as [l [H1 [H2 H3]]]; auto. exists (s::l). split; auto. inversion H2. subst a0 l. apply NFAsteps_cons; auto. simpl. auto. destruct H as [l [H1 [H2 H3]]]. inversion H1. clear H1. simpl in H6. destruct H6; [|destruct H1]. subst a w0 l t0. simpl. apply IHw. clear IHw. inversion H2. subst s0 a l. exists (DFAtrans d s c::l0); auto. split; auto. split; auto. inversion H3; auto. Defined.
Definition DFA2EFA: forall d, {e|forall w, DFAacc d w <-> EFAacc e w}. intros. destruct (DFA2NFA d) as [n H]. destruct (NFA2EFA n) as [e H0]. exists e. intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition NFA2DFA: forall n, {d|forall w, NFAacc n w <-> DFAacc d w}. intros. remember (fun s c=>ps2i nat_eq_dec (NFAstates n) (flat_map (fun s=>NFAtrans n s c) (i2ps nat_eq_dec (NFAstates n) s))) as t. assert (Hu: forall c s, In s (seq 0 (psSize nat_eq_dec (NFAstates n))) -> In (t s c) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros. subst t. apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply in_flat_map in Hx. destruct Hx as [y [H4 H5]]. apply NFAtrans_const in H5; auto. apply i2ps_spec1 in H4; auto. apply in_seq in H. destruct H; auto. assert (Hj: In (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) (seq 0 (psSize nat_eq_dec (NFAstates n)))). apply in_seq. split. apply le_O_n. apply ps2i_spec1. intros x Hx. apply NFAinit_const; auto. destruct (contain_powerSet nat_eq_dec (NFAstates n) (NFAaccept n)) as [al H4]. assert (Hac: incl (map (ps2i nat_eq_dec (NFAstates n)) al) (seq 0 (psSize nat_eq_dec (NFAstates n)))). intros x Hx. apply in_seq. split. apply le_O_n. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply ps2i_spec1; auto. assert (Exists (equiv y) al). apply Exists_exists. exists y; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. exists (mkDFA t (ps2i nat_eq_dec (NFAstates n)  (NFAinit n)) Hu Hj Hac).
  assert (H5: forall w, fold_left t w (ps2i nat_eq_dec (NFAstates n) (NFAinit n)) = let (tl,_,_) := NFAsteps_states n w (NFAinit n) in ps2i nat_eq_dec (NFAstates n) tl). apply (Fix (well_founded_ltof (list C) (length (A:=C)))). intros w IH. destruct (tail w) as [[c [w' H1]]|H1]. subst w. destruct (NFAsteps_states n (w'++c::nil) (NFAinit n)) as [tl H1 Ht]. rewrite fold_left_app. rewrite IH. clear IH. destruct (NFAsteps_states n w' (NFAinit n)) as [ul H0 Hv]. simpl. subst t. apply ps2i_spec3. intros x; split; intros. apply in_flat_map in H. destruct H as [y [H5 H6]]. apply i2ps_spec3 in H5. apply H1. apply H0 in H5. destruct H5 as [s [Ha [l [Hb [Hc Hd]]]]]. exists s. split; auto. exists (l++x::nil); split. apply NFAsteps_app with y; auto. split. inversion Hc; simpl; auto. clear -l. induction l; simpl; auto. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H1 in H. destruct H as [s [H5 [l [H6 [H7 H8]]]]]. apply in_flat_map. apply NFAsteps_app_w_rev in H6. destruct H6 as [t [m1 [m2 [Ha [Hb [Hc Hd]]]]]]. subst l. inversion Hc. subst c0 w s0 m2. inversion H6. subst t0 l. clear Hc H6. assert (x=s0). clear -H8. induction m1. inversion H8; auto. inversion H1. apply IHm1. inversion H8; auto. destruct m1; inversion H2. subst s0. exists t. split; auto. apply i2ps_spec3. apply Hv. intros z Hz. apply NFAinit_const; auto. apply H0. destruct m1. inversion Hb. inversion H7. subst n0 a l. exists s. split; auto. exists (s::m1); auto. unfold ltof. rewrite app_length. rewrite plus_comm; auto.
  subst w. clear IH. destruct (NFAsteps_states n nil (NFAinit n)) as [ul H0 Hv]. simpl. apply ps2i_spec3. intros x; split; intros. apply H0. exists x; split; auto. exists (x::nil); auto. apply H0 in H. destruct H as [s [Ha [l [Hb [Hc Hd]]]]]. inversion Hb. subst l. inversion Hc. subst a s0 l. inversion Hd. subst a x. auto. inversion H2.
  intros; split; intros. inversion H. unfold DFAacc; simpl. rewrite H5. destruct (NFAsteps_states n w (NFAinit n)) as[tl H7 H8]. apply in_map_iff. assert (Exists (equiv tl) al). apply H4. split. apply H8. intros x Hx. apply NFAinit_const; auto. exists es; split; auto. apply H7. exists is; split; auto. exists l; auto. apply Exists_exists in H9. destruct H9 as [x [Ha Hb]]. exists x; split; auto. apply ps2i_spec3. apply equiv_sym; auto. unfold DFAacc in H. simpl in H. apply in_map_iff in H. destruct H as [x [H1 H2]]. rewrite H5 in H1. destruct (NFAsteps_states n w (NFAinit n)) as [ul H6 H7]. apply ps2i_spec2 in H1. assert (Exists (equiv ul) al). apply Exists_exists. exists x. split; auto. apply equiv_sym; auto. apply H4 in H. destruct H. destruct H0 as [y [H8 H9]]. apply H6 in H8. destruct H8 as [s [Ha [l [Hb [Hc Hd]]]]]. apply NFAacc_intro with s y l; auto. assert (Exists (equiv x) al). apply Exists_exists. exists x; split; auto. apply equiv_refl. apply H4 in H. destruct H; auto. apply H7. intros y Hy. apply NFAinit_const; auto. Defined.

Definition EFA2DFA: forall e, {d|forall w, EFAacc e w <-> DFAacc d w}. intros. destruct (EFA2NFA e) as [n H]. destruct (NFA2DFA n) as [d H0]. exists d; intros; split; intros. apply H0. apply H; auto. apply H; apply H0; auto. Defined.

Definition EFA_map: forall e (f:nat->nat), (forall x y, In x (EFAstates e) -> In y (EFAstates e) -> f x=f y -> x=y) -> {e'|EFAstates e'=map f (EFAstates e) & forall w, EFAacc e w <-> EFAacc e' w}. intros e. destruct e as [st tr emp ini acc Htr Hemp Hini Hacc]. simpl. intros. destruct (inv_func nat_eq_dec f st 0 H) as [g Hg1 _]. remember (fun s c=>map f (tr (g s) c)) as tr'. assert (Htr': forall c s, In s (map f st) -> incl (tr' s c) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst tr'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Htr in H4; auto. remember (fun s=>map f (emp (g s))) as emp'. assert (Hemp': forall s, In s (map f st)->incl (emp' s) (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. subst emp'. rewrite Hg1; auto. intros y Hy. apply in_map_iff in Hy. destruct Hy as [z [H3 H4]]. subst y. apply in_map_iff. exists z; split; auto. apply Hemp in H4; auto. assert (Hini': forall s, In s (map f ini)->In s (map f st)). intros. apply in_map_iff in H0. destruct H0 as [x [H1 H2]]. subst s. apply in_map_iff. exists x; split; auto. assert (Hacc': incl (map f acc) (map f st)). intros x Hx. apply in_map_iff in Hx. destruct Hx as [y [H1 H2]]. subst x. apply in_map_iff. exists y; split; auto.
  exists (mkEFA tr' emp' Htr' Hemp' Hini' Hacc'); auto. intros; split; intros; inversion H0. simpl in H1. simpl in H2. clear H0. apply EFAacc_intro with (f is) (f es) (map f l); simpl; auto. apply in_map_iff. exists es; split; auto. apply in_map_iff. exists is; auto. assert (H6:incl l st). apply EFAsteps_const with (s:=is) in H3; auto. subst emp' tr'. clear -H3 H6 Hg1. revert H3. revert H6. revert w. induction l; intros. inversion H3. inversion H3; simpl; auto. subst a w0 l. apply EFAsteps_empty; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. simpl in H4. apply in_map_iff. exists t. split; auto. rewrite Hg1; auto. subst a w l. apply EFAsteps_cons; auto. apply IHl; auto. intros x Hx. apply H6. right; auto. simpl. rewrite Hg1; auto. apply in_map_iff. exists t; split; auto. inversion H4; simpl; auto. clear -H5. induction H5; simpl; auto.
  simpl in H1. simpl in H2. clear H0. apply in_map_iff in H1. destruct H1 as [es' [H6 H1]]. subst es. apply in_map_iff in H2. destruct H2 as [is' [H6 H2]]. subst is. apply EFAacc_intro with is' es' (map g l); simpl; auto. assert (H6:incl l (map f st)). apply EFAsteps_const with (s:=f is') in H3; auto. simpl. apply in_map_iff. exists is'; split; auto.  revert H3. revert H6. revert w. subst emp' tr'. clear -Hg1. induction l; intros. inversion H3. inversion H3; simpl; auto. apply EFAsteps_empty; auto. subst w0 a l. apply IHl; auto. intros x Hx; auto. simpl. simpl in H4. subst a w0 l. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Hemp in H5; auto. cut (In s (map f st)); intros. apply in_map_iff in H. destruct H as [x [H7 H8]]. subst s. rewrite Hg1; auto. apply H6; auto. apply EFAsteps_cons; auto. subst w a l. apply IHl; auto. intros x Hx; auto. simpl. subst w a l. simpl in H4. apply in_map_iff in H4. destruct H4 as [u [H4 H5]]. subst t. rewrite Hg1; auto. apply Htr in H5; auto. cut (In s (map f st)); intros; auto. apply in_map_iff in H. destruct H as [x [H8 H7]]. subst s. rewrite Hg1; auto. inversion H4; simpl. rewrite Hg1; auto. apply Hacc in H1. clear -H1 H5 Hg1. induction l. inversion H5. simpl. inversion H5; auto. simpl. rewrite Hg1; auto. Defined.

End CharType.
Hint Constructors NFAsteps NFAacc EFAsteps EFAacc.