Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import Peano_LQ.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l.

Theorem Var_Eq_sym: forall x y l, Inf l (#x==#y) -> Inf l (#y==#x). Proof. intros. apply IMp with (#x==#x); auto. apply IMp with (#x==#y); auto. apply IAx. apply PAE2 with (S(max x y)) (#S(max x y)) (#x); auto; apply nVT_SubTerm; intros C; apply VT_var in C; absurd (x<x); auto; rewrite <- C at 2; auto. Qed.
Theorem Var_Eq_trans: forall x y z l, Inf l (#x==#y) -> Inf l (#y==#z) -> Inf l (#x==#z). Proof. intros. apply IMp with (#y==#z); auto. apply IMp with (#y==#x); [|apply Var_Eq_sym]; auto. apply IAx. apply PAE2 with (S z) (#S z) (#z); auto; apply nVT_SubTerm; intros C; apply VT_var in C. Qed.
Theorem Term_Eq_refl: forall t l, Inf l (t==t). Proof. intros. apply Inf_incl with nil; auto. apply Ui with (#0==#0) 0 t; auto. Qed.
Theorem Term_Eq_sym: forall t u l, Inf l (t==u) -> Inf l (u==t). Proof. intros. apply IMP with (t==u) nil l; auto. remember (newVar nil (u::nil) nil) as v. apply Ui with (#v==u==>u==#v) v t; auto. apply Ug; auto. apply Ui with (#v==#S v==>#S v==#v) (S v) u; auto. apply Ug; auto. apply Ded. apply Var_Eq_sym; auto. subst v. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; eapply newVar_nVT; eauto. Qed.
Theorem Term_Eq_trans: forall s t u l, Inf l (s==t) -> Inf l (t==u) -> Inf l (s==u). Proof. intros. apply IMp with (t==u); auto. apply IMP with (s==t) nil l; auto. remember (newVar nil (s::t::u::nil) nil) as v. apply Ui with (s==t==>t==(#v)==>s==(#v)) v u; auto. apply Ug; auto. apply Ui with (s==(#S v)==>(#S v)==(#v)==>s==(#v)) (S v) t; auto. apply Ug; auto. apply Ui with (#S (S v)==#S v==>#S v==#v==>#S (S v)==#v) (S(S v)) s; auto. apply Ug; auto. apply Ded. apply Ded. apply Var_Eq_trans with (S v); auto. repeat apply TFFSub_Imp; auto; apply TFFSub_Eq; auto; apply nVT_SubTerm; intros C; inversion C; contradict H3; clear -v; induction v; auto. repeat apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; subst v; eapply newVar_nVT; eauto. repeat apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; subst v; eapply newVar_nVT; eauto. Qed.
Theorem Var_Eq_SubTerm: forall v x y t tx ty l, Inf l (#x==#y) -> SubTerm v (#x) t tx -> SubTerm v (#y) t ty -> Inf l (tx==ty). Proof. intros. remember (newVar (x::nil) (t::nil) nil) as z. destruct (subTerm_sig v (#z) t) as [t' H2 H3]. assert (Hz:~VarTerm z t). subst z; eapply newVar_nVT; eauto. assert (SubTerm z (#x) t' tx). apply SubTerm_via with v t; auto. assert (SubTerm z (#y) t' ty). apply SubTerm_via with v t; auto. apply IMp with (tx==tx). apply IMp with (#x==#y); auto. apply IAx. apply PAE2 with z tx t'; auto; apply nVT_SubTerm; apply SubTerm_nVT2 with v (#x) t; auto; intros C; apply VT_var in C; subst z; absurd (In x (x::nil)); auto; rewrite <-C at 1; eapply newVar_nVar; eauto. apply Term_Eq_refl. Qed.
Theorem Term_Eq_SubTerm: forall t u l v f ft fu, Inf l (t==u) -> SubTerm v t f ft -> SubTerm v u f fu -> Inf l (ft==fu). Proof. intros. apply IMP with (t==u) nil l; auto. remember (newVar nil (u::f::nil) nil) as x. apply Ui with (#x==u==>subTerm v (#x) f==fu) x t. apply Ug; auto. apply Ui with (#x==#S x==>subTerm v (#x) f==subTerm v (#S x) f) (S x) u; auto. apply Ug; auto. apply Ded. apply Var_Eq_SubTerm with v x (S x) f; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C. apply SubTerm_or with (v:=v) (s:=f) (t:=#x) in C; auto. destruct C. inversion H2. contradict H5; auto. contradict H2. apply newVar_nVT with nil (u::f::nil) nil; subst x; auto. apply SubTerm_via with v f; auto. apply newVar_nVT with nil (u::f::nil) nil; subst x; auto.
  apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. subst x; eapply newVar_nVT; eauto. apply SubTerm_via with v f; auto. subst x; eapply newVar_nVT; eauto. apply nVT_SubTerm. intros C. apply SubTerm_or with (v:=v) (t:=u) (s:=f) in C; auto. destruct C; contradict H2; subst x; eapply newVar_nVT; eauto. Qed.
Hint Resolve Var_Eq_sym Var_Eq_trans Term_Eq_refl Term_Eq_sym Term_Eq_trans Var_Eq_SubTerm Term_Eq_SubTerm.

Theorem Term_Eq_Succ: forall t u l, Inf l (t==u) -> Inf l (Succ t==Succ u). Proof. intros. apply Term_Eq_SubTerm with t u 0 (Succ (#0)); auto; unfold Succ; apply ST_Func; auto. Qed.
Theorem Term_Eq_Succ_inv: forall t u l, Inf l (Succ t==Succ u) -> Inf l (t==u). Proof. intros. apply IMP with (Succ t==Succ u) nil l; auto. remember (newVar nil (t::nil) nil) as v. apply Ui with (Succ t==Succ (#v)==>t==(#v)) v u. apply Ug; auto. apply Ui with (Succ (#S v)==Succ (#v)==>#S v==#v) (S v) t; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C. inversion C. apply In_one in H4. subst t0. contradict H3. subst v; eapply newVar_nVT; eauto. unfold Succ; auto. apply nVT_SubTerm. subst v; eapply newVar_nVT; eauto. Qed.
Theorem Neq_sym: forall t u l, Inf l (t!=u) -> Inf l (u!=t). Proof. intros. apply Contra with (t==u); auto. Qed.
Hint Resolve Term_Eq_Succ Term_Eq_Succ_inv Neq_sym.

(* convert nat to Term *)
Fixpoint n2t (i:nat) : Term := match i with 0 => Zero |S i'=>Succ (n2t i') end.
Theorem n2t_neq: forall i j l, i<>j -> Inf l (n2t i != n2t j). Proof. induction i; intros. simpl. destruct j. contradict H; auto. simpl. apply Ui with (Zero!=Succ (#0)) 0 (n2t j). apply Inf_incl with nil; auto. apply TFFSub_Neg. apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C; inversion C. destruct H4. apply ST_Func; auto. destruct j. simpl. apply Ui with (Succ (#0)!=Zero) 0 (n2t i); auto. apply TFFSub_Neg. apply TFFSub_Eq; auto. apply ST_Func; auto. apply nVT_SubTerm. intros C; inversion C. destruct H4. simpl. apply Contra with (n2t i==n2t j). apply IMp with (Succ (n2t i)==Succ (n2t j)); auto. apply Inf_incl'. apply IHi. contradict H; auto. Qed.

(* fun y x=>f(x,y) *)
Definition FSwap (f:Func) : Func := FComp f (FProj 1::FProj 0::nil).
Definition FPlus : Func := FRecu (FProj 0) (FComp FSucc (FProj 0::nil)).
Definition FPred: Func := FRecu FZero (FProj 1).
Definition FMinus: Func := FSwap (FRecu (FProj 0) (FComp FPred (FProj 0::nil))).
Definition FMult : Func := FRecu (FComp FZero nil) (FComp FPlus (FProj 0::FProj 2::nil)).
(* If input is 0, then output is 0, otherwise output is 1 *)
Definition FSign : Func := FRecu (FComp FZero nil) (FComp FSucc (FComp FZero nil::nil)).

Theorem FSwap_WFF: forall f, WFFunc 2 f -> WFFunc 2 (FSwap f). Proof. intros. apply WFF_Comp; auto. apply Forall_forall. intros. destruct H0. subst x; auto. destruct H0. subst x; auto. destruct H0. Qed.
Theorem FPlus_WFF: WFFunc 2 FPlus. Proof. apply WFF_Recu; auto. apply WFF_Comp; auto. Qed.
Theorem FPred_WFF: WFFunc 1 FPred. Proof. apply WFF_Recu; auto. Qed. 
Theorem FMinus_WFF: WFFunc 2 FMinus. Proof. apply FSwap_WFF. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FPred_WFF. Qed.
Theorem FMult_WFF: WFFunc 2 FMult. Proof. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FPlus_WFF. Qed.
Theorem FSign_WFF: WFFunc 1 FSign. Proof. apply WFF_Recu; auto. Qed.
Hint Resolve FSwap FPlus FPred FMinus FMult FSwap_WFF FPlus_WFF FPred_WFF FMinus_WFF FMult_WFF FSign_WFF.

Theorem Zero_WFT: WFTerm Zero. Proof. intros. unfold Zero; auto. Qed.
Theorem Succ_WFT: forall t, WFTerm t->WFTerm (Succ t). Proof. intros. unfold Succ; auto. Qed.
Hint Resolve Zero_WFT Succ_WFT.

Theorem n2t_nVT: forall i v, ~VarTerm v (n2t i). Proof. induction i; simpl; intros; intros C; inversion C. destruct H3. apply In_one in H3. subst t. contradict H2; auto. Qed.
Hint Resolve n2t_nVT.

Theorem SubTerm_Zero: forall v t, SubTerm v t Zero Zero. Proof. intros. apply ST_Func; auto. Qed.
Theorem SubTerm_Succ: forall v t s u, SubTerm v t s u -> SubTerm v t (Succ s) (Succ u). Proof. intros. apply ST_Func. auto. Qed.
Hint Resolve SubTerm_Zero SubTerm_Succ.

Theorem firstn_S: forall {T:Type} i (l:list T) (d:T), i<length l -> firstn (S i) l = firstn i l++nth i l d::nil. Proof. induction i; simpl; intros. destruct l; auto. destruct l; auto. inversion H. simpl. f_equal. apply IHi. simpl in H. apply le_S_n; auto. Qed.
Theorem MapR_refl: forall {T:Type} (R:T->T->Prop) (l:list T), (forall x, In x l -> R x x) -> MapR R l l. Proof. induction l; intros; auto. Qed.
Theorem plus_reg_r: forall p n m, n+p=m+p -> n=m. Proof. intros. rewrite plus_comm in H. symmetry in H. rewrite plus_comm in H. apply plus_reg_l in H. auto. Qed.
Theorem Imps_imply: forall p l c, Inf p (Imps l c) -> (forall f, In f l->Inf p f) -> Inf p c. Proof. induction l; intros. auto. simpl in H. apply IHl. apply IMp with a; auto. intros. apply H0. right; auto. Qed.
Theorem MapR_combine: forall {T U:Type} (R:T->U->Prop) l m, MapR R l m -> forall x y, In (x,y) (combine l m) -> R x y. Proof. induction l; intros. inversion H0. inversion H. subst a0 l0 m. simpl in H0. destruct H0. inversion H0; subst a b; auto. apply IHl with m0; auto. Qed.
Theorem TFFSub_Imps: forall v t l1 c1 l2 c2, MapR (TFFSub v t) l1 l2 -> TFFSub v t c1 c2 -> TFFSub v t (Imps l1 c1) (Imps l2 c2). Proof. induction l1; intros. inversion H. simpl; auto. inversion H. subst a0 l1 l2. simpl. apply TFFSub_Imp; auto. Qed.
Theorem MapR_map: forall {T U V:Type} (f:T->U) (g:T->V) l (R:U->V->Prop), (forall x, In x l-> R (f x) (g x)) -> MapR R (map f l) (map g l). Proof. induction l; intros; simpl; auto. Qed.
Theorem MapR_map2: forall {T1 T2 U1 U2:Type} (R:T2->U2->Prop) (f:T1->T2) (g:U1->U2) l m, MapR (fun x y=>R (f x) (g y)) l m -> MapR R (map f l) (map g m). Proof. induction l; simpl; intros. inversion H; simpl; auto. inversion H; simpl; auto. Qed. 
Theorem combine_app: forall {T U:Type} (l1 l2:list T) (m1 m2:list U), length l1=length m1 -> combine (l1++l2) (m1++m2) = combine l1 m1++combine l2 m2. Proof. induction l1; intros. destruct m1. auto. inversion H. destruct m1. inversion H. simpl. f_equal. apply IHl1. inversion H; auto. Qed.
Theorem skipn_S: forall {T:Type} (l:list T) n t, n<length l -> skipn n l=nth n l t::skipn (S n) l. Proof. induction l; intros. inversion H. destruct n. simpl; auto. simpl. apply IHl. apply le_S_n; auto. Qed.
Theorem combine_cons: forall {T U:Type} (a:T) (b:U) l m, combine (a::l) (b::m) = (a,b)::combine l m. Proof. intros. auto. Qed.

Theorem FProj_spec: forall i t args l, i<length args -> nth i args Zero = t -> Inf l (FuncT (FProj i) args==t). Proof. intros. apply Inf_incl with nil; auto. clear l. remember (newVar nil args nil) as v. assert (forall a i, v<=i->In a args->~VarTerm i a). intros. subst v. apply newVar_nVT with nil args nil; auto. clear Heqv. cut (forall j, j<=length args->Inf nil (FuncT (FProj i) (firstn j args++map Var (seq (j+v) (length args-j))) == if (le_dec j i) then #i+v else t)). intros. replace t with (if le_dec (length args) i then #i+v else t). replace args with (firstn (length args) args++map Var (seq (length args+v) (length args-length args))) at 1. apply H2; auto. rewrite firstn_all. rewrite <- minus_n_n. simpl. rewrite app_nil_r; auto. destruct (le_dec (length args) i); auto. contradict H; auto.  induction j; intros. simpl. rewrite <- minus_n_O; auto.
  assert (j<=length args). apply lt_le_weak; auto. apply IHj in H3. clear IHj. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. replace (length args - j) with (S(length args - S j)) in H3. rewrite <- cons_seq in H3. simpl in H3. apply Ui with (FuncT (FProj i) (firstn j args++(#j+v)::map Var (seq (S (j+v)) (length args-S j))) == (if le_dec j i then #i+v else t)) (j+v) (nth j args Zero). apply Ug; auto. apply TFFSub_Eq. apply ST_Func. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H1. apply le_plus_r. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. apply MapR_cons. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H4. destruct H4 as [y [H4 H5]]. subst x. apply in_seq in H5. intros C. inversion C. subst i0 y. destruct H5. contradict H4; auto. auto.
  destruct (le_dec (S j) i); destruct (le_dec j i). apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H6. subst j. contradict l; auto. contradict n; auto. assert (j=i). apply le_antisym; auto. destruct (le_lt_dec i j); auto. contradiction. subst j. rewrite H0; auto. apply nVT_SubTerm. apply H1. apply le_plus_r. subst t. apply nth_In; auto. rewrite minus_Sn_m; auto. Qed.
Theorem FComp_spec: forall n f fs args ts l, WFFunc n (FComp f fs) -> length args = n -> MapR (fun f t=> Inf l (t==FuncT f args)) fs ts -> Inf l (FuncT (FComp f fs) args == FuncT f ts). Proof. intros. assert (Hf:length fs=length ts). apply MapR_length in H1; auto. cut (Inf l (Imps (map (fun p=>snd p==FuncT (fst p) args) (combine fs ts)) (FuncT (FComp f fs) args == FuncT f ts))). intros. eapply Imps_imply. eapply H2. intros g Hg. apply in_map_iff in Hg. destruct Hg as [[g' t'] [H3 H4]]. simpl in H3. subst g. apply MapR_combine with (l0:=fs) (m:=ts) (x:=g') (y:=t'); auto. remember (newVar nil (ts++args) nil) as v. assert (forall i t, v<=i->In t args->~VarTerm i t). intros. subst v; apply newVar_nVT with nil (ts++args) nil; auto. apply in_or_app; auto. assert (forall i t, v<=i->In t ts->~VarTerm i t). intros. subst v; apply newVar_nVT with nil (ts++args) nil; auto. apply in_or_app; auto. apply Inf_incl with nil; auto. clear Heqv H1 l.
  cut (forall j, j<=n->Inf nil (Imps (map (fun p=>snd p==FuncT (fst p) (firstn j args++map Var (seq (j+v) (n-j)))) (combine fs ts)) (FuncT (FComp f fs) (firstn j args++map Var (seq (j+v) (n-j))) == FuncT f ts))). intros. replace args with (firstn n args++map Var (seq (n+v) (n-n))); auto. subst n. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O. simpl. 
  cut (forall j, j<=length ts-> Inf nil (Imps (map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (firstn j ts++map Var (seq (j+n+v) (length ts-j))))) (FuncT (FComp f fs) (map Var (seq v n))==FuncT f (firstn j ts++map Var (seq (j+n+v) (length ts-j)))))). intros. replace ts with (firstn (length ts) ts++map Var (seq (length ts+n+v) (length ts-length ts))); auto. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O. simpl. replace (map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (map Var (seq (n+v) (length ts))))) with (map (fun p=>#snd p+n+v==FuncT (fst p) (map Var (seq v n))) (with_idx fs)). rewrite <- Hf. auto. rewrite <- Hf. clear -fs. unfold with_idx. cut (forall i, map (fun p=>#snd p+n+v==FuncT (fst p) (map Var (seq v n))) (with_idx' fs i)=map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (map Var (seq (i+(n+v)) (length fs))))). intros; apply H. induction fs; simpl; intros; auto.
  f_equal; auto. f_equal. f_equal. rewrite plus_assoc; auto. apply IHfs. assert (j<=length ts). apply lt_le_weak; auto. apply IHj in H5. clear IHj. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc; auto. replace (length ts-j) with (S(length ts-S j)) in H5. rewrite <- cons_seq in H5. simpl in H5. eapply Ui with (v:=j+n+v) (t:=nth j ts Zero). apply Ug. eapply H5. auto. apply TFFSub_Imps. simpl. apply MapR_map2. rewrite <- firstn_skipn with Func j fs. repeat rewrite combine_app. apply MapR_app. apply MapR_refl. intros. destruct x as [g t]. assert (In t ts). apply in_combine_r in H6. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. simpl. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H8. destruct H8 as [y [H8 H9]]. subst x. apply in_seq in H9. destruct H9. contradict H9; inversion H9. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. rewrite skipn_S with (n0:=j) (l:=fs) (t:=FZero); auto. repeat rewrite combine_cons.
  apply MapR_cons; auto. apply MapR_refl. intros. destruct x as [g t]. apply in_combine_r in H6. simpl. apply TFFSub_Eq. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst t. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H7. destruct H7 as [y [H7 H8]]. subst x. apply in_seq in H8. destruct H8. contradict H8. inversion H8. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. simpl. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H7. inversion H7. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. rewrite Hf; auto. repeat rewrite firstn_length. rewrite Hf; auto. repeat rewrite firstn_length. rewrite Hf; auto.
  apply TFFSub_Eq. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H7. inversion H7. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. apply ST_Func. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H3; auto. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. apply MapR_cons. apply MapR_refl. intros. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. auto. rewrite minus_Sn_m; auto.
  assert (forall x, In x (firstn j args)->In x args). intros. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. rewrite firstn_S with (d:=Zero). rewrite <- app_assoc. simpl. assert (j<=n). apply lt_le_weak; auto. apply IHj in H5. clear IHj. replace (n-j) with (S(n-S j)) in H5. rewrite <- cons_seq in H5. simpl in H5. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H5. auto. apply TFFSub_Imps. apply MapR_map. intros. destruct x as [g t]. simpl. assert (In g fs). apply in_combine_l in H6; auto. assert (In t ts). apply in_combine_r in H6; auto. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_app. apply MapR_refl. intros; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H9. destruct H9 as [y [H9 H10]]. subst x. apply in_seq in H10. destruct H10. contradict H9; inversion H9; auto. apply TFFSub_Eq. apply ST_Func. apply MapR_app; auto. apply MapR_refl. intros; auto. apply MapR_cons; auto.
  apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6; inversion H6; auto. apply nVT_SubTerm. intros C. inversion C. contradict H9. auto. rewrite minus_Sn_m; auto. subst n; auto. Qed.
Theorem FRecu_Zero_spec: forall f g args l, WFFunc (S (length args)) (FRecu f g) -> Inf l (FuncT (FRecu f g) (Zero::args) == FuncT f args). Proof. intros. revert H. intros Hf. remember (newVar nil args nil) as v. assert (forall i a, v<=i->In a args->~VarTerm i a). intros. subst v. apply newVar_nVT with nil args nil; auto. clear Heqv. apply Inf_incl with nil; auto. cut (forall j, j<=length args->Inf nil (FuncT (FRecu f g) (Zero::firstn j args++map Var (seq (j+v) (length args-j)))==FuncT f (firstn j args++map Var (seq (j+v) (length args-j))))). intros. replace args with (firstn (length args) args++map Var (seq (length args+v) (length args-length args))). apply H0; auto. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r. auto. induction j. intros. simpl. rewrite <- minus_n_O; auto.
  intros. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. assert (j<=length args). apply lt_le_weak; auto. apply IHj in H1. clear IHj. replace (length args -j) with (S(length args - S j)) in H1. rewrite <- cons_seq in H1. simpl in H1. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H1. auto. apply TFFSub_Eq; apply ST_Func. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H. apply le_plus_r. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H2. destruct H2 as [y [H3 H4]]. subst x. apply in_seq in H4. destruct H4. contradict H2. inversion H2. subst i y. auto. apply nVT_SubTerm. intros C. inversion C. destruct H6. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H. apply le_plus_r. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto.
  apply MapR_cons. apply MapR_refl. intros. apply in_map_iff in H2. destruct H2 as [y [H3 H4]]. subst x. apply in_seq in H4. destruct H4. apply nVT_SubTerm. contradict H2. inversion H2. subst i y; auto. auto. rewrite minus_Sn_m; auto. Qed.
Theorem FRecu_Succ_spec: forall f g args ti ty l, WFFunc (S (length args)) (FRecu f g) -> Inf l (FuncT (FRecu f g) (ti::args) == ty) -> Inf l (FuncT (FRecu f g) (Succ ti::args) == FuncT g (ty::ti::args)). Proof. intros. remember (newVar nil (ti::ty::args) nil) as v. assert (forall i a, v<=i->In a args->~VarTerm i a). intros. eapply newVar_nVT. subst v; eauto. right; right; auto. assert (forall i, v<=i->~VarTerm i ti). intros. subst v. eapply newVar_nVT; eauto. assert (forall i, v<=i->~VarTerm i ty). intros. subst v. eapply newVar_nVT; eauto. apply IMP with (FuncT (FRecu f g) (ti::args)==ty) nil l; auto. clear H0 Heqv l. remember (length args) as n. apply Ui with (FuncT (FRecu f g) ((#n+v)::args) == ty ==> FuncT (FRecu f g) (Succ (#n+v)::args) == FuncT g (ty::(#n+v)::args)) (n+v) ti. apply Ug; auto. apply Ui with (FuncT (FRecu f g) ((#n+v)::args) == (#S(n+v)) ==> FuncT (FRecu f g) (Succ (#n+v)::args) == FuncT g ((#S(n+v))::(#n+v)::args)) (S(n+v)) ty. apply Ug; auto.
  cut (forall j, j<=n->Inf nil (FuncT (FRecu f g) ((#n+v)::firstn j args++map Var (seq (j+v) (n-j))) == #S(n+v)==>FuncT (FRecu f g) (Succ (#n+v)::firstn j args++map Var (seq (j+v) (n-j)))==FuncT g ((#S(n+v))::(#n+v)::firstn j args++map Var (seq (j+v) (n-j))))). intros. replace args with (firstn n args++map Var (seq (n+v) (n-n))); auto. subst n. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O; simpl; auto. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. assert (j<=n). apply lt_le_weak; auto. apply IHj in H4. replace (n-j) with (S(n-S j)) in H4. rewrite <- cons_seq in H4. simpl in H4. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H4. auto.
  assert (forall x, In x (firstn j args)->In x args). intros. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. apply TFFSub_Imp; apply TFFSub_Eq; try apply ST_Func; auto. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H1; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6. inversion H6. auto. apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j. contradict H0; auto. apply nVT_SubTerm. intros C; inversion C. absurd (j+v<n+v). apply le_not_lt. rewrite H8; auto. apply plus_lt_compat_r; auto. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6. inversion H6. auto. apply SubTerm_Succ.
  apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j; contradict H0; auto. apply MapR_cons. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. auto. apply MapR_cons; auto. apply MapR_refl. intros. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j; contradict H0; auto. apply nVT_SubTerm. intros C; inversion C. absurd (j+v<n+v). apply le_not_lt. rewrite H8; auto. apply plus_lt_compat_r; auto. rewrite minus_Sn_m; auto. subst n; auto. 
  apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C; contradict H5; auto. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C. apply In_one in H7; subst t. inversion H6. contradict H9; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C. contradict H5; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func; try repeat apply MapR_cons; auto; apply MapR_refl; intros; apply nVT_SubTerm; apply H1; auto. Qed.
Hint Resolve FProj_spec FComp_spec FRecu_Zero_spec FRecu_Succ_spec.

Theorem FPlus_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FPlus (t::u::nil) == n2t (i+j)). Proof. intros. remember (newVar nil (u::t::nil) nil) as v. assert (~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FPlus (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FPlus ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FPlus (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FPlus (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. clear l H H0 Heqv. induction i. simpl. apply Term_Eq_trans with (FuncT (FProj 0) (n2t j::nil)). apply FRecu_Zero_spec; auto. apply FProj_spec; auto.
  simpl. apply Term_Eq_trans with (FuncT (FComp FSucc (FProj 0::nil)) (n2t(i+j)::n2t i::n2t j::nil)). apply FRecu_Succ_spec; auto. apply FComp_spec with (n:=3); auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply Term_Eq_sym. apply FProj_spec; simpl; auto. Qed.
Theorem FMult_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FMult (t::u::nil) == n2t (i*j)). Proof. intros. remember (newVar nil (u::t::nil) nil) as v. assert (~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FMult (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FMult ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FMult (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FMult (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. clear l H H0 Heqv. induction i. simpl. apply Term_Eq_trans with (FuncT (FComp FZero nil) (n2t j::nil)). apply FRecu_Zero_spec; auto. apply FComp_spec with 1; auto. simpl. apply Term_Eq_trans with (FuncT (FComp FPlus (FProj 0::FProj 2::nil)) (n2t(i*j)::n2t i::n2t j::nil)). apply FRecu_Succ_spec; auto. apply Term_Eq_trans with (FuncT FPlus (n2t (i*j)::n2t j::nil)). apply FComp_spec with (n:=3); auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply Term_Eq_sym; auto. apply FProj_spec; simpl; auto.
  rewrite plus_comm. apply FPlus_spec; auto. Qed.

