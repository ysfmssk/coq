Require Import Arith.
Require Import List.
Require Import Relations.
Require Import Wellfounded.
Require Import list_util.
Require Import ModEq.
Require Import Peano_LQ.

Set Implicit Arguments.

Hint Resolve le_plus_r le_plus_l in_or_app.

Theorem Var_Eq_sym: forall x y l, Inf l (#x==#y) -> Inf l (#y==#x). Proof. intros. apply IMp with (#x==#x); auto. apply IMp with (#x==#y); auto. apply IAx. apply PAE2 with (S(max x y)) (#S(max x y)) (#x); auto; apply nVT_SubTerm; intros C; apply VT_var in C; absurd (x<x); auto; rewrite <- C at 2; auto. Qed.
Theorem Var_Eq_trans: forall x y z l, Inf l (#x==#y) -> Inf l (#y==#z) -> Inf l (#x==#z). Proof. intros. apply IMp with (#y==#z); auto. apply IMp with (#y==#x); [|apply Var_Eq_sym]; auto. apply IAx. apply PAE2 with (S z) (#S z) (#z); auto; apply nVT_SubTerm; intros C; apply VT_var in C. Qed.
Theorem Term_Eq_refl: forall t l, Inf l (t==t). Proof. intros. apply Inf_incl with nil; auto. apply Ui with (#0==#0) 0 t; auto. Qed.
Theorem Term_Eq_sym: forall t u l, Inf l (t==u) -> Inf l (u==t). Proof. intros. apply IMP with (t==u) nil l; auto. remember (newVar nil (u::nil) nil) as v. apply Ui with (#v==u==>u==#v) v t; auto. apply Ug; auto. apply Ui with (#v==#S v==>#S v==#v) (S v) u; auto. apply Ug; auto. apply Ded. apply Var_Eq_sym; auto. subst v. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; eapply newVar_nVT; eauto. Qed.
Theorem Term_Eq_trans: forall s t u l, Inf l (s==t) -> Inf l (t==u) -> Inf l (s==u). Proof. intros. apply IMp with (t==u); auto. apply IMP with (s==t) nil l; auto. remember (newVar nil (s::t::u::nil) nil) as v. apply Ui with (s==t==>t==(#v)==>s==(#v)) v u; auto. apply Ug; auto. apply Ui with (s==(#S v)==>(#S v)==(#v)==>s==(#v)) (S v) t; auto. apply Ug; auto. apply Ui with (#S (S v)==#S v==>#S v==#v==>#S (S v)==#v) (S(S v)) s; auto. apply Ug; auto. apply Ded. apply Ded. apply Var_Eq_trans with (S v); auto. repeat apply TFFSub_Imp; auto; apply TFFSub_Eq; auto; apply nVT_SubTerm; intros C; inversion C; contradict H3; clear -v; induction v; auto. repeat apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; subst v; eapply newVar_nVT; eauto. repeat apply TFFSub_Imp; apply TFFSub_Eq; auto; apply nVT_SubTerm; subst v; eapply newVar_nVT; eauto. Qed.
Theorem Var_Eq_SubTerm: forall v x y t tx ty l, Inf l (#x==#y) -> SubTerm v (#x) t tx -> SubTerm v (#y) t ty -> Inf l (tx==ty). Proof. intros. remember (newVar (x::nil) (t::nil) nil) as z. destruct (subTerm_sig v (#z) t) as [t' H2 H3]. assert (Hz:~VarTerm z t). subst z; eapply newVar_nVT; eauto. assert (SubTerm z (#x) t' tx). apply SubTerm_via with v t; auto. assert (SubTerm z (#y) t' ty). apply SubTerm_via with v t; auto. apply IMp with (tx==tx). apply IMp with (#x==#y); auto. apply IAx. apply PAE2 with z tx t'; auto; apply nVT_SubTerm; apply SubTerm_nVT2 with v (#x) t; auto; intros C; apply VT_var in C; subst z; absurd (In x (x::nil)); auto; rewrite <-C at 1; eapply newVar_nVar; eauto. apply Term_Eq_refl. Qed.
Theorem Term_Eq_SubTerm: forall t u l v f ft fu, Inf l (t==u) -> SubTerm v t f ft -> SubTerm v u f fu -> Inf l (ft==fu). Proof. intros. apply IMP with (t==u) nil l; auto. remember (newVar nil (u::f::nil) nil) as x. apply Ui with (#x==u==>subTerm v (#x) f==fu) x t. apply Ug; auto. apply Ui with (#x==#S x==>subTerm v (#x) f==subTerm v (#S x) f) (S x) u; auto. apply Ug; auto. apply Ded. apply Var_Eq_SubTerm with v x (S x) f; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C. apply SubTerm_or with (v:=v) (s:=f) (t:=#x) in C; auto. destruct C. inversion H2. contradict H5; auto. contradict H2. apply newVar_nVT with nil (u::f::nil) nil; subst x; auto. apply SubTerm_via with v f; auto. apply newVar_nVT with nil (u::f::nil) nil; subst x; auto.
  apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. subst x; eapply newVar_nVT; eauto. apply SubTerm_via with v f; auto. subst x; eapply newVar_nVT; eauto. apply nVT_SubTerm. intros C. apply SubTerm_or with (v:=v) (t:=u) (s:=f) in C; auto. destruct C; contradict H2; subst x; eapply newVar_nVT; eauto. Qed.
Hint Resolve Var_Eq_sym Var_Eq_trans Term_Eq_refl Term_Eq_sym Term_Eq_trans Var_Eq_SubTerm Term_Eq_SubTerm.

Theorem Term_Eq_Succ: forall t u l, Inf l (t==u) -> Inf l (Succ t==Succ u). Proof. intros. apply Term_Eq_SubTerm with t u 0 (Succ (#0)); auto; unfold Succ; apply ST_Func; auto. Qed.
Theorem Term_Eq_Succ_inv: forall t u l, Inf l (Succ t==Succ u) -> Inf l (t==u). Proof. intros. apply IMP with (Succ t==Succ u) nil l; auto. remember (newVar nil (t::nil) nil) as v. apply Ui with (Succ t==Succ (#v)==>t==(#v)) v u. apply Ug; auto. apply Ui with (Succ (#S v)==Succ (#v)==>#S v==#v) (S v) t; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C. inversion C. apply In_one in H4. subst t0. contradict H3. subst v; eapply newVar_nVT; eauto. unfold Succ; auto. apply nVT_SubTerm. subst v; eapply newVar_nVT; eauto. Qed.
Theorem Neq_sym: forall t u l, Inf l (t!=u) -> Inf l (u!=t). Proof. intros. apply Contra with (t==u); auto. Qed.
Theorem Term_Eq_args: forall f ts us l, MapR (fun x y=>Inf l (x==y)) ts us -> Inf l (FuncT f ts==FuncT f us). Proof. intros. remember (length ts) as a. assert (Heqb:a = length us). subst a. apply MapR_length in H; auto. remember (newVar nil (ts++us) l) as v. assert (forall i t, v<=i->In t ts->~VarTerm i t). intros. apply newVar_nVT with nil (ts++us) l; subst v; auto; apply in_or_app; auto. assert (forall i t, v<=i->In t us->~VarTerm i t). intros. apply newVar_nVT with nil (ts++us) l; subst v; auto; apply in_or_app; auto. cut (forall j, j<=a -> Inf l (FuncT f (firstn j ts++map Var (seq (j+v) (a-j)))==FuncT f (firstn j us++map Var (seq (j+v) (a-j))))). intros. assert (a<=a); auto. apply H2 in H3. rewrite <- minus_n_n in H3. simpl in H3. rewrite Heqa in H3 at 1. rewrite Heqb in H3. repeat rewrite firstn_all in H3. repeat rewrite app_nil_r in H3; auto. induction j; intros. simpl. auto. assert (j<=a); auto. apply IHj in H3. clear IHj. repeat rewrite firstn_S with (d:=Zero); auto.
  replace (a-j) with (S(a-S j)) in H3. rewrite <- cons_seq in H3. simpl in H3. repeat rewrite <- app_assoc. simpl. assert (Ha:forall t, MapR (SubTerm (j + v) t) (firstn j ts) (firstn j ts)). intros. apply MapR_refl. intros. apply nVT_SubTerm. apply H0; auto. rewrite <- firstn_skipn with (n:=j); auto. assert (Hb:forall t, MapR (SubTerm (j + v) t) (firstn j us) (firstn j us)). intros. apply MapR_refl. intros. apply nVT_SubTerm. apply H1; auto. rewrite <- firstn_skipn with (n:=j); auto. assert (Hc:forall t, MapR (SubTerm (j + v) t) (map Var (seq (S (j + v)) (a - S j))) (map Var (seq (S (j + v)) (a - S j)))). intros. apply MapR_refl. intros. apply in_map_iff in H4. destruct H4 as [y [H4 H5]]. subst x. apply in_seq in H5. destruct H5. apply nVT_SubTerm. contradict H4; inversion H4; auto.
  apply Term_Eq_trans with (FuncT f ((firstn j ts++nth j us Zero::map Var (seq (S (j+v)) (a-S j))))). apply Term_Eq_SubTerm with (v:=j+v) (t:=nth j ts Zero) (u:=nth j us Zero) (f:=FuncT f ((firstn j ts++(#j+v)::map Var (seq (S (j+v)) (a-S j))))). apply MapR_nth with (i:=j) (dt:=Zero) (du:=Zero) in H; auto. rewrite <- Heqa; auto. apply ST_Func. apply MapR_app; auto. apply ST_Func. apply MapR_app; auto. eapply Ui with (v:=j+v) (t:=nth j us Zero). eapply Ug. eapply H3. intros. intros C. apply FreeVar__VarFormula in C. contradict C. apply newVar_nVF with nil (ts++us) l; auto. rewrite <- Heqv; auto. apply TFFSub_Eq; apply ST_Func; apply MapR_app; auto. rewrite minus_Sn_m; auto. rewrite <- Heqb; auto. rewrite <- Heqa; auto. Qed.
Hint Resolve Term_Eq_Succ Term_Eq_Succ_inv Neq_sym.

(* convert nat to Term *)
Fixpoint n2t (i:nat) : Term := match i with 0 => Zero |S i'=>Succ (n2t i') end.
Theorem n2t_neq: forall i j l, i<>j -> Inf l (n2t i != n2t j). Proof. induction i; intros. simpl. destruct j. contradict H; auto. simpl. apply Ui with (Zero!=Succ (#0)) 0 (n2t j). apply Inf_incl with nil; auto. apply TFFSub_Neg. apply TFFSub_Eq; auto. apply nVT_SubTerm. intros C; inversion C. destruct H4. apply ST_Func; auto. destruct j. simpl. apply Ui with (Succ (#0)!=Zero) 0 (n2t i); auto. apply TFFSub_Neg. apply TFFSub_Eq; auto. apply ST_Func; auto. apply nVT_SubTerm. intros C; inversion C. destruct H4. simpl. apply Contra with (n2t i==n2t j). apply IMp with (Succ (n2t i)==Succ (n2t j)); auto. apply Inf_incl'. apply IHi. contradict H; auto. Qed.

(* fun y x=>f(x,y) *)
Definition FSwap (f:Func) : Func := FComp f (FProj 1::FProj 0::nil).
Definition FPlus : Func := FRecu (FProj 0) (FComp FSucc (FProj 0::nil)).
Definition FPred: Func := FRecu FZero (FProj 1).
Definition FMinus: Func := FSwap (FRecu (FProj 0) (FComp FPred (FProj 0::nil))).
Definition FMult : Func := FRecu (FComp FZero nil) (FComp FPlus (FProj 0::FProj 2::nil)).
Definition FPow : Func := FSwap (FRecu (FComp FSucc (FComp FZero nil::nil)) (FComp FMult (FProj 0::FProj 2::nil))).
Definition FMax : Func := FComp FPlus (FMinus::FProj 1::nil).
Definition FMin : Func := FComp FMinus (FProj 0::FMinus::nil).
Definition FAbs : Func := FComp FPlus (FMinus::FSwap FMinus::nil).
(* Predicate functions *)
(* If input is 0, then output is 0, otherwise output is 1 *)
Definition FSign : Func := FRecu FZero (FComp FSucc (FComp FZero nil::nil)).
(* If input is 0, then outout is 1, otherwise output is 0 *)
Definition FNeg : Func := FRecu (FComp FSucc (FZero::nil)) (FComp FZero nil).
Definition FEq: Func := FComp FNeg (FAbs::nil).
Definition FNEq: Func := FComp FNeg (FEq::nil).
Definition FLe : Func := FComp FNeg (FMinus::nil).
(* Logical functions *)
Definition FLand : Func := FComp FSign (FMult::nil).
Definition FLor : Func := FComp FSign (FPlus::nil).
(* If exists x<z, f x <> 0, then output is 1, otherwise 0 *)
Definition FEx n f : Func := FRecu (FComp FZero nil) (FComp FLor (FProj 0::(FComp f (FProj 1::map FProj (seq 2 n))::nil))).

(* Remain (in case of 0 div, Remain x 0 = x) *)
Definition FRem : Func := FRecu (FComp FZero nil) (FComp FMult ((FComp FSucc (FProj 0::nil))::(FComp FNEq (FProj 2::FComp FSucc (FProj 0::nil)::nil))::nil)).

Theorem FSwap_WFF: forall f, WFFunc 2 f -> WFFunc 2 (FSwap f). Proof. intros. apply WFF_Comp; auto. apply Forall_forall. intros. destruct H0. subst x; auto. destruct H0. subst x; auto. destruct H0. Qed.
Theorem FPlus_WFF: WFFunc 2 FPlus. Proof. apply WFF_Recu; auto. apply WFF_Comp; auto. Qed.
Theorem FPred_WFF: WFFunc 1 FPred. Proof. apply WFF_Recu; auto. Qed. 
Theorem FMinus_WFF: WFFunc 2 FMinus. Proof. apply FSwap_WFF. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FPred_WFF. Qed.
Theorem FMult_WFF: WFFunc 2 FMult. Proof. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FPlus_WFF. Qed.
Theorem FPow_WFF: WFFunc 2 FPow. Proof. apply FSwap_WFF. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FMult_WFF. Qed. 
Hint Resolve FSwap FPlus FPred FMinus FMult FSwap_WFF FPlus_WFF FPred_WFF FMinus_WFF FMult_WFF FPow_WFF.
Theorem FMax_WFF: WFFunc 2 FMax. Proof. apply WFF_Comp; auto. Qed.
Theorem FMin_WFF: WFFunc 2 FMin. Proof. apply WFF_Comp; auto. Qed.
Theorem FAbs_WFF: WFFunc 2 FAbs. Proof. apply WFF_Comp; auto. Qed.
Theorem FSign_WFF: WFFunc 1 FSign. Proof. apply WFF_Recu; auto. Qed.
Theorem FNeg_WFF: WFFunc 1 FNeg. Proof. apply WFF_Recu; auto. Qed.
Theorem FEq_WFF: WFFunc 2 FEq. Proof. apply WFF_Comp; auto. apply FNeg_WFF. apply Forall_cons; auto. apply FAbs_WFF. Qed.
Theorem FNEq_WFF: WFFunc 2 FNEq. Proof. apply WFF_Comp; auto. apply FNeg_WFF. apply Forall_cons; auto. apply FEq_WFF. Qed.
Theorem FLe_WFF: WFFunc 2 FLe. Proof. apply WFF_Comp. apply FNeg_WFF. apply Forall_cons; auto. Qed.
Theorem FLand_WFF: WFFunc 2 FLand. Proof. apply WFF_Comp; auto. apply FSign_WFF. Qed.
Theorem FLor_WFF: WFFunc 2 FLor. Proof. apply WFF_Comp; auto. apply FSign_WFF. Qed.
Theorem FEx_WFF: forall n f, WFFunc (S n) f -> WFFunc (S n) (FEx n f). Proof. intros. apply WFF_Recu; auto. apply WFF_Comp. apply FLor_WFF. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; simpl; auto. rewrite map_length. rewrite seq_length; auto. apply Forall_cons; auto. apply Forall_forall. intros. apply in_map_iff in H0. destruct H0 as [y [H1 H2]]. subst x. apply in_seq in H2. destruct H2. apply WFF_Proj. auto. Qed.
Theorem FRem_WFF: WFFunc 2 FRem. Proof. intros. apply WFF_Recu; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply FNEq_WFF. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; auto. Qed.
Hint Resolve FMax_WFF FMin_WFF FAbs_WFF FSign_WFF FNeg_WFF FEq_WFF FNEq_WFF FLe_WFF FLand_WFF FLor_WFF FEx_WFF FRem_WFF.

Theorem Zero_WFT: WFTerm Zero. Proof. intros. unfold Zero; auto. Qed.
Theorem Succ_WFT: forall t, WFTerm t->WFTerm (Succ t). Proof. intros. unfold Succ; auto. Qed.
Hint Resolve Zero_WFT Succ_WFT.

Theorem n2t_nVT: forall i v, ~VarTerm v (n2t i). Proof. induction i; simpl; intros; intros C; inversion C. destruct H3. apply In_one in H3. subst t. contradict H2; auto. Qed.
Hint Resolve n2t_nVT.

Theorem SubTerm_Zero: forall v t, SubTerm v t Zero Zero. Proof. intros. apply ST_Func; auto. Qed.
Theorem SubTerm_Succ: forall v t s u, SubTerm v t s u -> SubTerm v t (Succ s) (Succ u). Proof. intros. apply ST_Func. auto. Qed.
Hint Resolve SubTerm_Zero SubTerm_Succ.

Theorem FProj_spec: forall i t args l, i<length args -> nth i args Zero = t -> Inf l (FuncT (FProj i) args==t). Proof. intros. apply Inf_incl with nil; auto. clear l. remember (newVar nil args nil) as v. assert (forall a i, v<=i->In a args->~VarTerm i a). intros. subst v. apply newVar_nVT with nil args nil; auto. clear Heqv. cut (forall j, j<=length args->Inf nil (FuncT (FProj i) (firstn j args++map Var (seq (j+v) (length args-j))) == if (le_dec j i) then #i+v else t)). intros. replace t with (if le_dec (length args) i then #i+v else t). replace args with (firstn (length args) args++map Var (seq (length args+v) (length args-length args))) at 1. apply H2; auto. rewrite firstn_all. rewrite <- minus_n_n. simpl. rewrite app_nil_r; auto. destruct (le_dec (length args) i); auto. contradict H; auto.  induction j; intros. simpl. rewrite <- minus_n_O; auto.
  assert (j<=length args). apply lt_le_weak; auto. apply IHj in H3. clear IHj. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. replace (length args - j) with (S(length args - S j)) in H3. rewrite <- cons_seq in H3. simpl in H3. apply Ui with (FuncT (FProj i) (firstn j args++(#j+v)::map Var (seq (S (j+v)) (length args-S j))) == (if le_dec j i then #i+v else t)) (j+v) (nth j args Zero). apply Ug; auto. apply TFFSub_Eq. apply ST_Func. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H1. apply le_plus_r. rewrite <- firstn_skipn with (n:=j); auto. apply MapR_cons. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H4. destruct H4 as [y [H4 H5]]. subst x. apply in_seq in H5. intros C. inversion C. subst i0 y. destruct H5. contradict H4; auto. auto.
  destruct (le_dec (S j) i); destruct (le_dec j i). apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H6. subst j. contradict l; auto. contradict n; auto. assert (j=i). apply le_antisym; auto. destruct (le_lt_dec i j); auto. contradiction. subst j. rewrite H0; auto. apply nVT_SubTerm. apply H1. apply le_plus_r. subst t. apply nth_In; auto. rewrite minus_Sn_m; auto. Qed.
Theorem FComp_spec: forall n f fs args ts l, WFFunc n (FComp f fs) -> length args = n -> MapR (fun f t=> Inf l (FuncT f args==t)) fs ts -> Inf l (FuncT (FComp f fs) args == FuncT f ts). Proof. intros. assert (Hf:length fs=length ts). apply MapR_length in H1; auto. cut (Inf l (Imps (map (fun p=>snd p==FuncT (fst p) args) (combine fs ts)) (FuncT (FComp f fs) args == FuncT f ts))). intros. eapply Imps_imply. eapply H2. intros g Hg. apply in_map_iff in Hg. destruct Hg as [[g' t'] [H3 H4]]. simpl in H3. subst g. apply Term_Eq_sym. apply MapR_combine with (l:=fs) (m:=ts) (x:=g') (y:=t'); auto. remember (newVar nil (ts++args) nil) as v. assert (forall i t, v<=i->In t args->~VarTerm i t). intros. subst v; apply newVar_nVT with nil (ts++args) nil; auto. assert (forall i t, v<=i->In t ts->~VarTerm i t). intros. subst v; apply newVar_nVT with nil (ts++args) nil; auto. apply Inf_incl with nil; auto. clear Heqv H1 l.
  cut (forall j, j<=n->Inf nil (Imps (map (fun p=>snd p==FuncT (fst p) (firstn j args++map Var (seq (j+v) (n-j)))) (combine fs ts)) (FuncT (FComp f fs) (firstn j args++map Var (seq (j+v) (n-j))) == FuncT f ts))). intros. replace args with (firstn n args++map Var (seq (n+v) (n-n))); auto. subst n. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O. simpl. 
  cut (forall j, j<=length ts-> Inf nil (Imps (map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (firstn j ts++map Var (seq (j+n+v) (length ts-j))))) (FuncT (FComp f fs) (map Var (seq v n))==FuncT f (firstn j ts++map Var (seq (j+n+v) (length ts-j)))))). intros. replace ts with (firstn (length ts) ts++map Var (seq (length ts+n+v) (length ts-length ts))); auto. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O. simpl. replace (map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (map Var (seq (n+v) (length ts))))) with (map (fun p=>#snd p+n+v==FuncT (fst p) (map Var (seq v n))) (with_idx fs)). rewrite <- Hf. auto. rewrite <- Hf. clear -fs. unfold with_idx. cut (forall i, map (fun p=>#snd p+n+v==FuncT (fst p) (map Var (seq v n))) (with_idx' fs i)=map (fun p=>snd p==FuncT (fst p) (map Var (seq v n))) (combine fs (map Var (seq (i+(n+v)) (length fs))))). intros; apply H. induction fs; simpl; intros; auto.
  f_equal; auto. f_equal. f_equal. rewrite plus_assoc; auto. apply IHfs. assert (j<=length ts). apply lt_le_weak; auto. apply IHj in H5. clear IHj. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc; auto. replace (length ts-j) with (S(length ts-S j)) in H5. rewrite <- cons_seq in H5. simpl in H5. eapply Ui with (v:=j+n+v) (t:=nth j ts Zero). apply Ug. eapply H5. auto. apply TFFSub_Imps. simpl. apply MapR_map2. rewrite <- firstn_skipn with Func j fs. repeat rewrite combine_app. apply MapR_app. apply MapR_refl. intros. destruct x as [g t]. assert (In t ts). apply in_combine_r in H6. rewrite <- firstn_skipn with (n:=j); auto. simpl. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H8. destruct H8 as [y [H8 H9]]. subst x. apply in_seq in H9. destruct H9. contradict H9; inversion H9. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. rewrite skipn_S with (n0:=j) (l:=fs) (t:=FZero); auto. repeat rewrite combine_cons.
  apply MapR_cons; auto. apply MapR_refl. intros. destruct x as [g t]. apply in_combine_r in H6. simpl. apply TFFSub_Eq. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst t. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H7. destruct H7 as [y [H7 H8]]. subst x. apply in_seq in H8. destruct H8. contradict H8. inversion H8. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. simpl. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H7. inversion H7. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. rewrite Hf; auto. repeat rewrite firstn_length. rewrite Hf; auto. repeat rewrite firstn_length. rewrite Hf; auto.
  apply TFFSub_Eq. apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H7. inversion H7. apply le_not_lt. rewrite plus_comm. rewrite <- plus_assoc; auto. apply ST_Func. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H3; auto. rewrite <- firstn_skipn with (n:=j); auto. apply MapR_cons. apply MapR_refl. intros. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. auto. rewrite minus_Sn_m; auto.
  assert (forall x, In x (firstn j args)->In x args). intros. rewrite <- firstn_skipn with (n:=j); auto. rewrite firstn_S with (d:=Zero). rewrite <- app_assoc. simpl. assert (j<=n). apply lt_le_weak; auto. apply IHj in H5. clear IHj. replace (n-j) with (S(n-S j)) in H5. rewrite <- cons_seq in H5. simpl in H5. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H5. auto. apply TFFSub_Imps. apply MapR_map. intros. destruct x as [g t]. simpl. assert (In g fs). apply in_combine_l in H6; auto. assert (In t ts). apply in_combine_r in H6; auto. apply TFFSub_Eq; auto. apply ST_Func. apply MapR_app. apply MapR_refl. intros; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H9. destruct H9 as [y [H9 H10]]. subst x. apply in_seq in H10. destruct H10. contradict H9; inversion H9; auto. apply TFFSub_Eq. apply ST_Func. apply MapR_app; auto. apply MapR_cons; auto.
  apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6; inversion H6; auto. apply nVT_SubTerm. intros C. inversion C. contradict H9. auto. rewrite minus_Sn_m; auto. subst n; auto. Qed.
Theorem FRecu_Zero_spec: forall f g args l, WFFunc (S (length args)) (FRecu f g) -> Inf l (FuncT (FRecu f g) (Zero::args) == FuncT f args). Proof. intros. revert H. intros Hf. remember (newVar nil args nil) as v. assert (forall i a, v<=i->In a args->~VarTerm i a). intros. subst v. apply newVar_nVT with nil args nil; auto. clear Heqv. apply Inf_incl with nil; auto. cut (forall j, j<=length args->Inf nil (FuncT (FRecu f g) (Zero::firstn j args++map Var (seq (j+v) (length args-j)))==FuncT f (firstn j args++map Var (seq (j+v) (length args-j))))). intros. replace args with (firstn (length args) args++map Var (seq (length args+v) (length args-length args))). apply H0; auto. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r. auto. induction j. intros. simpl. rewrite <- minus_n_O; auto.
  intros. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. assert (j<=length args). apply lt_le_weak; auto. apply IHj in H1. clear IHj. replace (length args -j) with (S(length args - S j)) in H1. rewrite <- cons_seq in H1. simpl in H1. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H1. auto. apply TFFSub_Eq; apply ST_Func. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H. apply le_plus_r. rewrite <- firstn_skipn with (n:=j); auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H2. destruct H2 as [y [H3 H4]]. subst x. apply in_seq in H4. destruct H4. contradict H2. inversion H2. subst i y. auto. apply nVT_SubTerm. intros C. inversion C. destruct H6. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H. apply le_plus_r. rewrite <- firstn_skipn with (n:=j); auto.
  apply MapR_cons. apply MapR_refl. intros. apply in_map_iff in H2. destruct H2 as [y [H3 H4]]. subst x. apply in_seq in H4. destruct H4. apply nVT_SubTerm. contradict H2. inversion H2. subst i y; auto. auto. rewrite minus_Sn_m; auto. Qed.
Theorem FRecu_Succ_spec: forall f g args ti ty l, WFFunc (S (length args)) (FRecu f g) -> Inf l (FuncT (FRecu f g) (ti::args) == ty) -> Inf l (FuncT (FRecu f g) (Succ ti::args) == FuncT g (ty::ti::args)). Proof. intros. remember (newVar nil (ti::ty::args) nil) as v. assert (forall i a, v<=i->In a args->~VarTerm i a). intros. eapply newVar_nVT. subst v; eauto. right; right; auto. assert (forall i, v<=i->~VarTerm i ti). intros. subst v. eapply newVar_nVT; eauto. assert (forall i, v<=i->~VarTerm i ty). intros. subst v. eapply newVar_nVT; eauto. apply IMP with (FuncT (FRecu f g) (ti::args)==ty) nil l; auto. clear H0 Heqv l. remember (length args) as n. apply Ui with (FuncT (FRecu f g) ((#n+v)::args) == ty ==> FuncT (FRecu f g) (Succ (#n+v)::args) == FuncT g (ty::(#n+v)::args)) (n+v) ti. apply Ug; auto. apply Ui with (FuncT (FRecu f g) ((#n+v)::args) == (#S(n+v)) ==> FuncT (FRecu f g) (Succ (#n+v)::args) == FuncT g ((#S(n+v))::(#n+v)::args)) (S(n+v)) ty. apply Ug; auto.
  cut (forall j, j<=n->Inf nil (FuncT (FRecu f g) ((#n+v)::firstn j args++map Var (seq (j+v) (n-j))) == #S(n+v)==>FuncT (FRecu f g) (Succ (#n+v)::firstn j args++map Var (seq (j+v) (n-j)))==FuncT g ((#S(n+v))::(#n+v)::firstn j args++map Var (seq (j+v) (n-j))))). intros. replace args with (firstn n args++map Var (seq (n+v) (n-n))); auto. subst n. rewrite firstn_all. rewrite <- minus_n_n. rewrite app_nil_r; auto. induction j; intros. rewrite <- minus_n_O; simpl; auto. rewrite firstn_S with (d:=Zero); auto. rewrite <- app_assoc. simpl. assert (j<=n). apply lt_le_weak; auto. apply IHj in H4. replace (n-j) with (S(n-S j)) in H4. rewrite <- cons_seq in H4. simpl in H4. eapply Ui with (v:=j+v) (t:=nth j args Zero). apply Ug. eapply H4. auto.
  assert (forall x, In x (firstn j args)->In x args). intros. rewrite <- firstn_skipn with (n:=j). apply in_or_app; auto. apply TFFSub_Imp; apply TFFSub_Eq; try apply ST_Func; auto. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. apply nVT_SubTerm. apply H1; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6. inversion H6. auto. apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j. contradict H0; auto. apply nVT_SubTerm. intros C; inversion C. absurd (j+v<n+v). apply le_not_lt. rewrite H8; auto. apply plus_lt_compat_r; auto. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. contradict H6. inversion H6. auto. apply SubTerm_Succ.
  apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j; contradict H0; auto. apply MapR_cons. apply MapR_cons. apply MapR_app. apply MapR_refl. intros. auto. apply MapR_cons; auto. apply MapR_refl. intros. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. apply nVT_SubTerm. contradict H6; inversion H6; auto. apply nVT_SubTerm. intros C. inversion C. apply plus_reg_r in H8. subst j; contradict H0; auto. apply nVT_SubTerm. intros C; inversion C. absurd (j+v<n+v). apply le_not_lt. rewrite H8; auto. apply plus_lt_compat_r; auto. rewrite minus_Sn_m; auto. subst n; auto. 
  apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C; contradict H5; auto. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C. apply In_one in H7; subst t. inversion H6. contradict H9; auto. apply MapR_cons; auto. apply MapR_refl. intros. apply nVT_SubTerm. destruct H0; auto. subst x. intros C; inversion C. contradict H5; auto. apply TFFSub_Imp; apply TFFSub_Eq; auto; apply ST_Func; try repeat apply MapR_cons; auto; apply MapR_refl; intros; apply nVT_SubTerm; apply H1; auto. Qed.
Hint Resolve FProj_spec FComp_spec FRecu_Zero_spec FRecu_Succ_spec.

(* Expression theorem *)
Definition Func_function: forall F a, WFFunc a F -> {f: forall (l:list nat), length l=a -> nat|forall p l (H:length l=a), Inf p (FuncT F (map n2t l)==n2t (f l H))}. intros F. apply (Fix (well_founded_ltof Func funcDepth)) with (P:=fun F=>forall a, WFFunc a F-> {f|forall p l (H:length l=a), Inf p (FuncT F (map n2t l)==n2t (f l H))}). clear F. intros F IH a H. destruct F. exists (fun _ _=>0). intros. inversion H. subst a. destruct l. auto. inversion H1.
  exists (fun l _=> match l with |nil=>0 |a::l' => (S a) end). intros. inversion H. subst a. destruct l. inversion H1. inversion H1. destruct l. simpl. auto. inversion H2.
  exists (fun l _=> nth n l 0). intros. apply FProj_spec. rewrite map_length. rewrite H0. inversion H; auto. replace Zero with (n2t 0); auto. apply map_nth.
  destruct (IH F) with (a:=length l) as [fc Hc]. unfold ltof. simpl. auto. inversion H; auto. destruct (MapR_build (T:=Func) (U:=forall l:list nat, length l=a->nat)) with (l:=l) (R:=fun (G:Func) f=>forall p (l:list nat) (H:length l=a), Inf p (FuncT G (map n2t l)==n2t (f l H))) as [fs Hf]. intros. apply IH. unfold ltof. simpl. apply le_n_S. apply le_trans with (maxl (map funcDepth l)); auto. apply maxl_le. apply in_map_iff; exists x; auto. inversion H. apply Forall_forall with (x:=x) in H5; auto. assert (forall f, length (A:=nat) (map f fs)=length l). intros. rewrite map_length. apply MapR_length in Hf. auto. exists (fun a Ha => fc (map (fun f=>f a Ha) fs) (H0 (fun f=>f a Ha))). intros. apply Term_Eq_trans with (FuncT F (map n2t (map (fun f=>f l0 H1) fs))); auto. apply FComp_spec with a; auto. rewrite map_length; auto. rewrite map_map. replace l with (map id l); auto. apply MapR_map2. eapply MapR_trans; [|eapply Hf]. intros. apply H4. rewrite map_id; auto.
  destruct a. exfalso. inversion H. destruct (IH F1) with (a:=a) as [f1 Hf1]. unfold ltof. simpl; auto. inversion H; auto. destruct (IH F2) with (a:=S (S a)) as [f2 Hf2]. unfold ltof; simpl; auto. inversion H; auto. assert (decons:forall n (l:list nat), length l=S n->{e:nat & {m|l=e::m & length m=n}}). intros. destruct l. inversion H0. exists n0. exists l; auto. assert (Hi:forall (x y:nat) n l, length l=n->length (x::y::l) = (S (S n))). intros; simpl; auto. exists (fun args (Ha:length args=S a) => match decons a args Ha with existT _ i (exist2 _ _ arg _ Hb) => (fix rec (n:nat) : nat := match n with |O=>f1 arg Hb |S i'=> f2 (rec i'::i'::arg) (Hi (rec i') i' a arg Hb) end) i end). intros. destruct (decons a l H0) as [i [m H1 H2]]. subst l. clear H0. induction i. simpl. apply Term_Eq_trans with (FuncT F1 (map n2t m)). apply FRecu_Zero_spec; auto. rewrite map_length. rewrite H2; auto. apply Hf1.
  simpl. remember ((fix rec n:=match n with |0=>f1 m H2|S i'=>f2 (rec i'::i'::m) (Hi (rec i') i' a m H2) end) i) as y. apply Term_Eq_trans with (FuncT F2 (n2t y::n2t i::map n2t m)). apply FRecu_Succ_spec; auto. rewrite map_length. rewrite H2; auto. replace (n2t y::n2t i::map n2t m) with (map n2t (y::i::m)); auto. Defined.
Theorem Expression_theorem: forall F a args l, WFFunc a F -> length args=a -> Forall (fun arg=>exists n, Inf l (arg == n2t n)) args -> exists n, Inf l (FuncT F args == n2t n). Proof. intros. destruct (Func_function H) as [f Hf]. assert (exists nl, MapR (fun x y=>Inf l (y==n2t x)) nl args). clear H0. induction args. exists nil. auto. inversion H1. apply IHargs in H4. destruct H4 as [nl H5]. destruct H3 as [b H6]. exists (b::nl). auto. clear H1. destruct H2 as [nl H2]. assert (length nl=a). subst a. apply MapR_length in H2; auto. exists (f nl H1).  apply Term_Eq_trans with (FuncT F (map n2t nl)); auto. apply Term_Eq_sym. apply Term_Eq_args. replace args with (map id args). apply MapR_map2. eapply MapR_trans; [|eapply H2]. intros. simpl in H5. apply Term_Eq_sym; auto. apply map_id. Qed.

Theorem FSwap_spec: forall t u l f, WFFunc 2 f -> Inf l (FuncT (FSwap f) (t::u::nil) == FuncT f (u::t::nil)). Proof. intros. unfold FSwap. apply FComp_spec with (n:=2); auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply MapR_cons. apply MapR_cons; auto. apply FProj_spec; auto. Qed.
Theorem FPlus_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FPlus (t::u::nil) == n2t (i+j)). Proof. intros. remember (newVar nil (u::t::nil) nil) as v. assert (~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FPlus (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FPlus ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FPlus (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FPlus (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. clear l H H0 Heqv. induction i. simpl. apply Term_Eq_trans with (FuncT (FProj 0) (n2t j::nil)). apply FRecu_Zero_spec; auto. apply FProj_spec; auto.
  simpl. apply Term_Eq_trans with (FuncT (FComp FSucc (FProj 0::nil)) (n2t(i+j)::n2t i::n2t j::nil)). apply FRecu_Succ_spec; auto. apply FComp_spec with (n:=3); auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. Qed.
Theorem FMult_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FMult (t::u::nil) == n2t (i*j)). Proof. intros. remember (newVar nil (u::t::nil) nil) as v. assert (~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FMult (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FMult ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FMult (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FMult (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. clear l H H0 Heqv. induction i. simpl. apply Term_Eq_trans with (FuncT (FComp FZero nil) (n2t j::nil)). apply FRecu_Zero_spec; auto. apply FComp_spec with 1; auto.
  simpl. apply Term_Eq_trans with (FuncT (FComp FPlus (FProj 0::FProj 2::nil)) (n2t(i*j)::n2t i::n2t j::nil)). apply FRecu_Succ_spec; auto. apply Term_Eq_trans with (FuncT FPlus (n2t (i*j)::n2t j::nil)). apply FComp_spec with (n:=3); auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. rewrite plus_comm. apply FPlus_spec; auto. Qed.
Theorem FPow_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FPow (t::u::nil) == n2t (pow i j)). Proof. intros. remember (newVar nil (u::nil) nil) as v. assert (Hu:~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FPow (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FPow ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FPow (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FPow (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. unfold FPow. eapply Term_Eq_trans. eapply FSwap_spec. apply WFF_Recu; auto. apply WFF_Comp; auto. clear l H H0 Heqv v Hu.
  induction j; simpl. apply Term_Eq_trans with (FuncT (FComp FSucc (FComp FZero nil::nil)) (n2t i::nil)). apply FRecu_Zero_spec. apply WFF_Recu; auto. apply WFF_Comp; auto. apply FComp_spec with 1; auto. apply MapR_cons; auto. apply FComp_spec with 1; auto. apply Term_Eq_trans with (FuncT (FComp FMult (FProj 0::FProj 2::nil)) (n2t (pow i j)::n2t j::n2t i::nil)). apply FRecu_Succ_spec; auto. apply WFF_Recu; auto. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT FMult (n2t (pow i j)::n2t i::nil)). apply FComp_spec with 3; simpl; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. rewrite mult_comm. apply FMult_spec; auto. Qed.
Theorem FPred_spec: forall i t l, Inf l (t==n2t i) -> Inf l (FuncT FPred (t::nil) == n2t(pred i)). Proof. intros. apply Term_Eq_trans with (FuncT FPred (n2t i::nil)). apply Term_Eq_SubTerm with t (n2t i) 0 (FuncT FPred ((#0)::nil)); auto. clear H. apply Inf_incl with nil; auto. induction i. simpl. apply Term_Eq_trans with (FuncT FZero nil); auto. apply FRecu_Zero_spec; auto. simpl. apply Term_Eq_trans with (FuncT (FProj 1) ((FuncT FPred (n2t i::nil))::n2t i::nil)). apply FRecu_Succ_spec; auto. apply FProj_spec; auto. Qed.
Theorem FMinus_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FMinus (t::u::nil) == n2t (i-j)). Proof. intros. remember (newVar nil (u::nil) nil) as v. assert (Hu:~VarTerm v u). subst v; eapply newVar_nVT; eauto. apply Term_Eq_trans with (FuncT FMinus (n2t i::u::nil)). apply Term_Eq_SubTerm with t (n2t i) v (FuncT FMinus ((#v)::u::nil)); auto. apply Term_Eq_trans with (FuncT FMinus (n2t i::n2t j::nil)). apply Term_Eq_SubTerm with u (n2t j) 0 (FuncT FMinus (n2t i::(#0)::nil)); auto. apply Inf_incl with nil; auto. unfold FMinus. apply Term_Eq_trans with (FuncT (FRecu (FProj 0) (FComp FPred (FProj 0::nil))) (n2t j::n2t i::nil)). apply FSwap_spec. apply WFF_Recu; auto. apply WFF_Comp; auto. clear l H H0 Heqv v Hu.
  induction j. simpl. rewrite <- minus_n_O. apply Term_Eq_trans with (FuncT (FProj 0) (n2t i::nil)); auto. apply FRecu_Zero_spec. simpl. apply WFF_Recu; auto. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT (FComp FPred (FProj 0::nil)) (n2t (i-j)::n2t j::n2t i::nil)). apply FRecu_Succ_spec; auto. apply WFF_Recu; auto. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT FPred (n2t (i-j)::nil)). apply FComp_spec with (n:=3); auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; auto. simpl; auto. replace (i-S j) with (pred (i-j)). apply FPred_spec; auto. clear IHj. revert j. induction i; intros. auto. simpl. destruct j. simpl. rewrite <- minus_n_O; auto. auto. Qed.
Theorem FMax_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FMax (t::u::nil) == n2t (max i j)). Proof. intros. unfold FMax. apply Term_Eq_trans with (FuncT FPlus (n2t (i-j)::n2t j::nil)). apply FComp_spec with 2; auto. apply MapR_cons. apply MapR_cons; auto. apply Term_Eq_trans with u; auto. apply FMinus_spec; auto. replace (max i j) with (i-j+j). apply FPlus_spec; auto. destruct (le_lt_dec i j). rewrite max_r; auto. apply Nat.sub_0_le in l0. rewrite l0; auto. rewrite max_l; auto. rewrite plus_comm. symmetry. apply le_plus_minus; auto. Qed.
Theorem FMin_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FMin (t::u::nil) == n2t (min i j)). Proof. intros. unfold FMin. apply Term_Eq_trans with (FuncT FMinus (n2t i::n2t (i-j)::nil)). apply FComp_spec with 2; auto. apply MapR_cons. apply MapR_cons; auto. apply FMinus_spec; auto. apply Term_Eq_trans with t; auto. replace (min i j) with (i-(i-j)). apply FMinus_spec; auto. destruct (le_lt_dec i j). rewrite min_l; auto. apply Nat.sub_0_le in l0. rewrite l0. rewrite <- minus_n_O; auto. rewrite min_r; auto. replace (i-(i-j)) with (j+(i-j)-(i-j)). apply Nat.add_sub. f_equal. rewrite <- le_plus_minus; auto. Qed.
Theorem FAbs_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FAbs (t::u::nil) == n2t (if le_lt_dec i j then j-i else i-j)). Proof. intros. unfold FAbs. replace (if le_lt_dec i j then j-i else i-j) with ((i-j)+(j-i)). apply Term_Eq_trans with (FuncT FPlus (n2t (i-j)::n2t (j-i)::nil)). apply FComp_spec with 2; auto. apply MapR_cons. apply MapR_cons; auto. apply Term_Eq_trans with (FuncT FMinus (u::t::nil)). apply FSwap_spec; auto. apply FMinus_spec; auto. apply FMinus_spec; auto. apply FPlus_spec; auto. destruct (le_lt_dec i j). apply Nat.sub_0_le in l0. rewrite l0. auto. replace (j-i) with 0. rewrite plus_comm; auto. apply lt_le_weak in l0. apply Nat.sub_0_le in l0. auto. Qed.
Theorem FSign_spec: forall i t l, Inf l (t==n2t i) -> Inf l (FuncT FSign (t::nil) == n2t(if nat_eq_dec i 0 then 0 else 1)). Proof. intros. apply Term_Eq_trans with (FuncT FSign (n2t i::nil)). apply Term_Eq_SubTerm with t (n2t i) 0 (FuncT FSign ((#0)::nil)); auto. induction i; simpl. apply FRecu_Zero_spec; auto. apply Term_Eq_trans with (FuncT (FComp FSucc (FComp FZero nil::nil)) (FuncT FSign (n2t i::nil)::n2t i::nil)). apply FRecu_Succ_spec; auto. apply FComp_spec with (n:=2); simpl; auto. apply MapR_cons; auto. apply FComp_spec with 2; auto. Qed.
Theorem FSign_spec1: forall i t l, Inf l (t==n2t i) -> i<> 0 -> Inf l (FuncT FSign (t::nil) == n2t 1). Proof. intros. replace 1 with (if nat_eq_dec i 0 then 0 else 1). apply FSign_spec; auto. destruct (nat_eq_dec i 0); auto; contradiction. Qed.
Theorem FSign_spec2: forall t l, Inf l (t==n2t 0) -> Inf l (FuncT FSign (t::nil) == n2t 0). Proof. intros. replace 0 with (if nat_eq_dec 0 0 then 0 else 1). apply FSign_spec; auto. auto. Qed.
Theorem FNeg_spec: forall i t l, Inf l (t==n2t i) -> Inf l (FuncT FNeg (t::nil) == n2t(if nat_eq_dec i 0 then 1 else 0)). Proof. intros. apply Term_Eq_trans with (FuncT FNeg (n2t i::nil)). apply Term_Eq_SubTerm with t (n2t i) 0 (FuncT FNeg ((#0)::nil)); auto. apply Inf_incl with nil; auto. clear H l. induction i; simpl. apply Term_Eq_trans with (FuncT (FComp FSucc (FZero::nil)) nil). apply FRecu_Zero_spec; auto. apply FComp_spec with 0; auto. apply Term_Eq_trans with (FuncT (FComp FZero nil) (FuncT FNeg (n2t i::nil)::n2t i::nil)). apply FRecu_Succ_spec; auto. apply FComp_spec with (n:=2); simpl; auto. Qed.
Theorem FNeg_spec1: forall t l, Inf l (t==n2t 0) -> Inf l (FuncT FNeg (t::nil) == n2t 1). Proof. intros. replace 1 with (if nat_eq_dec 0 0 then 1 else 0); auto. apply FNeg_spec; auto. Qed.
Theorem FNeg_spec2: forall i t l, Inf l (t==n2t i) -> i<>0 -> Inf l (FuncT FNeg (t::nil) == n2t 0). Proof. intros. replace 0 with (if nat_eq_dec i 0 then 1 else 0); auto. apply FNeg_spec; auto. destruct (nat_eq_dec i 0); auto; contradiction. Qed.
Theorem FEq_spec: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FEq (t::u::nil) == n2t (if nat_eq_dec i j then 1 else 0)). Proof. intros. unfold FEq. apply Term_Eq_trans with (FuncT FNeg (n2t (if le_lt_dec i j then j-i else i-j)::nil)). apply FComp_spec with 2; auto. apply MapR_cons; auto. apply FAbs_spec; auto. destruct (le_lt_dec i j). replace (if nat_eq_dec i j then 1 else 0) with (if nat_eq_dec (j-i) 0 then 1 else 0). apply FNeg_spec; auto. destruct (nat_eq_dec (j-i) 0); destruct (nat_eq_dec i j); auto. contradict n. apply le_antisym; auto. apply Nat.sub_0_le; auto. contradict n. subst j. rewrite <- minus_n_n; auto. replace (if nat_eq_dec i j then 1 else 0) with (if nat_eq_dec (i-j) 0 then 1 else 0). apply FNeg_spec; auto. destruct (nat_eq_dec (i-j) 0); destruct (nat_eq_dec i j); auto. contradict l0. apply le_not_lt. apply Nat.sub_0_le; auto. contradict l0; subst j; auto. Qed.
Theorem FEq_spec1: forall i t u l, Inf l (t==n2t i) -> Inf l (u==n2t i) -> Inf l (FuncT FEq (t::u::nil) == n2t 1). Proof. intros. replace 1 with (if nat_eq_dec i i then 1 else 0). apply FEq_spec; auto. destruct (nat_eq_dec i i); auto. contradict n; auto. Qed.
Theorem FEq_spec2: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> i<>j -> Inf l (FuncT FEq (t::u::nil) == n2t 0). Proof. intros. replace 0 with (if nat_eq_dec i j then 1 else 0). apply FEq_spec; auto. destruct (nat_eq_dec i j); auto; contradiction. Qed.
Theorem FNEq_spec1: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> i<>j -> Inf l (FuncT FNEq (t::u::nil) == n2t 1). Proof. intros. unfold FNEq. apply Term_Eq_trans with (FuncT FNeg (n2t 0::nil)). apply FComp_spec with 2; auto. apply MapR_cons; auto. apply FEq_spec2 with i j; auto. apply FNeg_spec1; auto. Qed.
Theorem FNEq_spec2: forall i t u l, Inf l (t==n2t i) -> Inf l (u==n2t i) -> Inf l (FuncT FNEq (t::u::nil) == n2t 0). Proof. intros. unfold FNEq. apply Term_Eq_trans with (FuncT FNeg (n2t 1::nil)). apply FComp_spec with 2; auto. apply MapR_cons; auto. apply FEq_spec1 with i; auto. apply FNeg_spec2 with 1; auto. Qed.
Hint Resolve FPlus_spec FMult_spec FPow_spec FPred_spec FSwap_spec FMinus_spec FMax_spec FMin_spec FAbs_spec FSign_spec FSign_spec1 FSign_spec2 FNeg_spec FNeg_spec1 FNeg_spec2 FEq_spec FEq_spec1 FEq_spec2 FNEq_spec1 FNEq_spec2.

Theorem FLe_spec1: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> i<= j -> Inf l (FuncT FLe (t::u::nil) == n2t 1). Proof. intros. unfold FLe. apply Term_Eq_trans with (FuncT FNeg (n2t (i-j)::nil)). apply FComp_spec with 2; auto. apply FNeg_spec1. replace (i-j) with 0; auto. apply Nat.sub_0_le in H1; auto. Qed.
Theorem FLe_spec2: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> j < i -> Inf l (FuncT FLe (t::u::nil) == n2t 0). Proof. intros. unfold FLe. apply Term_Eq_trans with (FuncT FNeg (n2t (i-j)::nil)). apply FComp_spec with 2; auto. apply FNeg_spec2 with (i-j); auto. contradict H1. apply Nat.sub_0_le in H1; auto. Qed.
Theorem FLand_spec1: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> i<>0 -> j<>0 -> Inf l (FuncT FLand (t::u::nil) == n2t 1). Proof. intros. unfold FLand. apply Term_Eq_trans with (FuncT FSign (n2t (i*j)::nil)). apply FComp_spec with 2; auto. apply FSign_spec1 with (i*j); auto. intros C. apply mult_is_O in C. destruct C; contradiction. Qed.
Theorem FLand_spec2: forall j t u l, Inf l (t==n2t 0) -> Inf l (u==n2t j) -> Inf l (FuncT FLand (t::u::nil) == n2t 0). Proof. intros. unfold FLand. apply Term_Eq_trans with (FuncT FSign (n2t (0*j)::nil)). apply FComp_spec with 2; auto. apply FSign_spec2; auto. Qed.
Theorem FLand_spec3: forall i t u l, Inf l (t==n2t i) -> Inf l (u==n2t 0) -> Inf l (FuncT FLand (t::u::nil) == n2t 0). Proof. intros. unfold FLand. apply Term_Eq_trans with (FuncT FSign (n2t (i*0)::nil)). apply FComp_spec with 2; auto. rewrite mult_0_r. apply FSign_spec2; auto. Qed.
Theorem FLor_spec1: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> i<>0 -> Inf l (FuncT FLor (t::u::nil) == n2t 1). Proof. intros. unfold FLor. apply Term_Eq_trans with (FuncT FSign (n2t (i+j)::nil)). apply FComp_spec with 2; auto. apply FSign_spec1 with (i+j); auto. contradict H1. destruct i; auto. inversion H1. Qed.
Theorem FLor_spec2: forall i j t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> j<>0 -> Inf l (FuncT FLor (t::u::nil) == n2t 1). Proof. intros. unfold FLor. apply Term_Eq_trans with (FuncT FSign (n2t (i+j)::nil)). apply FComp_spec with 2; auto. apply FSign_spec1 with (i+j); auto. contradict H1. destruct j; auto. rewrite <- plus_n_Sm in H1. inversion H1. Qed.
Theorem FLor_spec3: forall t u l, Inf l (t==n2t 0) -> Inf l (u==n2t 0) -> Inf l (FuncT FLor (t::u::nil) == n2t 0). Proof. intros. unfold FLor. apply Term_Eq_trans with (FuncT FSign (n2t (0+0)::nil)). apply FComp_spec with 2; auto. apply FSign_spec2; auto. Qed.
Hint Resolve FLe_spec1 FLe_spec2 FLand_spec1 FLand_spec2 FLand_spec3 FLor_spec1 FLor_spec2 FLor_spec3.

Theorem FEx_spec1: forall a nl args f l, WFFunc (S a) f -> length nl=a -> MapR (fun k a=>Inf l (a==n2t k)) nl args -> forall i t j, Inf l (t==n2t i) -> j<>0 -> Inf l (FuncT f (t::args) == n2t j) -> forall n u, i<n -> Inf l (u==n2t n) -> Inf l (FuncT (FEx a f) (u::args) == n2t 1). Proof. intros. assert (Hl:length args=a). apply MapR_length in H1; subst a; auto. remember (newVar nil (t::u::args) nil) as v. apply Term_Eq_trans with (FuncT (FEx a f) (n2t n::args)). apply Term_Eq_SubTerm with u (n2t n) v (FuncT (FEx a f) ((#v)::args)); auto; apply ST_Func; apply MapR_cons; auto; apply MapR_refl; intros; apply nVT_SubTerm; eapply newVar_nVT; subst v; eauto. unfold FEx. clear H6. assert (Hw:WFFunc (S (S a)) (FComp f (FProj 1 :: map FProj (seq 2 a)))). apply WFF_Comp; auto. simpl. rewrite map_length. rewrite seq_length; auto. apply Forall_cons. auto. apply Forall_forall. intros. apply in_map_iff in H6. destruct H6 as [y [H6 H7]]. subst x. apply in_seq in H7. destruct H7. apply WFF_Proj; auto.
  induction n. inversion H5. apply le_S_n in H5. apply le_lt_or_eq in H5. destruct H5. simpl. apply Term_Eq_trans with (FuncT (FComp FLor (FProj 0::FComp f (FProj 1::map FProj (seq 2 a))::nil)) (n2t 1::n2t n::args)). apply FRecu_Succ_spec; auto. apply WFF_Recu; auto. rewrite Hl; auto. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT FLor (n2t 1::FuncT f (n2t n::args)::nil)). apply FComp_spec with (S(S a)); auto. apply WFF_Comp; auto. simpl; auto. apply MapR_cons; auto. apply MapR_cons; auto. apply FComp_spec with (S(S a)); simpl; auto. apply MapR_cons. apply combine_MapR. rewrite map_length; rewrite seq_length; auto. apply Forall_forall. intros. destruct x as [g arg]. apply In_nth with (d:=(FProj 0, Zero)) in H6. destruct H6 as [idx [H6 H7]]. rewrite combine_length in H6. rewrite min_r in H6. rewrite combine_nth in H7. inversion  H7. subst g arg. simpl. clear H7. rewrite map_nth. rewrite seq_nth. simpl. apply FProj_spec.  simpl; auto. simpl; auto. rewrite <- Hl; auto. rewrite map_length; rewrite seq_length; auto. rewrite map_length; rewrite seq_length; rewrite Hl; auto. 
  apply FProj_spec; simpl; auto. apply FProj_spec; simpl; auto. assert (exists k, Inf l (FuncT f (n2t n::args)==n2t k)). apply Expression_theorem with (S a); auto. simpl; auto. apply Forall_cons. exists n; auto. apply Forall_forall. intros arg Ha. apply In_nth with (d:=Zero) in Ha. destruct Ha as [idx [Ha Hb]]. subst arg. exists (nth idx nl 0). apply MapR_nth with (i:=idx) (dt:=0) (du:=Zero) in H1; auto. subst a. rewrite <- Hl; auto. destruct H6 as [k H6]. apply FLor_spec1 with 1 k; auto.
  (* i=n *) subst i. clear IHn. assert (exists k, Inf l (FuncT (FRecu (FComp FZero nil) (FComp FLor (FProj 0::FComp f (FProj 1::map FProj (seq 2 a))::nil))) (n2t n::args) == n2t k)). apply Expression_theorem with (S a); auto. apply WFF_Recu; auto. apply WFF_Comp; auto. simpl; auto. apply Forall_cons; auto. exists n; auto. apply Forall_forall. intros. apply In_nth with (d:=Zero) in H5. destruct H5 as [idx [H5 H6]]. subst x. exists (nth idx nl 0). apply MapR_nth with (i:=idx) (du:=Zero) (dt:=0) in H1; auto. subst a. rewrite <- Hl; auto. 
  simpl. destruct H5 as [k H5]. apply Term_Eq_trans with (FuncT (FComp FLor (FProj 0::FComp f (FProj 1::map FProj (seq 2 a))::nil)) (n2t k::n2t n::args)). apply FRecu_Succ_spec; auto. rewrite Hl. apply WFF_Recu; auto. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT FLor (n2t k::FuncT f (n2t n::args)::nil)). apply FComp_spec with (S(S a)). apply WFF_Comp; auto. simpl; auto. apply MapR_cons. apply MapR_cons; auto. apply FComp_spec with (S (S a)); auto. simpl; auto. apply MapR_cons; auto. apply combine_MapR. rewrite map_length; rewrite seq_length; auto. apply Forall_forall. intros. destruct x as [g arg]. apply In_nth with (d:=(FProj 0,Zero)) in H6. destruct H6 as [idx [H6 H7]]. rewrite combine_length in H6. rewrite min_r in H6. rewrite combine_nth in H7. inversion H7. subst g arg. clear H7. simpl. rewrite map_nth. rewrite seq_nth. simpl. apply FProj_spec; auto. simpl; auto. rewrite <- Hl; auto. rewrite map_length; rewrite seq_length; auto. rewrite map_length; rewrite seq_length; rewrite Hl; auto.
  apply FProj_spec; auto. simpl; auto. apply FProj_spec; auto. simpl; auto. apply FLor_spec2 with k j; auto. apply Term_Eq_trans with (FuncT f (t::args)); auto. apply Term_Eq_args. apply MapR_cons. apply MapR_refl; auto. apply Term_Eq_sym; auto. Qed.
Theorem FEx_spec2: forall a nl args f l, WFFunc (S a) f -> length nl=a -> MapR (fun k a=>Inf l (a==n2t k)) nl args -> forall n t, Inf l (t==n2t n) -> (forall i, i<n -> Inf l (FuncT f (n2t i::args) == n2t 0)) -> Inf l (FuncT (FEx a f) (t::args) == n2t 0). Proof. intros. assert (Hl:length args=a). apply MapR_length in H1; subst a; auto. remember (newVar nil (t::args) nil) as v. apply Term_Eq_trans with (FuncT (FEx a f) (n2t n::args)). apply Term_Eq_SubTerm with t (n2t n) v (FuncT (FEx a f) ((#v)::args)); auto; apply ST_Func; apply MapR_cons; auto; apply MapR_refl; intros; apply nVT_SubTerm; eapply newVar_nVT; subst v; eauto. unfold FEx. clear H2. assert (Hw:WFFunc (S (S a)) (FComp f (FProj 1 :: map FProj (seq 2 a)))). apply WFF_Comp; auto. simpl. rewrite map_length. rewrite seq_length; auto. apply Forall_cons. auto. apply Forall_forall. intros. apply in_map_iff in H2. destruct H2 as [y [H2 H4]]. subst x. apply in_seq in H4. destruct H4. apply WFF_Proj; auto.
  induction n. simpl. apply Term_Eq_trans with (FuncT (FComp FZero nil) args). apply FRecu_Zero_spec; auto. apply WFF_Recu; auto. rewrite Hl. apply WFF_Comp; auto. apply FComp_spec with (n:=a); auto. simpl. apply Term_Eq_trans with (FuncT (FComp FLor (FProj 0::FComp f (FProj 1::map FProj (seq 2 a))::nil)) (n2t 0::n2t n::args)). apply FRecu_Succ_spec; auto. apply WFF_Recu; auto. rewrite Hl. apply WFF_Comp; auto. apply Term_Eq_trans with (FuncT FLor (n2t 0::FuncT f (n2t n::args)::nil)). apply FComp_spec with (S(S a)); auto. apply WFF_Comp; auto. simpl; auto. apply MapR_cons. apply MapR_cons; auto. apply FComp_spec with (S(S a)); auto. simpl; auto. apply MapR_cons. apply combine_MapR. rewrite map_length; rewrite seq_length; auto. apply Forall_forall. intros. apply In_nth with (d:=(FProj 0,Zero)) in H2. destruct x as [g arg]. simpl. destruct H2 as [idx [H4 H5]]. rewrite combine_nth in H5. inversion H5. subst g arg. clear H5. rewrite combine_length in H4. rewrite min_r in H4.
  rewrite map_nth. rewrite seq_nth. simpl. apply FProj_spec; auto. simpl; auto. rewrite <- Hl; auto. rewrite Hl. rewrite map_length; rewrite seq_length; auto. rewrite map_length; rewrite seq_length; auto. apply FProj_spec; auto. simpl; auto. apply FProj_spec; simpl; auto. apply FLor_spec3; auto. Qed.
Hint Resolve FEx_spec1 FEx_spec2.

Theorem FRem_spec1: forall i j (nz:j<>0) t u l, Inf l (t==n2t i) -> Inf l (u==n2t j) -> Inf l (FuncT FRem (t::u::nil) == n2t (modN nz i)). Proof. intros. apply Term_Eq_trans with (FuncT FRem (n2t i::n2t j::nil)). apply Term_Eq_args; auto. clear H H0. unfold FRem. induction i. simpl. apply Term_Eq_trans with (FuncT (FComp FZero nil) (n2t j::nil)). apply FRecu_Zero_spec; auto. replace (modN nz 0) with 0. apply FComp_spec with 1; auto. unfold modN. destruct (divmod j 0) as [[q [r [H1 H2] H3]]|H1]. destruct r; auto. rewrite plus_comm in H1; inversion H1. contradiction. simpl. apply Term_Eq_trans with (FuncT (FComp FMult (FComp FSucc (FProj 0::nil)::FComp FNEq (FProj 2::FComp FSucc (FProj 0::nil)::nil)::nil)) (n2t (modN nz i)::n2t i::n2t j::nil)). apply FRecu_Succ_spec; auto. apply Term_Eq_trans with (FuncT FMult (n2t (S(modN nz i))::FuncT FNEq (n2t j::n2t (S(modN nz i))::nil)::nil)). apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; auto.
  apply MapR_cons. apply MapR_cons; auto. apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply MapR_cons. apply MapR_cons; auto. apply Term_Eq_trans with (FuncT FSucc (n2t (modN nz i)::nil)). apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. auto. apply FProj_spec; auto. apply Term_Eq_trans with (FuncT FSucc (n2t (modN nz i)::nil)); simpl; auto. apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. destruct (nat_eq_dec j (S (modN nz i))) as [Hn|Hn]. rewrite <- Hn. apply Term_Eq_trans with (FuncT FMult (n2t j::n2t 0::nil)). apply Term_Eq_args. apply MapR_cons; auto. apply MapR_cons; auto. apply FNEq_spec2 with j; auto. replace (modN nz (S i)) with 0. replace 0 with (j*0) at 2; auto. unfold modN. destruct (divmod j (S i)) as [[q [r [H1 H2] H3]]|H1]; [|contradiction]. unfold modN in Hn. destruct (divmod j i) as [[q' [r' [H4 H5] H6]]|H4]; [|contradiction]. assert (S i=S (q'*j+r')). subst i; auto. rewrite plus_n_Sm in H. rewrite <- Hn in H.
 replace (q'*j+j) with ((S q')*j+0) in H. apply H3 in H; auto. destruct H; auto. rewrite plus_comm; simpl; auto. apply Term_Eq_trans with (FuncT FMult (n2t (S (modN nz i))::n2t 1::nil)). apply Term_Eq_args. apply MapR_cons; auto. apply MapR_cons; auto. apply FNEq_spec1 with j (S (modN nz i)); auto. replace (modN nz (S i)) with (S (modN nz i)*1); auto. rewrite mult_1_r. unfold modN. unfold modN in Hn. destruct (divmod j i) as [[q [r [H1 H2] H3]]|H1]; [|contradiction]. destruct (divmod j (S i)) as [[q' [r' [H4 H5] H6]]|H4]; [|contradiction]. assert (S i=S(q*j+r)). subst i; auto. rewrite plus_n_Sm in H. apply H6 in H. destruct H; auto. apply le_lt_or_eq in H2. destruct H2; auto. contradict Hn; auto. Qed. 
Theorem FRem_spec2: forall i t u l, Inf l (t==n2t i) -> Inf l (u==n2t 0) -> Inf l (FuncT FRem (t::u::nil) == n2t i).  Proof. intros. apply Term_Eq_trans with (FuncT FRem (n2t i::n2t 0::nil)). apply Term_Eq_args; auto. clear H H0. unfold FRem. induction i. simpl. apply Term_Eq_trans with (FuncT (FComp FZero nil) (Zero::nil)). apply FRecu_Zero_spec; auto. apply FComp_spec with 1; auto. simpl. apply Term_Eq_trans with (FuncT (FComp FMult (FComp FSucc (FProj 0::nil)::FComp FNEq (FProj 2::FComp FSucc (FProj 0::nil)::nil)::nil)) (n2t i::n2t i::n2t 0::nil)). apply FRecu_Succ_spec; auto. apply Term_Eq_trans with (FuncT FMult (n2t (S i)::FuncT FNEq (n2t 0::n2t (S i)::nil)::nil)). apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; auto.
  apply MapR_cons. apply MapR_cons; auto. apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply Forall_cons; auto. apply Forall_cons; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply MapR_cons; auto. simpl. apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. simpl. apply FComp_spec with 3; auto. apply WFF_Comp; auto. apply MapR_cons; auto. apply FProj_spec; simpl; auto. apply Term_Eq_trans with (FuncT FMult (n2t (S i)::n2t 1::nil)). apply Term_Eq_args. apply MapR_cons; auto. apply MapR_cons; auto. apply FNEq_spec1 with 0 (S i); auto. replace (Succ (n2t i)) with (n2t ((S i)*1)); auto. rewrite mult_1_r; auto. Qed.
Hint Resolve FRem_spec1 FRem_spec2.
